## Algorithm

### 数据结构

**并发集合了解哪些？**

非阻塞列表 ConcurrentLinkedDeque

阻塞列表 LinkedBlockingDeque

用在生产者与消费者数据的阻塞列表	LinkedTransferQueue

使用优先级排序元素的阻塞列表 PriorityBlockingQueue

存储延迟元素的阻塞 DelayQueue

非阻塞导航的map ConcurrentSkipListMap

随机数 ThreadLocalRandom

原子变量 AtomicLong & AtomicIntegerArray

**列举java的集合以及集合之间的继承关系**

Collection下三个子类 List,Set.Queue;List下三个子类ArrayList,LinkedList,Vector,Set下一个子类HashSet

Map下两个子类 HashMap HashTable(已经被淘汰);HashMap线程不安全,如果需要线程安全使用ConcurrentHashMap.

**集合类以及集合框架**



**容器类介绍以及之间的区别（容器类估计很多人没听这个词，Java容器主要可以划分为4个部分：List列表、Set集合、Map映射、工具类（Iterator迭代器、Enumeration枚举类、Arrays和Collections），具体的可以看看这篇博文 Java容器类 http://alexyyek.github.io/2015/04/06/Collection/）**
**List,Set,Map的区别**
**List和Map的实现方式以及存储方式**
**HashMap的实现原理**
**HashMap数据结构？**
**HashMap源码理解**
**HashMap如何put数据（从HashMap源码角度讲解）？**
**HashMap怎么手写实现？**
**ConcurrentHashMap的实现原理**
**ArrayMap和HashMap的对比**
**HashTable实现原理**
**TreeMap具体实现**
**HashMap和HashTable的区别**

​	

**HashMap与HashSet的区别**



**HashSet与HashMap怎么判断集合元素重复？**



**集合Set实现Hash怎么防止碰撞**
**ArrayList和LinkedList的区别，以及应用场景**
**数组和链表的区别**
**二叉树的深度优先遍历和广度优先遍历的具体实现**
**堆的结构**
**堆和树的区别**
**堆和栈在内存中的区别是什么(解答提示：可以从数据结构方面以及实际实现方面两个方面去回答)？**
**什么是深拷贝和浅拷贝**
**手写链表逆序代码**
**讲一下对树，B+树的理解**
**讲一下对图的理解**
**判断单链表成环与否？**
**链表翻转（即：翻转一个单项链表）**
**合并多个单有序链表（假设都是递增的）**

### 基本算法

**排序算法有哪些？**

插入排序（直接插入排序、[链表](http://baike.baidu.com/view/549479.htm)插入排序、分段/二分/折半插入排序、希尔排序/缩小增量排序）、冒泡排序、快速排序、简单选择排序、归并排序、二叉树排序、基数排序等。

**最快的排序算法是哪个？**

**快速选择算法**

**手写一个冒泡排序**
**手写快速排序代码**
**快速排序的过程、时间复杂度、空间复杂度**
**手写堆排序**
**堆排序过程、时间复杂度及空间复杂度**
**写出你所知道的排序算法及时空复杂度，稳定性**
**二叉树给出根节点和目标节点，找出从根节点到目标节点的路径**
**给阿里2万多名员工按年龄排序应该选择哪个算法？**
**GC算法(各种算法的优缺点以及应用场景)**
**蚁群算法与蒙特卡洛算法**
**子串包含问题(KMP 算法)写代码实现**
**一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法**
**万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)**
**百度POI中如何试下查找最近的商家功能(提示：坐标镜像+R树)。**
**两个不重复的数组集合中，求共同的元素。**
**两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？**
**一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法**
**一张Bitmap所占内存以及内存占用的计算**
**2000万个整数，找出第五十大的数字？**

​	假设里面有很多重复的数字,使用hash进行存储,去掉重复数字,然后以10000个数字为一组创建堆,找到每堆里面最大的50的数字,最后把这50x堆数进行排序找到第五十,快速选择算法

**烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？**

​	3根绳子 第一根点一头 第二根点两头 第二根30分钟点完了 点第一根的另一个头 第一根点完了45分钟 第三根两头同时点 30分钟 45+30=75分钟

**求1000以内的水仙花数以及40亿以内的水仙花数**

**5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同**

**时针走一圈，时针分针重合几次**
**N*N的方格纸,里面有多少个正方形**      
**x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完？**

**编一个判别质数的函数,如果是质数,函数的返回值为1,否则为0**

**编写一个函数,输入两个正整数,输出最大公约数和最小公倍数**

**一张一元纸币兑换成一分,二分和五分的硬币,假定每种至少一枚,编程序计算共有多少种兑换方法并打印各种兑换方法**

**编写一个函数,在屏幕上打印出下列图形**

​**                       x**

​**                     xxx**

​                  **xxxxx**

​                 **xxxxxxx**

​               **xxxxxxxxx**

**​              xxxxxxxxxxx**

```java
	public static void main(String[] args) {
        int x = 10;
        for (int i = 0; i < x; i++) {
            for (int j = 0; j < x - i-1; j++) {
                System.out.print(" ");
            }
            for (int j = 0; j < 2 * i + 1; j++) {
                System.out.print("x");
            }
            System.out.println();
        }
    }
```

**一个正整数有可能被表示为n(n>=2)个连续正整数之和,如:**

**15=1+2+3+4+5**

**15=4+5=6**

**15=7+8**

**请编写程序,根据输入的任何一个正整数,找出符合这种要求的所有连续正整数序列,**

**如 输入 15**

**输出**

 **1 2 3 4 5**

 **4 5 6**

 **7 8**

**输入16 输出NONE**

**分解质因数 输入90 打印出90=2x3x3x5**

**打印杨辉三角形**

**​						1**

**					1		1**

**​				1		2		1**

**​			1		3		3		1**

**​		1		4		6		4		1**

**​	1		5		10		10		5		1**

**有n个人围成一圈,顺序拍号,从第一个人开始报数(从1到3报数),凡报到3的人退出圈子,问最后留下的是原来第几号的那位**

**两个兵乓球队进行比赛,各处三人,甲队为a,b,c三人,乙队为x,y,z三人,已抽签决定比赛名单,有人向队员打听比赛的名单,a说他不和x比,c说他不和x,z比,请编程序找出三队选手的名单.**

## JAVA

### 	基础

**==和equals()和hashCode()的区别**

​	==:对于基本数据类型比较值是否相等,引用数据类型比较是否是同一个对象,即地址值是否一样

​	equals():Object.equals()默认调用==,部分情况并不能满足条件,String重写.equals内容,使用while循环打成char数组比较内部值

​	hashCode():计算这个值的哈希码,equals()相等则hashCode()一定相等,hashCode()相等,equals()不一定相等

**int、char、long各占多少字节数**

​	char 16位2个字节 

​	byte 8位1个字节 

​	short 16位2个字节

​	int 32位4个字节 

​	long 64位8个字节 

​	float 32位 4个字节 

​	double 64位8个字节
**int与integer的区别**

​	1.Integer是int的包装类,int是java的一种基本数据类型

​	2.Integer变量必须实例化后才能使用,int不需要

​	3.Integer是对象的引用,new的时候出个新对象,有地址,int是直接储存数据值

​	4.Integer默认是null,int默认是0

​	5.Integer的比较{

​		a.new出来的Integer对象不相等

​		b.和int类型比较会比较值(自动装箱)

​		c.new出来的Integer对象和直接赋值的Integer对象不相等

​		d.两个非new生成的对象在-127~128之间,会相等,因为cache

​		}

**探探对java多态的理解**	

​	前提条件:有继承.子类重写父类方法(去掉super,不然先执行父类),父类引用指向子类对象

​	结果:调用方法,执行子类方法

**String、StringBuffer、StringBuilder区别**

​	对String修改等于创建了新变量,如果修改多的话建议使用Stringbuffer或者StringBuilder,StringBuilder相比较起StringBuffer速度更快,线程不安全(源码的注释上写的).用在字符串缓冲区被单个线程使用的时候.

**什么是内部类？内部类的作用**

​	定义在一个类里面的类,kotlin语言要加inner关键字,这个类仍然是一个独立的类,在编译之后内部类会被编译成独立的.class文件只不过前面冠以

**抽象类和接口区别**
**抽象类的意义**
**抽象类与接口的应用场景**
**抽象类是否可以没有方法和属性？**
**接口的意义**
**泛型中extends和super的区别**
**父类的静态方法能否被子类重写**
**进程和线程的区别**
**final，finally，finalize的区别**
**序列化的方式**
**Serializable 和Parcelable 的区别**
**静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？**
**静态内部类的设计意图**
**成员内部类、静态内部类、局部内部类和匿名内部类的理解，以及项目中的应用**
**谈谈对kotlin的理解**
**闭包和局部内部类的区别**
**string 转换成 integer的方式及原理**

**WeakReference**

1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。

Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

2.JDK和JRE的区别是什么？

Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。

3.”static”关键字是什么意思？Java中是否可以覆盖(override)一个private或者是static的方法？

“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例变量的情况下被访问。
Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

4.是否可以在static环境中访问非static变量？

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

5.Java支持的数据类型有哪些？什么是自动拆装箱？

Java语言支持的8中基本数据类型是：

byte
short
int
long
float
double
boolean
char
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer，double转化成double，等等。反之就是自动拆箱。

6.Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？

Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。

7.Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？

当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。

Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。

Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。

8.Java支持多继承么？

不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。

9.接口和抽象类的区别是什么？

Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：

接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
类可以实现很多个接口，但是只能继承一个抽象类
类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
抽象类可以在不提供接口方法实现的情况下实现接口。
Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。
也可以参考JDK8中抽象类和接口的区别

10.什么是值传递和引用传递？

对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。

对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。

Java线程

11.进程和线程的区别是什么？

进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

12.创建线程有几种不同的方式？你喜欢哪一种？为什么？

有三种方式可以用来创建线程：

继承Thread类
实现Runnable接口
应用程序可以使用Executor框架来创建线程池
实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。

13.概括的解释下线程的几种可用状态。

线程在执行过程中，可以处于下面几种状态：

就绪(Runnable):线程准备运行，不一定立马就能开始执行。
运行中(Running)：进程正在执行线程的代码。
等待中(Waiting):线程处于阻塞的状态，等待外部的处理结束。
睡眠中(Sleeping)：线程被强制睡眠。
I/O阻塞(Blocked on I/O)：等待I/O操作完成。
同步阻塞(Blocked on Synchronization)：等待获取锁。
死亡(Dead)：线程完成了执行。
14.同步方法和同步代码块的区别是什么？

在Java语言中，每一个对象有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。

15.在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

监视器和锁在Java虚拟机中是一块使用的。监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

16.什么是死锁(deadlock)？

两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。

17.如何确保N个线程可以访问N个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

Java集合类

18.Java集合类框架的基本接口有哪些？

Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：

Collection：代表一组对象，每一个对象都是它的子元素。
Set：不包含重复元素的Collection。
List：有顺序的collection，并且可以包含重复元素。
Map：可以把键(key)映射到值(value)的对象，键不能重复。
19.为什么集合类没有实现Cloneable和Serializable接口？

集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。

20.什么是迭代器(Iterator)？

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的
迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。

克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。

21.Iterator和ListIterator的区别是什么？

下面列出了他们的区别：

Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。
22.快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。

23.Java中的HashMap的工作原理是什么？

Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

24.hashCode()和equals()方法的重要性体现在什么地方？

Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。

25.HashMap和Hashtable有什么区别？

HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
HashMap允许键和值是null，而Hashtable不允许键或者值是null。
Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。
一般认为Hashtable是一个遗留的类。
26.数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？

下面列出了Array和ArrayList的不同点：

Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。
ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。
对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。
27.ArrayList和LinkedList有什么区别？

ArrayList和LinkedList都实现了List接口，他们有以下的不同点：

ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。

相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。

LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。

也可以参考ArrayList vs. LinkedList。

28.Comparable和Comparator接口是干什么的？列出它们的区别。

Java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明输入对象小于，等于，大于已经存在的对象。

Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。

29.什么是Java优先级队列(Priority Queue)？

PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。

30.你了解大O符号(big-O notation)么？你能给出不同数据结构的例子么？

大O符号描述了当数据结构里面的元素增加的时候，算法的规模或者是性能在最坏的场景下有多么好。
大O符号也可用来描述其他的行为，比如：内存消耗。因为集合类实际上是数据结构，我们一般使用大O符号基于时间，内存和性能来选择最好的实现。大O符号可以对大量数据的性能给出一个很好的说明。

31.如何权衡是使用无序的数组还是有序的数组？

有序数组最大的好处在于查找的时间复杂度是O(log n)，而无序数组是O(n)。有序数组的缺点是插入操作的时间复杂度是O(n)，因为值大的元素需要往后移动来给新元素腾位置。相反，无序数组的插入时间复杂度是常量O(1)。

32.Java集合类框架的最佳实践有哪些？

根据应用的需要正确选择要使用的集合的类型对性能非常重要，比如：假如元素的大小是固定的，而且能事先知道，我们就应该用Array而不是ArrayList。
有些集合类允许指定初始容量。因此，如果我们能估计出存储的元素的数目，我们可以设置初始容量来避免重新计算hash值或者是扩容。
为了类型安全，可读性和健壮性的原因总是要使用泛型。同时，使用泛型还可以避免运行时的ClassCastException。
使用JDK提供的不变类(immutable class)作为Map的键可以避免为我们自己的类实现hashCode()和equals()方法。
编程的时候接口优于实现。
底层的集合实际上是空的情况下，返回长度是0的集合或者是数组，不要返回null。
33.Enumeration接口和Iterator接口的区别有哪些？

Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。

34.HashSet和TreeSet有什么区别？

HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。

另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。

垃圾收集器(Garbage Collectors)

35.Java中垃圾回收有什么目的？什么时候进行垃圾回收？

垃圾回收的目的是识别并且丢弃应用不再使用的对象来释放和重用资源。

36.System.gc()和Runtime.gc()会做什么事情？

这两个方法用来提示JVM要进行垃圾回收。但是，立即开始还是延迟进行垃圾回收是取决于JVM的。

37.finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？

在释放对象占用的内存之前，垃圾收集器会调用对象的finalize()方法。一般建议在该方法中释放对象持有的资源。

38.如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？

不会，在下一个垃圾回收周期中，这个对象将是可被回收的。

39.Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?

JVM的堆是运行时数据区，所有类的实例和数组都是在堆上分配内存。它在JVM启动的时候被创建。对象所占的堆内存是由自动内存管理系统也就是垃圾收集器回收。

堆内存是由存活和死亡的对象组成的。存活的对象是应用可以访问的，不会被垃圾回收。死亡的对象是应用不可访问尚且还没有被垃圾收集器回收掉的对象。一直到垃圾收集器把这些对象回收掉之前，他们会一直占据堆内存空间。

40.串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？

吞吐量收集器使用并行版本的新生代垃圾收集器，它用于中等规模和大规模数据的应用程序。而串行收集器对大多数的小应用(在现代处理器上需要大概100M左右的内存)就足够了。

41.在Java中，对象什么时候可以被垃圾回收？

当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。

42.JVM的永久代中会发生垃圾回收么？

垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区
(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)

ImportNew
首页所有文章资讯Web架构基础技术书籍教程Java小组工具资源
115个Java面试题和答案——终极列表（下）
2014/04/23 | 分类： 基础技术 | 6 条评论 | 标签： JAVA, 面试
分享到： 291
本文由 ImportNew - miracle1919 翻译自 javacodegeeks。欢迎加入翻译小组。转载请见文末要求。
第一篇讨论了面向对象编程和它的特点，关于Java和它的功能的常见问题，Java的集合类，垃圾收集器，本章主要讨论异常处理，Java小应用程序，Swing，JDBC，远程方法调用(RMI)，Servlet和JSP。
异常处理

Java小应用程序(Applet)

Swing

JDBC

远程方法调用（RMI）

Servlet

JSP

异常处理

43.Java中的两种异常类型是什么？他们有什么区别？

Java中有两种异常：受检查的(checked)异常和不受检查的(unchecked)异常。不受检查的异常不需要在方法或者是构造函数上声明，就算方法或者是构造函数的执行可能会抛出这样的异常，并且不受检查的异常可以传播到方法或者是构造函数的外面。相反，受检查的异常必须要用throws语句在方法或者是构造函数上声明。这里有Java异常处理的一些小建议。

44.Java中Exception和Error有什么区别？

Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。

45.throw和throws有什么区别？

throw关键字用来在程序中明确的抛出异常，相反，throws语句用来表明方法不能处理的异常。每一个方法都必须要指定哪些异常不能处理，所以方法的调用者才能够确保处理可能发生的异常，多个异常是用逗号分隔的。

45.异常处理的时候，finally代码块的重要性是什么？(译者注：作者标题的序号弄错了)

无论是否抛出异常，finally代码块总是会被执行。就算是没有catch语句同时又抛出异常的情况下，finally代码块仍然会被执行。最后要说的是，finally代码块主要用来释放资源，比如：I/O缓冲区，数据库连接。

46.异常处理完成以后，Exception对象会发生什么变化？

Exception对象会在下一个垃圾回收过程中被回收掉。

47.finally代码块和finalize()方法有什么区别？

无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。

Java小应用程序(Applet)

48.什么是Applet？

java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。

49.解释一下Applet的生命周期

applet可以经历下面的状态：

Init：每次被载入的时候都会被初始化。
Start：开始执行applet。
Stop：结束执行applet。
Destroy：卸载applet之前，做最后的清理工作。
50.当applet被载入的时候会发生什么？

首先，创建applet控制类的实例，然后初始化applet，最后开始运行。

51.Applet和普通的Java应用程序有什么区别？

applet是运行在启用了java的浏览器中，Java应用程序是可以在浏览器之外运行的独立的Java程序。但是，它们都需要有Java虚拟机。

进一步来说，Java应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。

最后，Java applet一般会使用很严格的安全策略，Java应用一般使用比较宽松的安全策略。

52.Java applet有哪些限制条件？

主要是由于安全的原因，给applet施加了以下的限制：

applet不能够载入类库或者定义本地方法。
applet不能在宿主机上读写文件。
applet不能读取特定的系统属性。
applet不能发起网络连接，除非是跟宿主机。
applet不能够开启宿主机上其他任何的程序。
53.什么是不受信任的applet？

不受信任的applet是不能访问或是执行本地系统文件的Java applet，默认情况下，所有下载的applet都是不受信任的。

54.从网络上加载的applet和从本地文件系统加载的applet有什么区别？

当applet是从网络上加载的时候，applet是由applet类加载器载入的，它受applet安全管理器的限制。

当applet是从客户端的本地磁盘载入的时候，applet是由文件系统加载器载入的。

从文件系统载入的applet允许在客户端读文件，写文件，加载类库，并且也允许执行其他程序，但是，却通不过字节码校验。

55.applet类加载器是什么？它会做哪些工作？

当applet是从网络上加载的时候，它是由applet类加载器载入的。类加载器有自己的java名称空间等级结构。类加载器会保证来自文件系统的类有唯一的名称空间，来自网络资源的类有唯一的名称空间。

当浏览器通过网络载入applet的时候，applet的类被放置于和applet的源相关联的私有的名称空间中。然后，那些被类加载器载入进来的类都是通过了验证器验证的。验证器会检查类文件格式是否遵守Java语言规范，确保不会出现堆栈溢出(stack overflow)或者下溢(underflow)，传递给字节码指令的参数是正确的。

56.applet安全管理器是什么？它会做哪些工作？

applet安全管理器是给applet施加限制条件的一种机制。浏览器可以只有一个安全管理器。安全管理器在启动的时候被创建，之后不能被替换覆盖或者是扩展。

Swing

57.弹出式选择菜单(Choice)和列表(List)有什么区别

Choice是以一种紧凑的形式展示的，需要下拉才能看到所有的选项。Choice中一次只能选中一个选项。List同时可以有多个元素可见，支持选中一个或者多个元素。

58.什么是布局管理器？

布局管理器用来在容器中组织组件。

59.滚动条(Scrollbar)和滚动面板(JScrollPane)有什么区别？

Scrollbar是一个组件，不是容器。而ScrollPane是容器。ScrollPane自己处理滚动事件。

60.哪些Swing的方法是线程安全的？

只有3个线程安全的方法： repaint(), revalidate(), and invalidate()。

61.说出三种支持重绘(painting)的组件。

Canvas, Frame, Panel,和Applet支持重绘。

62.什么是裁剪(clipping)？

限制在一个给定的区域或者形状的绘图操作就做裁剪。

63.MenuItem和CheckboxMenuItem的区别是什么？

CheckboxMenuItem类继承自MenuItem类，支持菜单选项可以选中或者不选中。

64.边缘布局(BorderLayout)里面的元素是如何布局的？

BorderLayout里面的元素是按照容器的东西南北中进行布局的。

65.网格包布局(GridBagLayout)里面的元素是如何布局的？

GridBagLayout里面的元素是按照网格进行布局的。不同大小的元素可能会占据网格的多于1行或一列。因此，行数和列数可以有不同的大小。

66.Window和Frame有什么区别？

Frame类继承了Window类，它定义了一个可以有菜单栏的主应用窗口。

67.裁剪(clipping)和重绘(repainting)有什么联系？

当窗口被AWT重绘线程进行重绘的时候，它会把裁剪区域设置成需要重绘的窗口的区域。

68.事件监听器接口(event-listener interface)和事件适配器(event-adapter)有什么关系？

事件监听器接口定义了对特定的事件，事件处理器必须要实现的方法。事件适配器给事件监听器接口提供了默认的实现。

69.GUI组件如何来处理它自己的事件？

GUI组件可以处理它自己的事件，只要它实现相对应的事件监听器接口，并且把自己作为事件监听器。

70.Java的布局管理器比传统的窗口系统有哪些优势？

Java使用布局管理器以一种一致的方式在所有的窗口平台上摆放组件。因为布局管理器不会和组件的绝对大小和位置相绑定，所以他们能够适应跨窗口系统的特定平台的不同。

71.Java的Swing组件使用了哪种设计模式？
Java中的Swing组件使用了MVC(视图-模型-控制器)设计模式。

JDBC

72.什么是JDBC？

JDBC是允许用户在不同数据库之间做选择的一个抽象层。JDBC允许开发者用JAVA写数据库应用程序，而不需要关心底层特定数据库的细节。

73.解释下驱动(Driver)在JDBC中的角色。

JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。

74.Class.forName()方法有什么作用？

这个方法用来载入跟数据库建立连接的驱动。

75.PreparedStatement比Statement有什么优势？

PreparedStatements是预编译的，因此，性能会更好。同时，不同的查询参数值，PreparedStatement可以重用。

76.什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？

CallableStatement用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是：

1
CallableStament.prepareCall();
77.数据库连接池是什么意思？

像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。

远程方法调用(RMI)

78.什么是RMI？

Java远程方法调用(Java RMI)是Java API对远程过程调用(RPC)提供的面向对象的等价形式，支持直接传输序列化的Java对象和分布式垃圾回收。远程方法调用可以看做是激活远程正在运行的对象上的方法的步骤。RMI对调用者是位置透明的，因为调用者感觉方法是执行在本地运行的对象上的。看下RMI的一些注意事项。

79.RMI体系结构的基本原则是什么？

RMI体系结构是基于一个非常重要的行为定义和行为实现相分离的原则。RMI允许定义行为的代码和实现行为的代码相分离，并且运行在不同的JVM上。

80.RMI体系结构分哪几层？

RMI体系结构分以下几层：

存根和骨架层(Stub and Skeleton layer)：这一层对程序员是透明的，它主要负责拦截客户端发出的方法调用请求，然后把请求重定向给远程的RMI服务。

远程引用层(Remote Reference Layer)：RMI体系结构的第二层用来解析客户端对服务端远程对象的引用。这一层解析并管理客户端对服务端远程对象的引用。连接是点到点的。

传输层(Transport layer)：这一层负责连接参与服务的两个JVM。这一层是建立在网络上机器间的TCP/IP连接之上的。它提供了基本的连接服务，还有一些防火墙穿透策略。

81.RMI中的远程接口(Remote Interface)扮演了什么样的角色？

远程接口用来标识哪些方法是可以被非本地虚拟机调用的接口。远程对象必须要直接或者是间接实现远程接口。实现了远程接口的类应该声明被实现的远程接口，给每一个远程对象定义构造函数，给所有远程接口的方法提供实现。

82.java.rmi.Naming类扮演了什么样的角色？

java.rmi.Naming类用来存储和获取在远程对象注册表里面的远程对象的引用。Naming类的每一个方法接收一个URL格式的String对象作为它的参数。

83.RMI的绑定(Binding)是什么意思？

绑定是为了查询找远程对象而给远程对象关联或者是注册以后会用到的名称的过程。远程对象可以使用Naming类的bind()或者rebind()方法跟名称相关联。

84.Naming类的bind()和rebind()方法有什么区别？

bind()方法负责把指定名称绑定给远程对象，rebind()方法负责把指定名称重新绑定到一个新的远程对象。如果那个名称已经绑定过了，先前的绑定会被替换掉。

85.让RMI程序能正确运行有哪些步骤？

为了让RMI程序能正确运行必须要包含以下几个步骤：

编译所有的源文件。
使用rmic生成stub。
启动rmiregistry。
启动RMI服务器。
运行客户端程序。
86.RMI的stub扮演了什么样的角色？

远程对象的stub扮演了远程对象的代表或者代理的角色。调用者在本地stub上调用方法，它负责在远程对象上执行方法。当stub的方法被调用的时候，会经历以下几个步骤：

初始化到包含了远程对象的JVM的连接。
序列化参数到远程的JVM。
等待方法调用和执行的结果。
反序列化返回的值或者是方法没有执行成功情况下的异常。
把值返回给调用者。
87.什么是分布式垃圾回收(DGC)？它是如何工作的？

DGC叫做分布式垃圾回收。RMI使用DGC来做自动垃圾回收。因为RMI包含了跨虚拟机的远程对象的引用，垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。

88.RMI中使用RMI安全管理器(RMISecurityManager)的目的是什么？

RMISecurityManager使用下载好的代码提供可被RMI应用程序使用的安全管理器。如果没有设置安全管理器，RMI的类加载器就不会从远程下载任何的类。

89.解释下Marshalling和demarshalling。

当应用程序希望把内存对象跨网络传递到另一台主机或者是持久化到存储的时候，就必须要把对象在内存里面的表示转化成合适的格式。这个过程就叫做Marshalling，反之就是demarshalling。

90.解释下Serialization和Deserialization。

Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。

Servlet

91.什么是Servlet？

Servlet是用来处理客户端请求并产生动态网页内容的Java类。Servlet主要是用来处理或者是存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。

92.说一下Servlet的体系结构。

所有的Servlet都必须要实现的核心的接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者是间接实现这个接口，或者是继承javax.servlet.GenericServlet或者javax.servlet.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。

93.Applet和Servlet有什么区别？

Applet是运行在客户端主机的浏览器上的客户端Java程序。而Servlet是运行在web服务器上的服务端的组件。applet可以使用用户界面类，而Servlet没有用户界面，相反，Servlet是等待客户端的HTTP请求，然后为请求产生响应。

94.GenericServlet和HttpServlet有什么区别？

GenericServlet是一个通用的协议无关的Servlet，它实现了Servlet和ServletConfig接口。继承自GenericServlet的Servlet应该要覆盖service()方法。最后，为了开发一个能用在网页上服务于使用HTTP协议请求的Servlet，你的Servlet必须要继承自HttpServlet。这里有Servlet的例子。

95.解释下Servlet的生命周期。

对每一个客户端的请求，Servlet引擎载入Servlet，调用它的init()方法，完成Servlet的初始化。然后，Servlet对象通过为每一个请求单独调用service()方法来处理所有随后来自客户端的请求，最后，调用Servlet(译者注：这里应该是Servlet而不是server)的destroy()方法把Servlet删除掉。

96.doGet()方法和doPost()方法有什么区别？

doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。

doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。

97.什么是Web应用程序？

Web应用程序是对Web或者是应用服务器的动态扩展。有两种类型的Web应用：面向表现的和面向服务的。面向表现的Web应用程序会产生包含了很多种标记语言和动态内容的交互的web页面作为对请求的响应。而面向服务的Web应用实现了Web服务的端点(endpoint)。一般来说，一个Web应用可以看成是一组安装在服务器URL名称空间的特定子集下面的Servlet的集合。

98.什么是服务端包含(Server Side Include)？

服务端包含(SSI)是一种简单的解释型服务端脚本语言，大多数时候仅用在Web上，用servlet标签嵌入进来。SSI最常用的场景把一个或多个文件包含到Web服务器的一个Web页面中。当浏览器访问Web页面的时候，Web服务器会用对应的servlet产生的文本来替换Web页面中的servlet标签。

99.什么是Servlet链(Servlet Chaining)？

Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。

100.如何知道是哪一个客户端的机器正在请求你的Servlet？

ServletRequest类可以找出客户端机器的IP地址或者是主机名。getRemoteAddr()方法获取客户端主机的IP地址，getRemoteHost()可以获取主机名。看下这里的例子。

101.HTTP响应的结构是怎么样的？

HTTP响应由三个部分组成：

状态码(Status Code)：描述了响应的状态。可以用来检查是否成功的完成了请求。请求失败的情况下，状态码可用来找出失败的原因。如果Servlet没有返回状态码，默认会返回成功的状态码HttpServletResponse.SC_OK。

HTTP头部(HTTP Header)：它们包含了更多关于响应的信息。比如：头部可以指定认为响应过期的过期日期，或者是指定用来给用户安全的传输实体内容的编码格式。如何在Serlet中检索HTTP的头部看这里。

主体(Body)：它包含了响应的内容。它可以包含HTML代码，图片，等等。主体是由传输在HTTP消息中紧跟在头部后面的数据字节组成的。

102.什么是cookie？session和cookie有什么区别？

cookie是Web服务器发送给浏览器的一块信息。浏览器会在本地文件中给每一个Web服务器存储cookie。以后浏览器在给特定的Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。下面列出了session和cookie的区别：

无论客户端浏览器做怎么样的设置，session都应该能正常工作。客户端可以选择禁用cookie，但是，session仍然是能够工作的，因为客户端无法禁用服务端的session。

在存储的数据量方面session和cookies也是不一样的。session能够存储任意的Java对象，cookie只能存储String类型的对象。

103.浏览器和Servlet通信使用的是什么协议？
浏览器和Servlet通信使用的是HTTP协议。

104.什么是HTTP隧道？

HTTP隧道是一种利用HTTP或者是HTTPS把多种网络协议封装起来进行通信的技术。因此，HTTP协议扮演了一个打通用于通信的网络协议的管道的包装器的角色。把其他协议的请求掩盖成HTTP的请求就是HTTP隧道。

105.sendRedirect()和forward()方法有什么区别？

sendRedirect()方法会创建一个新的请求，而forward()方法只是把请求转发到一个新的目标上。重定向(redirect)以后，之前请求作用域范围以内的对象就失效了，因为会产生一个新的请求，而转发(forwarding)以后，之前请求作用域范围以内的对象还是能访问的。一般认为sendRedirect()比forward()要慢。

106.什么是URL编码和URL解码？

URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。

JSP

107.什么是JSP页面？

JSP页面是一种包含了静态数据和JSP元素两种类型的文本的文本文档。静态数据可以用任何基于文本的格式来表示，比如：HTML或者XML。JSP是一种混合了静态内容和动态产生的内容的技术。这里看下JSP的例子。

108.JSP请求是如何被处理的？

浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。

109.JSP有什么优点？

下面列出了使用JSP的优点：

JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。
JSP页面可以被预编译。
JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。
开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。
开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。
110.什么是JSP指令(Directive)？JSP中有哪些不同类型的指令？

Directive是当JSP页面被编译成Servlet的时候，JSP引擎要处理的指令。Directive用来设置页面级别的指令，从外部文件插入数据，指定自定义的标签库。Directive是定义在<%@ 和 %>之间的。下面列出了不同类型的Directive：

包含指令(Include directive)：用来包含文件和合并文件内容到当前的页面。
页面指令(Page directive)：用来定义JSP页面中特定的属性，比如错误页面和缓冲区。
Taglib指令： 用来声明页面中使用的自定义的标签库。
111.什么是JSP动作(JSP action)？

JSP动作以XML语法的结构来控制Servlet引擎的行为。当JSP页面被请求的时候，JSP动作会被执行。它们可以被动态的插入到文件中，重用JavaBean组件，转发用户到其他的页面，或者是给Java插件产生HTML代码。下面列出了可用的动作：

jsp:include-当JSP页面被请求的时候包含一个文件。
jsp:useBean-找出或者是初始化Javabean。
jsp:setProperty-设置JavaBean的属性。
jsp:getProperty-获取JavaBean的属性。
jsp:forward-把请求转发到新的页面。
jsp:plugin-产生特定浏览器的代码。
112.什么是Scriptlets？

JSP技术中，scriptlet是嵌入在JSP页面中的一段Java代码。scriptlet是位于标签内部的所有的东西，在标签与标签之间，用户可以添加任意有效的scriplet。

113.声明(Decalaration)在哪里？

声明跟Java中的变量声明很相似，它用来声明随后要被表达式或者scriptlet使用的变量。添加的声明必须要用开始和结束标签包起来。

114.什么是表达式(Expression)？

【列表很长，可以分上、中、下发布】

JSP表达式是Web服务器把脚本语言表达式的值转化成一个String对象，插入到返回给客户端的数据流中。表达式是在<%=和%>这两个标签之间定义的。

115.隐含对象是什么意思？有哪些隐含对象？

JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象：

application
page
request
response
session
exception
out
config
pageContext

### 难度

**哪些情况下的对象会被垃圾回收机制处理掉？**


**讲一下常见编码方式？**

**utf-8编码中的中文占几个字节；int型几个字节？**

**静态代理和动态代理的区别，什么场景使用？**

**Java的异常体系**

**谈谈你对解析与分派的认识。**

**修改对象A的equals方法的签名，那么使用HashMap存放这个对象实例的时候，会调用哪个equals方法？**

**Java中实现多态的机制是什么？**

**如何将一个Java对象序列化到文件里？**

**说说你对Java反射的理解**

**说说你对Java注解的理解**

**说说你对依赖注入的理解**

**说一下泛型原理，并举例说明**

**Java中String的了解**

**String为什么要设计成不可变的？**

**Object类的equal和hashCode方法重写，为什么？**





### 线程

开启线程的三种方式？
线程和进程的区别？
为什么要有线程，而不是仅仅用进程？
run()和start()方法区别
如何控制某个方法允许并发访问线程的个数？
在Java中wait和seelp方法的不同；
谈谈wait/notify关键字的理解
什么导致线程阻塞？
线程如何关闭？
讲一下java中的同步的方法
数据一致性如何保证？
如何保证线程安全？
如何实现线程同步？
两个进程同时要求写或者读，能不能实现？如何防止进程的同步？
线程间操作List
Java中对象的生命周期
Synchronized用法
synchronize的原理
谈谈对Synchronized关键字，类锁，方法锁，重入锁的理解
static synchronized 方法的多线程访问和作用
同一个类里面两个synchronized方法，两个线程同时访问的问题
volatile的原理
谈谈volatile关键字的用法
谈谈volatile关键字的作用
谈谈NIO的理解
synchronized 和volatile 关键字的区别
synchronized与Lock的区别
ReentrantLock 、synchronized和volatile比较
ReentrantLock的内部实现
lock原理
死锁的四个必要条件？
怎么避免死锁？
对象锁和类锁是否会互相影响？
什么是线程池，如何使用?
Java的并发、多线程、线程模型
谈谈对多线程的理解
多线程有什么要注意的问题？
谈谈你对并发编程的理解并举例说明
谈谈你对多线程同步机制的理解？
如何保证多线程读写文件的安全？
多线程断点续传原理
断点续传的实现

## Android

### Activity

​	onCreate() onStart() onResume() onRestart() onPause() onStop() onDestory()

​	1.每个Activity可以代表一个页面,需要显示的Activity必须在AndroidManifest.xml中注册

​	2.通过startActivity进行启动

**启动模式**

​	singletonInstance 单例

​	singleTask 栈顶,没有就创建,在栈顶不创建,不唯一

​	singleTop 栈顶,上部销毁或创建,唯一

​	standard 默认 创建

**Activity之间的通信方式**

​	1.最常用的intent,在开启时传值

​	2.全局静态变量 在进入之前先进行修改 然后获取的值就被修改

**Activity各种情况下的生命周期**

​	1.打开一个Activity,

​		 FristActivity onCreate;onStart;onResume

​	2.跳到第二个Activity,

​		FirstActivity onPause; 

​		SecondActivity onCreate;onStart;onResume

​		FirstActivity onStop;

​	3.返回第一个Activity:

​		SecondActivity onPause;

​		FirstActivity onRestart;onStart;onRsume

​		SecondActivity onStop;onDestory

​	4.关闭屏幕

​		onPause  onStop

​	5.打开屏幕

​		onRestart  onStart  onResume

**保存Activity的退出状态**

​	onSaveInstanceState(Bundle outState) 方法 存储状态

​	在onCreate的时候判断savedInstanceState是否为空

**将一个Activity设置为窗口**

​	theme设置为@android:style/Theme.dialog

**横竖屏切换的时候，Activity 各种情况下的生命周期**

​	不设置configChanges时,切屏重新调用各个生命周期,切横屏执行一次,竖屏两次

​	设置configChanges为orientation后,切屏调用各个生命周期,切横竖都是只一次

​	设置configChanges为orientation或keyboardHidden,只执行onConfigurationChanged方法

**Activity与Fragment之间生命周期比较**

​	Activity有7个生命周期 Fragment有11个生命周期

​	创建时,Activity带领Fragment执行生命周期方法

​	Activity.onCreate()

​	Fragment.onAttach()

​	Fragment.onCreate()

​	Fragment.onCreateView()

​	Fragment.onActivityCreated()

​	然后

​	Activity.onStart()

​	Fragment.onStart()

​	Activity.onResume() (Activity.onRestart())

​	Fragment.onResume()

​	打开后,onResume对于Activity和Fragment都是执行最长的

​	销毁要先从Fragment开始

​	Fragment.onPause()

​	Activity.onPause()

​	Fragment.onStop()

​	Activity.onStop()

​	Fragment.onDestoryView()

​	Fragment.onDestroy()

​	Fragment.onDetach()

​	Activity.onDestroy()

**Activity的管理机制**

​	AMS(ActivityManagerService)管理,AMS提供一个ArrayList mHistory管理所有Activity,Activity启动时,AMS生成对应的ActivityRecord记录,ActivityRecord对应一个TaskRecord,相同TaskRecord的ActivityRecord在mHistory中处在连续位置,形成栈结构,后启动的Activity对应的ActivityRecord会放在task的栈顶,同一个TaskRecord的Activity可能在不同进程,每个Activity所在进程和task没有关系.

**Activity如与Service通信？**

​	可以通过bindService的方式，先在Activity里实现一个ServiceConnection接口，并将该接口传递给bindService()方法，在ServiceConnection接口的onServiceConnected()方法里执行相关操作。

**Activity管理生命周期**

​	打开一个Activity,Activity入栈,在ActivityStack里面从onCreate到onResume开始变换,ActivityStack在Sever进程里面运行,Server进程通过ApplicationThread的代理对象ApplicationThreadProxy向运行在app进程ApplicationThread发起操作请求,ApplicationThread接收到操作请求后通过handler向主线程ActivityThread发起请求,ActivittyThread执行响应操作回调Activity相应的周期方法.

**Activity通信方式**

​	startActivityForResult EventBus LocalBroadCastReceiver RxBus Otto

**同一个程序,不同的Activity是否可以放在不同的Task任务栈**

​	在清单文件配置activity的taskAffinity属性,这样可以指定在其他栈

​	启动Activity时intent设置FLAG_ACTIVITY_NEW_TASK

​	指定启动模式为singletonInstance



### Service

​	手动生命周期:startService(),stopService(),bindService(),unBindService()

​	自动调用:onCreate(),onStartCommand(),onDestory(),onBind(),onUnbind()

​	1.创建一个类实现抽象类Service

​	2.必须重写方法onBind,绑定服务调用;onCreate,首次创建调用;onStartCommand,每次startService都要用;onDestory,销毁回调

​	3.启动方式:startService(new Intent(this,Service.class))

​	 bindService(intent, conn, Service.BIND_AUTO_CREATE);

​	**Service的生命周期与启动方法有什么区别？**

​	startService()：开启Service，调用者退出后Service仍然存在。
​	bindService()：开启Service，调用者退出后Service也随即退出。

​	Service生命周期：
​	只是用startService()启动服务：onCreate() -> onStartCommand() -> onDestory
​	只是用bindService()绑定服务：onCreate() -> onBind() -> onUnBind() -> onDestory
​	同时使用startService()启动服务与bindService()绑定服务：onCreate() -> onStartCommnad() -> onBind() -> onUnBind() -> onDestory

### BroadcastReceiver

​	并不监听数据变化而是接收变化的广播

​	系统的很多操作会发送广播,如开机,电量变化,屏幕开闭,android4.0以后未启动程序不会被广播通知

​	是两种注册方式:

​		xml静态注册,类似Activity 代码动态注册,intent启动

​		静态注册:	

```xml
<receiver android:name=".BroadcastReceiver1">
	<intent-filter>
    <action android:name="android.intent.action.CALL">
    </action>
    </intent-filter>
</receiver>
```

​		动态注册:

```java
receiver = new BroadcastReceiver();
IntentFilter intentFilter = new IntentFilter();
intentFilter.addAction(CALL_ACTION);
context.registerReceiver(receiver,intentFilter);
```

​	广播有两种 

​	有序广播和无序广播

​	通过Context,sendBroadcast(Intent)发送无序广播,通过Context.sendOrderedBroadcast发送有序广播

​	无序广播属于完全异步,可以被任何接收者接收到,无法通过一个接收者把结果传给另一个接收者

​	有序广播可以按照优先级传播,后接到广播的可以收到上一个收到广播的处理结果

​	**主要使用广播的场景**

​	监听系统的变化:开机,SD卡挂载,收到短信,WIFI状态切换,可以在Activity和Fragment之间数据通信使用,现在很少使用

​	**生命周期**

​	生命周期很短,接收广播创建,onReceive之后销毁,所以不要做耗时操作或者子线程耗时操作

​	**广播分为哪几种，应用场景是什么？**

​	普通广播：调用sendBroadcast()发送，最常用的广播。
​	有序广播：调用sendOrderedBroadcast()，发出去的广播会被广播接受者按照顺序接收，广播接收者按照Priority属性值从大-小排序，Priority属性相同者，动态注册的广播优先，广播接收者还可以选择对广播进行截断和修改。

​	**广播的两种注册方式有什么区别？**

​	静态注册：常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。
​	动态注册：非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造成内存泄漏。

​	**广播发送和接收的原理了解吗？**

​	继承BroadcastReceiver，重写onReceive()方法。
​	通过Binder机制向ActivityManagerService注册广播。
​	通过Binder机制向ActivityMangerService发送广播。
​	ActivityManagerService查找符合相应条件的广播（IntentFilter/Permission）的BroadcastReceiver，将广播发送到BroadcastReceiver所在的消息队列中。
​	BroadcastReceiver所在消息队列拿到此广播后，回调它的onReceive()方法。

​	**BroadcastReceiver与LocalBroadcastReceiver有什么区别？**

​	BroadcastReceiver 是跨应用广播，利用Binder机制实现。
​	LocalBroadcastReceiver 是应用内广播，利用Handler实现，利用了IntentFilter的match功能，提供消息的发布与接收功能，实现应用内通信，效率比较高。

​	

### ContentProvider

​	给不同应用提供内存访问,多进程通信,以一个或多个表的形式提供外部应用

​	**ContentProvider,ContentResolver,ContentObserver**

​	ContentProvider管理和提供数据,把自己的数据提供给别人

​	ContentResolver内容解析者,获取ContentProvider提供的数据,ContentResolver.notifyChanger(uri)发出消息

​	ContentObserver内容监听者,监听内容改变,通过ContentObserver.registerContentObserver()监听消息.

​	**通过ContentResolver获取ContentProvider内容的基本步骤**

​	得到ContentResolver类对象,定义要查询的字段String数组,使用cr.query返回一个Cursor对象,使用while循环得到Cursor里面的内容

​	**访问自定义ContentProvider**

​	通过Context.getContentResolver获取ContentResolver对象,通过这个对象的insert delete update query方法调用ContentProvider中对应的方法获取结果



### View

**SurfaceView和View的区别**

​	SurfaceView采用双缓存技术,在单独线程更新UI,View在UI线程更新UI

**ImageView的ScaleType**

​	CENTER 按照原来的尺寸居中显示,超过View的尺寸截掉,居中显示

​	CENTER_CROP 按比例扩大,长宽大于等于View长宽

​	CENTER_INSIDE 居中显示,通过比例缩小或者

​	FIT_CENTER 把图片按比例扩大/缩小到View的宽度,居中显示

​	FIT_END 把图片按比例扩大/缩小到View的宽度,显示在View的下半部分位置

​	FIT_START 把图片按比例扩大/缩小到View的宽度,显示在View的上半部分位置

​	FIT_XY 把图片不按比例 扩大/缩小到View的大小显示

​	MATRIX 矩阵绘制

**RemoteView**

​	跨进程的View

**布局优化**

​	include复用布局文件

​	merge避免嵌套布局

​	stub标签只在需要的时候显示

**描述一下View的绘制原理？**

​	View的绘制流程主要分为三步：

​	onMeasure：测量视图的大小，从顶层父View到子View递归调用measure()方法，measure()调用onMeasure()方法，onMeasure()方法完成绘制工作。
​	onLayout：确定视图的位置，从顶层父View到子View递归调用layout()方法，父View将上一步measure()方法得到的子View的布局大小和布局参数，将子View放在合适的位置上。
​	onDraw：绘制最终的视图，首先ViewRoot创建一个Canvas对象，然后调用onDraw()方法进行绘制。onDraw()方法的绘制流程为：① 绘制视图背景。② 绘制画布的图层。 ③ 绘制View内容。④ 绘制子视图，如果有的话。⑤ 还原图层。⑥ 绘制滚动条。

**requestLayout()、invalidate()与postInvalidate()有什么区别？**

​	requestLayout()：该方法会递归调用父窗口的requestLayout()方法，直到触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为true，会触发onMesaure()与onLayout()方法，不一定
会触发onDraw()方法。
​	invalidate()：该方法递归调用父View的invalidateChildInParent()方法，直到调用ViewRootImpl的invalidateChildInParent()方法，最终触发ViewRootImpl的performTraversals()方法，此时mLayoutRequestede为false，不会触发onMesaure()与onLayout()方法，当时会触发onDraw()方法。
​	postInvalidate()：该方法功能和invalidate()一样，只是它可以在非UI线程中调用。

### Fragment

​	**遇到过哪些关于Fragment的问题，如何处理的？**

​	getActivity()空指针：这种情况一般发生在在异步任务里调用getActivity()，而Fragment已经onDetach()，此时就会有空指针，解决方案是在Fragment里使用一个全局变量mActivity，在onAttach()方法里赋值，这样可能会引起内存泄漏，但是异步任务没有停止的情况下本身就已经可能内存泄漏，相比直接crash，这种方式
显得更妥当一些。
​	Fragment视图重叠：在类onCreate()的方法加载Fragment，并且没有判断saveInstanceState==null或if(findFragmentByTag(mFragmentTag) == null)，导致重复加载了同一个Fragment导致重叠。（PS：replace情况下，如果没有加入回退栈，则不判断也不会造成重叠，但建议还是统一判断下）

```java
@Override 
protected void onCreate(@Nullable Bundle savedInstanceState) {
// 在页面重启时，Fragment会被保存恢复，而此时再加载Fragment会重复加载，导致重叠 ;
    if(saveInstanceState == null){
    // 或者 if(findFragmentByTag(mFragmentTag) == null)
       // 正常情况下去 加载根Fragment 
    } 
}	
```



### 事件

### 图片相关

**BitmapFactory.Options与图片压缩**

​	inTargetDensity 要被画出来的目标像素密度

​	inSampleSize int值 远尺寸宽高除以这个值为画出来的尺寸宽高

​	inJustDecodeBounds 只解析边界 不解析里面内容

​	inPreferredConfig 默认使用ARGB_8888一个像素点4个byte,质量要求不高的可以用RGB_565,一个像素两个byte,节省50%内存

​	inBitmap 重复利用图片内存,减少内存分配,4.4以前只有相同可以服用,4.4以后只要原有的比解码的大就能复用

**如何在不压缩的情况下加载高清大图**

​	使用BitmapRegionDecoder进行布局加载。(Bitmap局部编码)

**如何计算一个Bitmap占用内存的大小，怎么保证加载Bitmap不产生内存溢出**

​	Bitamp 占用内存大小 = 宽度像素 x （inTargetDensity / inDensity） x 高度像素 x （inTargetDensity / inDensity）x 一个像素所占的内存.

​	这里inDensity表示目标图片的dpi（放在哪个资源文件夹下），inTargetDensity表示目标屏幕的dpi，所以你可以发现inDensity和inTargetDensity会对Bitmap的宽高进行拉伸，进而改变Bitmap占用内存的大小。

​	Bitmap有两个获取内存占用大小的方法

​	getByteCount() API 12引入, getAllocationByteCount()API 19引入

​	在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 getByteCount() 表示新解码图片占用内存的大小，getAllocationByteCount() 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。

​	为了保证在加载Bitmap的时候不产生内存溢出，可以受用BitmapFactory进行图片压缩，主要有以下几个参数：

​	BitmapFactory.Options.inPreferredConfig：将ARGB_8888改为RGB_565，改变编码方式，节约内存。
​	BitmapFactory.Options.inSampleSize：缩放比例，可以参考Luban那个库，根据图片宽高计算出合适的缩放比例。
​	BitmapFactory.Options.inPurgeable：让系统可以内存不足时回收内存。

**图片库对比**

**图片库的源码分析**

**图片框架缓存实现**

**LRUCache原理**

**图片加载原理**

**自己去实现图片库，怎么做？**

**Glide源码解析**

**Glide使用什么缓存？**

**Glide内存缓存如何控制大小？**



### 基础

**Activity,View,Window之间的关系**

​	Activity构造的时候初始化一个Window,准确的说是PhoneWindow,这个PhoneWindow有一个"ViewRoot",这个"ViewRoot"是一个View或者ViewGroup,最初的根视图,ViewRoot通过addView方法添加控件,事件的监听通过WindowManagerService接受消息,回调Activity函数.

**View重叠事件处理**

​	相对布局出现,会根据xml的前后add顺序 从内向外传递然后从外向内进行消费,同一级别后添加进去的控件先执行.

**Android 程序之间的亲和性**

​	默认一个应用所有Activity有相同的affinity,从application中继承,application的affinity默认是manifest的包名,affinity是Activity对于所在Task的一个标签

**res下raw目录和asset目录的区别**

​	不会被编译成二进制文件

​	assets下文件不可以直接R.java调用,需要用assetManager,raw下可以直接调用

​	raw不能二级目录,assets下可以

```java
//读取raw下文件
try{
    InputStream is = null;
    is = getResources().openRawResource(R.id.filename);
}catch(Exception e){
    e.printStackTrace();
}
//读取assets下文件
try{
    AssetManager am = null;
    am = getAssets();
    InputStream is = am.open("filename");
}catch(Exception e){
    e.printStackTrace();
}
```

**Activity里面有几种进程**

​	**前台进程**

​	用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：	

​	托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）
​	托管某个 Service，后者绑定到用户正在交互的 Activity
​	托管正在“前台”运行的 Service（服务已调用 startForeground()）
​	托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
​	托管正执行其 onReceive() 方法的 BroadcastReceiver

​	除非内存不足,不然不会中止

​	**可见进程**

​	没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：

​	托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。
​	托管绑定到可见（或前台）Activity 的 Service。

​	极其重要的进程,除非为了维持前台app运行,不然不会关闭

​	**服务进程**

​	重要性小于前两个.在保证上面两个运行的时候终止,比如后台播放音乐或者网络下载数据

​	**后台进程**

​	已经停止,系统可以随时中止,导航回这个应用时,恢复开启状态

​	**空进程**

​	不包含内容,只为了下次快速开启,经常被系统中止

​	AMS管理所有进程

**进程保护如何做，如何唤醒其他进程**

​	首先,不推荐这么干,这么干手机会越来越卡,常用的做法是这么干,监控锁屏,锁屏时启动一个像素的Activity,用户解锁时拉活. 主要两个思路 进程优先级,拉活被杀死的进程

**序列化,Android引入Parcelable**

​	序列化就是把对象转成二进制流,JAVA实现的序列化方式是Serializable,可能触发频繁的IO操作,效率低,适合写入硬盘,Parceable是Android序列化机制,将序列化后的字节流写入到一个共性内存中,其他对象可以从这块共享内存中读出字节流，并反序列化成对象。因此效率比较高，适合在对象间或者进程间传递信息。

**Application生命周期**

onCreate() 创建时调用

onTerminate() 终止时调用

onLowMemory() 低内存时执行

onTrimMemory() 回收内存执行

onConfigurationChanged(Configuration newConfig) 配置改变触发

**Android里面有几种Context对象**

​	Context是一个接口,常用的继承这个类或者其子类的是Activity,Service和Applicaton,不常用的ContextImpl,ContextWrapper,ContextThemeWrapper

**Android里的Intent传递的数据有大小限制吗，如何解决？**

​	Intent传递数据大小的限制大概在1M左右，超过这个限制就会静默崩溃。处理方式如下：

​	进程内：EventBus，文件缓存、磁盘缓存。

​	进程间：通过ContentProvider进行款进程数据共享和传递。

**style和theme的区别**

​	style是View属性 theme是整个Activity或者Application的属性

**JAVA程序与Android程序的区别**

​	JAVASDK和AndroidSDK,AndroidSDK抛弃了一部分的JAVASDK,添加了jar,HttpClient,PULL,OpenGL

**Intent传递数据类型**

​	Seriable 序列化对象

 	Charsequence 包含CharBuffer String StringBuffer StringBuilder

​	Parcelable 封装数据的容器

​	Bundle 不是持久化状态

**Context和getApplicationContext()的区别**

​	Context分为ActivityContext,ServiceContext,ApplicationContext,

​	Context一般只代表当前类,ApplicationContext代表整个app的一个上下文

**ANR和避免ANR**

Application Not Responding 规定时间没有响应

避免的方法:

​	避免Activity耗时操作,onReceiver过多操作,避免在Intente Service启动Activity,用handler处理线程交互

**XML文件解析的方式和原理**

​	DOM: 消耗内存,把xml读取到内存,DOM JavaSE来访问树形结构,获取数据,消耗内存,可能死机

​	SAX: 效率高,内存少,基于事件处理,扫描到一个文档/元素去扫描头尾通知函数进行处理

​	PULL: 和SAX类似,基于事件调用,通过next方法获取节点值

**判断当前BroadCastReceiver收到的是有序还是无序广播**

​	在onReceive方法中调用boolean b = isOrderedBroadcast

**SP存储方式**

​	轻型的数据存储方式,基于XML文件存储,数据结构是keyValue键值对,用于存储简单配置信息,存储位置在data/data/包名/shared-prefs下,通过Editor对象修改数据

**SP存储方式与SQLite数据库区别**

​	SP更适合简洁小数据,但是只能基本类型,SQLise存储大数据,复杂查询,可以直接读写ORM处理后对象

**显示Intent和隐式Intent的区别**

​	注册方式,显式的在.class,隐式的在xml,显式的明确指出了目标组件名称,隐式的没有指出

**Activity上有Dialog的时候按Home键时的生命周期**

**两个Activity 之间跳转时必然会执行的是哪几个方法？**

**前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。**

**Activity的四种启动模式对比**

**Activity状态保存于恢复**

**fragment各种情况下的生命周期**

**Fragment状态保存startActivityForResult是哪个类的方法，在什么情况下使用？**

**如何实现Fragment的滑动？**

**fragment之间传递数据的方式？**

**Activity 怎么和Service 绑定？**

**怎么在Activity 中启动自己对应的Service？**

**service和activity怎么进行数据交互？**

**Service的开启方式**


**请描述一下Service 的生命周期**

**谈谈你对ContentProvider的理解**


**说说ContentProvider、ContentResolver、ContentObserver 之间的关系**

**请描述一下广播BroadcastReceiver的理解**

**广播的分类**

**广播使用的方式和场景**


**在manifest 和代码中如何注册和使用BroadcastReceiver?**

**本地广播和全局广播有什么差别？**

**BroadcastReceiver，LocalBroadcastReceiver 区别**


**AlertDialog,popupWindow,Activity区别**

**Application 和 Activity 的 Context 对象的区别**


**Android属性动画特性**

**如何导入外部数据库?**

**LinearLayout、RelativeLayout、FrameLayout的特性及对比，并介绍使用场景。**

**谈谈对接口与回调的理解**

**回调的原理**

**写一个回调demo**

**介绍下SurfView**

**RecycleView的使用**

**序列化的作用，以及Android两种序列化的区别**

**差值器**

**估值器**

**Android中数据存储方式**



**自定义控件的onDraw方法和onCanvas方法**

### 数据库

**如何做SQLite升级**

数据库升级增加表和删除表都不涉及数据迁移，但是修改表涉及到对原有数据进行迁移。升级的方法如下所示：

将现有表命名为临时表。
创建新表。
将临时表的数据导入新表。
删除临时表。

如果是跨版本数据库升级，可以由两种方式，如下所示：

逐级升级，确定相邻版本与现在版本的差别，V1升级到V2,V2升级到V3，依次类推。
跨级升级，确定每个版本与现在数据库的差别，为每个case编写专门升级大代码。

### 源码机制

**Binder机制**

​	android每个app或系统服务都运行在独立的进程中,这些进程之间的通信都依靠Binder

​	Linux级进程间通信

​	管道：在创建时分配一个page大小的内存，缓存区大小比较有限；
​	消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信；
​	共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决；
​	套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信；
​	信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。6. 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等；

​	有IPC方式再次设计Binder机制是因为以下三个方面而设计

​	高性能：从数据拷贝次数来看Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次，共享内存不需要拷贝，Binder的性能仅次于共享内存。
​	稳定性：上面说到共享内存的性能优于Binder，那为什么不适用共享内存呢，因为共享内存需要处理并发同步问题，控制负责，容易出现死锁和资源竞争，稳定性较差。而Binder基于C/S架构，客户端与服务端彼此独立，稳定性较好。
​	安全性：我们知道Android为每个应用分配了UID，用来作为鉴别进程的重要标志，Android内部也依赖这个UID进行权限管理，包括6.0以前的固定权限和6.0以后的动态权限，传荣IPC只能由用户在数据包里填入UID/PID，这个标记完全是在用户空间控制的，没有放在内核空间，因此有被恶意篡改的可能，因此Binder的安全性更高。

**描述一下Android的事件分发机制？**

Android事件分发机制的本质：事件从哪个对象发出，经过哪些对象，最终由哪个对象处理了该事件。此处对象指的是Activity、Window与View。

Android事件的分发顺序：Activity（Window） -> ViewGroup -> View

Android事件的分发主要由三个方法来完成，如下所示：

```java
// 父View调用dispatchTouchEvent()开始分发事件
public boolean dispatchTouchEvent(MotionEvent event){
    boolean consume = false;
    // 父View决定是否拦截事件
    if(onInterceptTouchEvent(event)){
        // 父View调用onTouchEvent(event)消费事件，如果该方法返回true，表示
        // 该View消费了该事件，后续该事件序列的事件（Down、Move、Up）将不会在传递
        // 该其他View。
        consume = onTouchEvent(event);
    }else{
        // 调用子View的dispatchTouchEvent(event)方法继续分发事件
        consume = child.dispatchTouchEvent(event);
    }
    return consume;
}
```



**Android动画框架实现原理**

​	自定义View-动画-6.View启动Animation流程

**Android各个版本API的区别**

​	

**Requestlayout，onlayout，onDraw，DrawChild区别与联系**

​	requestlayout会调用measure()和layout() 只是对View树重新布局,包括measure()和layout(),不会调用draw()过程,也不会重新绘制任何View

​	onLayout()在View中没有实现,在ViewGroup是抽象方法,需要实现该方法，对每个子视图进行布局

​	onDraw()绘制视图本身

​	drawChild()去重新回调每个子视图的draw()方法

**invalidate和postInvalidate的区别及使用**

​	invalidate在UI线程自身使用,不能直接使用,使用时创建handler,在里面调用

​	postInvalidate在非UI线程中使用,在ViewRootImpl里面使用了handler,开子线程直接使用

**Activity-Window-View三者的差别**

​	Activity(工匠)>Window(框架)>View(),Activity代表一个控制单元,Window承载模型,View显示视图,事件分发机制-控件导入Activity原理

**谈谈对Volley的理解**

​	Volley是google2013发布的基于HttpURLConnection的封装网络通信库,简化了HttpURLConnection的代码逻辑,提高了代码效率.

​	优点 : 进行网路通信更快,有着高效率的GET,POST及网络图像的异步处理请求机制,能对多个请求进行排序,能对请求的结果进行缓存,能多级别取消请求

​	缺点 : 数据量非常大的情况下，性能就会非常差.对于日常开发已经满足

**如何优化自定义View**

​	1.减少onDraw的调用(invaildate)   

​	2.使用硬件加速

**Handler机制**

​	在创建Handler的同时会创建一个Looper和MessageQueue,通过sendMessage发送Message到消息队列messageQueue,Looper通过loop不断提取触发条件的message,将Message交给对应的target handler处理,targer handler调用自身的handleMessage方法处理message.MessageQueue是JAVA层和C++层维系的桥梁,相关功能都通过native方法实现.

**低版本SDK如何实现高版本api？**

​	使用注解@TargetApi,只在超过这个版本的时候调用这个方法,常用的地方是对权限的判断

​	对应的可以再重写一个方法,应对低版本安卓版本

**描述一次网络请求的流程**

​	大概流程 : 建立Socket链接,DNS域名解析把网址转成ip,TCP三次握手;建立TCP链接后发起GET/POST请求,服务器相应HTTP请求,获取到请求数据
**HttpUrlConnection 和 okhttp关系**

​	首先说,okHttp是高性能的http库,支持同步和异步,实现了spdy,http2,webscocket协议,api简单,实现了http协议的缓存	,HttpUrlConnection是一种多用途轻量级的HTTP客户端,当做http操作可以适用于大多数应用程序,API比较简单,容易使用和扩展,android4.4以后HttpUrlConnection底层采用okhttp.

**Bitmap对象的理解**

​	

**looper架构**

**ActivityThread，AMS，WMS的工作原理**

**自定义View如何考虑机型适配**

**自定义View的事件**

**AstncTask+HttpClient 与 AsyncHttpClient有什么区别？**

**LaunchMode应用场景**

**AsyncTask 如何使用?**

**SpareArray原理**

**请介绍下ContentProvider 是如何实现数据共享的？**

**AndroidService与Activity之间通信的几种方式**

**IntentService原理及作用是什么？**

**说说Activity、Intent、Service 是什么关系**

**ApplicationContext和ActivityContext的区别**

**SP是进程同步的吗?有什么方法做到同步？**

**谈谈多线程在Android中的使用**

**进程和 Application 的生命周期**

**封装View的时候怎么知道view的大小**

**RecycleView原理**

**AndroidManifest的作用与理解**

**Handler机制和底层实现**

**Handler、Thread和HandlerThread的差别**


**handler发消息给子线程，looper怎么启动？**

**关于Handler，在任何地方new Handler 都是什么线程下?**

**ThreadLocal原理，实现及如何保证Local属性？**

**请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系**

**请描述一下View事件传递分发机制**

**Touch事件传递流程**

**事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？**

**View和ViewGroup分别有哪些事件分发相关的回调方法**

**View刷新机制**

**View绘制流程**

**自定义控件原理**

**自定义View如何提供获取View属性的接口？**

**Android代码中实现WAP方式联网**

**AsyncTask机制**


**AsyncTask原理及不足**

**如何取消AsyncTask？**

**为什么不能在子线程更新UI？**

**ANR产生的原因是什么？**

**ANR定位和修正**

**什么情况导致oom？**

**有什么解决方法可以避免OOM？**

**Oom 是否可以try catch？为什么？**

**内存泄漏是什么？**

**什么情况导致内存泄漏？**


**如何防止线程的内存泄漏？**

**内存泄露场的解决方法**


**内存泄漏和内存溢出区别？**

**LruCache默认缓存大小**

**ContentProvider的权限管理(解答：读写分离，权限控制-精确到表级，URL控制)**


**如何通过广播拦截和abort一条短信？**

**广播是否可以请求网络？**



**广播引起anr的时间限制是多少？**



**计算一个view的嵌套层级**



**Activity栈**






**Android线程有没有上限？**



**线程池有没有上限？**




**ListView重用的是什么？**



**Android为什么引入Parcelable？**

**有没有尝试简化Parcelable的使用？**

### 常见问题

**ListView 中图片错位的问题是如何产生的?**


**混合开发有了解吗？**


**知道哪些混合开发的方式？说出它们的优缺点和各自使用场景？（解答：比如:RN，weex，H5，小程序，WPA等。做Android的了解一些前端js等还是很有好处的)；**

**屏幕适配的处理技巧都有哪些?**

**服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？**

**动态布局的理解**

**怎么去除重复代码？**


**画出 Android 的大体架构图**

**Recycleview和ListView的区别**

**ListView图片加载错乱的原理和解决方案**

**动态权限适配方案，权限组的概念**

**Android系统为什么会设计ContentProvider？**

**下拉状态栏是不是影响activity的生命周期**

**如果在onStop的时候做了网络请求，onResume的时候怎么恢复？**

**Bitmap 使用时候注意什么？**

**Bitmap的recycler()**

**Android中开启摄像头的主要步骤**

**ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？**

**点击事件被拦截，但是想传到下面的View，如何操作？**

**微信主页面的实现方式**

**微信上消息小红点的原理**

**CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: CAS简介http://blog.csdn.net/jly4758/article/details/46673835）**

### 性能内存

**WebView优化了解吗，如何提高WebView的加载速度？**

​	加载慢的主要原因是加载H5页面之前，需要先初始化WebView，在WebView完全初始化完成之前，后续的界面加载过程都是被阻塞的。优化有两个主要内容:预加载WebView,在同时请求H5数据。常用解决办法 全局WebView,客户端代理页面请求,asset存放离线包.

**性能优化**

​	避免创建不必要的对象 

​	合理使用static成员

​	避免内部的Get/Set方法

​	使用增强For循环,ArrayList除外

​	public代替private以便内部类访问

​	合理使用浮点类型

​	采用<merge>和<include>布局

​	移除Activity默认背景,提升加载速度

​	动态注册广播,生命周期结束取消注册

​	线程同步机制

​	合理使用SreingBuffer StringBuilder String

​	尽量使用局部变量

​	IO操作关闭流

​	生命周期长的对象引用ApplicationContext,不引用Context

​	较大Bitmap压缩后使用,高清大图使用BitmapRegionDecoder

​	用.9代替整张大图

​	在Activity或者Fragment销毁时销毁webView,webView.destroy();webView = null;

**内存泄露**

常见的发生泄露

​	静态的Context(Activity)引用

​	静态View引用

​	内部类或匿名内部类实例无法释放(有延迟时间操作),内部类强引用外部类无法释放,常见于监听器,Hanlder,Thread,TimerTask

​	资源没有关闭

​	错误的案例模式,比如持有Activity

​	集合类内存泄露

​	查找内存泄露一般使用AndroidStudio上的Profiler工具 或者LeakCanary

**Android里的内存缓存和磁盘缓存是怎么实现的?**

​	内存缓存基于LruCache实现，磁盘缓存基于DiskLruCache实现。这两个类都基于Lru算法和LinkedHashMap来实现。

​	Lru算法原则是如果一个数据在最近一段时间没有使用到，那么它在将来被访问到的可能性也很小，则这类数据项会被优先淘汰掉。

​	LruCache的原理是利用LinkedHashMap持有对象的强引用，按照Lru算法进行对象淘汰。具体说来假设我们从表尾访问数据，在表头删除数据，当访问的数据项在链表中存在时，则将该数据项移动到表尾，否则在表尾新建一个数据项。当链表容量超过一定阈值，则移除表头的数据。

**上面一道题下面问 为什么选择LinkedHashMap**

​	LinkedHashMap的构造函数里有个布尔参数accessOrder，当它为true时，LinkedHashMap会以访问顺序为序排列元素，否则以插入顺序为序排序元素。

**SharePreference性能优化，可以做进程同步吗？**

​	SP是一种以key-value的轻量级存储方式,每次使用都是一次读取,如果SP文件较大会出现问题

​	第一次取值可能阻塞线程,界面卡顿掉帧

​	解析时大量临时对象,频繁GC,界面卡顿

​	永远存在内存,占用内存

​	优化

​	不存大的key和value

​	读取频繁和不易变动的不要放在一起

​	无法跨进程通信

​	尽量不要存JSON和HTML

**如何对Android 应用进行性能分析以及优化?**

​	避免创建不必要的对象 减少内存回收率

​	合理使用static成员 View变量不用,一般常量使用,利于访问

​	避免内部的get/set方法 直接调用比get更快

​	使用增强for循环 ArrayList除外,更快获取数据

​	使用public代替private以便内部类高效访问外部类成员 私有的需要先在编译时生成静态方法才能访问

​	合理使用浮点类型 除法尽可能用乘法代替,有的硬件没有除法

​	采用<merge>优化布局层数,采用<include＞来共享布局 merge是一个简单的纵向线性布局,在被include的时候被忽略

​	移除Activity默认背景,提升加载速度

​	合理使用StringBuffer StringBuilder String

​	动态注册广播,生命周期结束时要取消注册

​	IO留操作关闭流

​	尽量使用局部变量

​	不让生命周期长的对象引用Activity Context

​	IntentService代替Service IntentService使用队列的方式将请求的intent加入队列

**ddms 和 traceView**


**性能优化如何分析systrace？**

**用IDE如何分析内存泄漏？**

**Java多线程引发的性能问题，怎么解决？**

**启动页白屏及黑屏解决？**

**启动太慢怎么解决？**

**怎么保证应用启动不卡顿？**

**App启动崩溃异常捕捉**

**自定义View注意事项**

**现在下载速度很慢,试从网络协议的角度分析原因,并优化(提示：网络的5层都可以涉及)。**

**Https请求慢的解决办法（提示：DNS，携带数据，直接访问IP）**

**如何保持应用的稳定性**


**RecyclerView和ListView的性能对比**


**ListView的优化**


**RecycleView优化**


**View渲染**

**Bitmap如何处理大图，如一张30M的大图，如何预防OOM**

**java中的四种引用的区别以及使用场景**

**强引用置为null，会不会被回收？**



### 架构相关

**MVC、MVP与MVVM之间的对比分析**

​	MVC: 时间最长的架构,所有逻辑封装在Controller层,Activity/Fragment承担了V的角色的同时承担了C的角色,小项目十分顺手

​	MVP: 为了解决MVC耦合性过大的问题出现MVP框架,实现解耦目的,一般是按照Google官方sample增加自己的封装,使用Presenterr将视图逻辑I和业务逻辑相分离

​	MVVM: 使用ViewModel代替Presenter，实现数据与View的双向绑定,早期是XML使用DataBinding绑定数据,Google后续推出ViewModel组件和LiveData组件.ViewModel组件规范了ViewModel所处地位,生命周期,生产方式以及一个Activity下多个Fragment共享ViewModel数据的问题,LiveData则提供了Java层面View订阅ViewModel数据源的实现方案.

**如何提交代码质量？**

避免创建不必要的对象，尽可能避免频繁的创建临时对象，例如在for循环内，减少GC的次数。
尽量使用基本数据类型代替引用数据类型。
静态方法调用效率高于动态方法，也可以避免创建额外对象。
对于基本数据类型和String类型的常量要使用static final修饰，这样常量会在dex文件的初始化器中进行初始化，使用的时候可以直接使用。
多使用系统API，例如数组拷贝System.arrayCopy()方法，要比我们用for循环效率快9倍以上，因为系统API很多都是通过底层的汇编模式执行的，效率比较高。

**PathClassLoader与DexClassLoader有什么区别**

​	PathClassLoader：只能加载已经安装到Android系统的APK文件，即/data/app目录，Android默认的类加载器。
​	DexClassLoader：可以加载任意目录下的dex、jar、apk、zip文件。

**谈谈你对Android设计模式的理解**

**你所知道的设计模式有哪些？**

**项目中常用的设计模式**

**手写生产者/消费者模式**

**写出观察者模式的代码**

**适配器模式，装饰者模式，外观模式的异同？**


**用到的一些开源框架，介绍一个看过源码的，内部实现过程。**

**谈谈对RxJava的理解**

**RxJava的功能与原理实现**

**RxJava的作用，与平时使用的异步操作来比的优缺点**

**说说EventBus作用，实现方式，代替EventBus的方式**

**从0设计一款App整体架构，如何去做？**

**说一款你认为当前比较火的应用并设计(比如：直播APP，P2P金融，小视频等)**

**谈谈对java状态机理解**

**Fragment如果在Adapter中使用应该如何解耦？**

**Binder机制及底层实现**

**对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？**

**实现一个Json解析器(可以通过正则提高速度)**

**统计启动时长,标准**

### 三方调用

**AIDL**

​	Android Interface Definition Language

​	使用AIDL提供公共服务接口实现跨进程通信

**JNI了解吗，Java与C++如何相互调用？**

JAVA调用C

​	在Java中声明Native方法（即需要调用的本地方法）
​	编译上述 Java源文件javac（得到 .class文件）
​	通过 javah 命令导出JNI的头文件（.h文件）
​	使用 Java需要交互的本地代码 实现在 Java中声明的Native方法
​	编译.so库文件
​	通过Java命令执行 Java程序，最终实现Java调用本地代码

C调用JAVA

​	从classpath路径下搜索ClassMethod这个类，并返回该类的Class对象。
​	获取类的默认构造方法ID。
​	查找实例方法的ID。
​	创建该类的实例。
​	调用对象的实例方法。

**请介绍一下NDK**


**什么是NDK库?**

**如何在jni中注册native函数，有几种注册方式?**

**Java如何调用c、c++语言？**

**jni如何调用java层代码？**


**进程间通信的方式？**


**Binder机制**


**简述IPC？**

**什么是AIDL？**

**AIDL解决了什么问题？**

**AIDL如何使用？**

**Android 上的 Inter-Process-Communication 跨进程通信时如何工作的？**

**多进程场景遇见过么？**

**Android进程分类？**

**进程和 Application 的生命周期？**

**进程调度**

**谈谈对进程共享和线程安全的认识**

**谈谈对多进程开发的理解以及多进程应用场景**



**什么是协程？**

java虚拟机的特性
谈谈对jvm的理解
JVM内存区域，开线程影响哪块内存
对Dalvik、ART虚拟机有什么了解？
Art和Dalvik对比
虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)
谈谈你对双亲委派模型理解
JVM内存模型，内存区域
类加载机制
谈谈对ClassLoader(类加载器)的理解
谈谈对动态加载（OSGI）的理解
内存对象的循环引用及避免
内存回收机制、GC回收策略、GC原理时机以及GC对象
垃圾回收机制与调用System.gc()区别
Ubuntu编译安卓系统
系统启动流程是什么？（提示：Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程）
大体说清一个应用程序安装到手机上时发生了什么
简述Activity启动全部过程
App启动流程，从点击桌面开始
逻辑地址与物理地址，为什么使用逻辑地址？
Android为每个应用程序分配的内存大小是多少？
Android中进程内存的分配，能不能自己分配定额内存？
进程保活的方式
如何保证一个后台服务不被杀死？（相同问题：如何保证service在后台不被kill？）比较省电的方式是什么？
App中唤醒其他进程的实现方式



## AndroidStudio

**APK打包流程**

​	通过AAPT工具进行资源文件（包括AndroidManifest.xml、布局文件、各种xml资源等）的打包，生成R.java文件。
​	通过AIDL工具处理AIDL文件，生成相应的Java文件。
​	通过Javac工具编译项目源码，生成Class文件。
​	通过DX工具将所有的Class文件转换成DEX文件，该过程主要完成Java字节码转换成Dalvik字节码，压缩常量池以及清除冗余信息等工作。
​	通过ApkBuilder工具将资源文件、DEX文件打包生成APK文件。
​	利用KeyStore对生成的APK文件进行签名。
​	如果是正式版的APK，还会利用ZipAlign工具进行对齐处理，对齐的过程就是将APK文件中所有的资源文件举例文件的起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件的速度会更快。

**apk安装流程**

​	复制APK到/data/app目录下，解压并扫描安装包。
​	资源管理器解析APK里的资源文件。
​	解析AndroidManifest文件，并在/data/data/目录下创建对应的应用数据目录。
​	然后对dex文件进行优化，并保存在dalvik-cache目录下。
​	将AndroidManifest文件解析出的四大组件信息注册到PackageManagerService中。
​	安装完成后，发送广播。

**点击一个应用图标后发生了什么**

​	1.点击桌面应用图标，Launcher进程将启动Activity（MainActivity）的请求以Binder的方式发送给了AMS。
​	2.AMS接收到启动请求后，交付ActivityStarter处理Intent和Flag等信息，然后再交给ActivityStackSupervisior/ActivityStack
处理Activity进栈相关流程。同时以Socket方式请求Zygote进程fork新进程。
​	3.Zygote接收到新进程创建请求后fork出新进程。
​	4.在新进程里创建ActivityThread对象，新创建的进程就是应用的主线程，在主线程里开启Looper消息循环，开始处理创建Activity。
​	5.ActivityThread利用ClassLoader去加载Activity、创建Activity实例，并回调Activity的onCreate()方法。这样便完成了Activity的启动。

**64K问题**

​	在DEX文件中，method、field、class等的个数使用short类型来做索引，即两个字节（65535），method、field、class等均有此限制。APK安装过程中调用dexopt将DEX文件优化成ODEX,dexopt使用LinearAlloc来存储应用信息，关于LinearAlloc缓冲区大小，不同的版本经历了4M/8M/16M的限制，超出缓冲区时就会抛出INSTALL_FAILED_DEXOPT错误.一般的,最可能的原因是使用了重复的包的引用,并不是数量超过65536,解决方案是Google的MultiDex方案,修改gradle,令multiDexEnabled 为true

**build 按钮后发生了什么**

​	

## Company Interview

### 淘宝

dp是什么，sp呢，有什么区别

自定义View，ViewGroup注意那些回调？

界面卡顿的原因以及解决方法

android中的存储类型

service用过么，基本调用方法

Handler机制

LinearLayout、FrameLayout、RelativeLayout性能对比，为什么

Activity的生命周期，finish调用后其他生命周期还会走么？

FW层熟悉么，源码看过么

GC回收机制熟悉么，分代算法知道么

Java的类类加载原理

内存泄漏如何排查，MAT分析方法以及原理，各种泄漏的原因是什么比如

Handler为什么会泄漏

gradle熟悉么，自动打包知道么

介绍下先的app架构和通信

自己负责过哪些模块，跟同事相比自己的优势是什么

遇到过什么印象深刻的问题，怎么解决的

Activity的生命周期有哪些，知道onRestart么，介绍下

savedInstanceState知道么，干什么用的，什么时候有值，什么时候为空，平时是怎么用的

View绘制熟悉么，介绍下，能说下是实现原理么？

平时用过什么开发工具，分析工具？

ANR是怎么回事？怎么查？Service会引起ANR么？

Activity的启动模式有哪些？栈里是A-B-C，先想直接到A，BC都清理掉，有几种方法可以做到？这几种方法产生的结果是有几个A的实例？

有什么工具可以看到Activity栈信息么？多个栈话，有方法分别得到各个栈的Activity列表么

都熟悉哪些命令？知道怎么用命令启动一个Activity么?

SharedPrefrences的apply和commit有什么区别

java里带$的函数见过么，是什么意思

MD5是加密方法么，Base64呢

有博客和github，主要是写的什么？有哪些关注

android 8.0 有哪些新特性

glide缓存策略？同一个图片跟size有关么

android中的动画有哪些

View事件传递机制

界面卡顿怎么排查和优化？

Fragment的replace和end？？的区别？

MVP，MVVM，MVC解释和实践

微信跳一跳外挂怎么实现，检测怎么做的？

一张纯色背景下怎么有效检测各个矩形？

对接的so算法了解么，有接触过相关的库么？

三个算法题选一个并写出测试用例：打印n-m之间所有的素数；计算n-m之间1出现的次数；指定数字序列的排序；

android api层的源码熟悉哪些？解释一下

ACTION_CANCEL什么时候触发，触摸button然后滑动到外部抬起会触发点击事件吗，在+ + 滑动回去抬起会么

怎么处理嵌套View的滑动冲突问题

热修复相关的原理，框架熟悉么

gradle打包流程熟悉么

任意提问环节：其实可以问之前面试中遇到的问题：比如，多模块开发的时候不同的负责人可能会引入重复资源，相同的字符串，相同的icon等但是文件名并不一样，怎样去重？

### NetBase

Canvas的底层机制，绘制框架，硬件加速是什么原理，canvas lock的缓冲区是怎么回事

surfaceview， suface，surfacetexure等相关的，以及底层原理

android文件存储，各版本存储位置的权限控制的演进，外部存储，内部存储

上层业务activity和fragment的遇到什么坑？？页面展示上的一些坑和优化经验

网络请求的开源框架：OKHttp介绍，写过拦截器么

数据层有统一的管理么，数据缓存是怎么做的，http请求等有提供统一管理么？

有用什么模式么，逻辑什么的都在Activity层？怎么分离的

如果用了一些解耦的策略，怎么管理生命周期的？

有什么提高编译速度的方法？

对应用里的线程有做统一管理么？

jni的算法提供都是主线程的？是不是想问服务类的啊

边沿检测用的啥？深度学习相关的有了解么？

上线后的app性能分析检测有做么

进程间通信方式？Binder的构成有几部分？

HttpClient和HttpConnection的区别

View的事件传递机制

MVC，MVP，MVVM分别是什么？

Android中常用的设计模式，说三个比较高级的？

内存优化，OOM的原因和排查方法

想改变listview的高度，怎么做

Https是怎么回事？

除了日常开发，其他有做过什么工作？比如持续化集成，自动化测试等等



### 阿里巴巴

LRUCache原理

图片加载原理

模块化实现（好处，原因）

JVM

视频加密传输

统计启动时长,标准

如何保持应用的稳定性

ThreadLocal 原理

谈谈classloader

动态布局

热修复,插件化

HashMap源码,SpareArray原理

性能优化,怎么保证应用启动不卡顿

怎么去除重复代码

SP是进程同步的吗?有什么方法做到同步

介绍下SurfView

HashMap实现原理，ConcurrentHashMap 的实现原理

BroadcastReceiver，LocalBroadcastReceiver 区别

Bundle 机制

Handler 机制

android 事件传递机制

线程间 操作 List

App启动流程，从点击桌面开始

动态加载

类加载器

OSGI

Https请求慢的解决办法，DNS，携带数据，直接访问IP

GC回收策略

画出 Android 的大体架构图

描述清点击 Android Studio 的 build 按钮后发生了什么

大体说清一个应用程序安装到手机上时发生了什么；

对 Dalvik、ART 虚拟机有基本的了解；

Android 上的 Inter-Process-Communication 跨进程通信时如何工作的；

App 是如何沙箱化，为什么要这么做；

权限管理系统（底层的权限是如何进行 grant 的）

进程和 Application 的生命周期；

系统启动流程 Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程

recycleview listview 的区别,性能

排序，快速排序的实现

树：B+树的介绍

图：有向无环图的解释

TCP/UDP的区别

synchronized与Lock的区别

volatile

Java线程池

Java中对象的生命周期

类加载机制

双亲委派模型

Android事件分发机制

MVP模式

RxJava

抽象类和接口的区别

集合 Set实现 Hash 怎么防止碰撞

JVM 内存区域 开线程影响哪块内存

垃圾收集机制 对象创建，新生代与老年代

二叉树 深度遍历与广度遍历

B树、B+树

消息机制

进程调度

进程与线程

死锁

进程状态

JVM内存模型

并发集合了解哪些

ConCurrentHashMap实现

CAS介绍

开启线程的三种方式,run()和start()方法区别

线程池

常用数据结构简介

判断环（猜测应该是链表环）

排序，堆排序实现

链表反转

### 腾讯

synchronized用法

volatile用法

动态权限适配方案，权限组的概念

网络请求缓存处理，okhttp如何处理网络缓存的

图片加载库相关，bitmap如何处理大图，如一张30M的大图，如何预防OOM

进程保活

listview图片加载错乱的原理和解决方案

https相关，如何验证证书的合法性，https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解

### 滴滴

MVP

广播（动态注册和静态注册区别，有序广播和标准广播）

service生命周期

handler实现机制（很多细节需要关注：如线程如何建立和退出消息循环等等）

多线程（关于AsyncTask缺陷引发的思考）

数据库数据迁移问题

设计模式相关（例如Android中哪里使用了观察者模式，单例模式相关）

x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完

TCP与UDP区别与应用（三次握手和四次挥手）涉及到部分细节（如client如何确定自己发送的消息被server收到） HTTP相关 提到过Websocket 问了WebSocket相关以及与socket的区别

是否熟悉Android jni开发，jni如何调用java层代码

进程间通信的方式

java注解

计算一个view的嵌套层级

项目组件化的理解

多线程断点续传原理

Android系统为什么会设计ContentProvider，进程共享和线程安全问题

jvm相关

Android相关优化（如内存优化、网络优化、布局优化、电量优化、业务优化）

EventBus实现原理

ActivityA跳转ActivityB然后B按back返回A，各自的生命周期顺序，A与B均不透明。

Synchronize关键字后面跟类或者对象有什么不同。

单例的DCL方式下，那个单例的私有变量要不要加volatile关键字，这个关键字有什么用

JVM的引用树，什么变量能作为GCRoot？GC垃圾回收的几种方法

ThreadLocal是什么？Looper中的消息死循环为什么没有ANR？

Android中main方法入口在哪里

jdk1.5？SparseArray和ArrayMap各自的数据结构，前者的查找是怎么实现的，与HashMap的区别

Runnable与Callable、Future、FutureTask的区别，AsyncTask用到哪个？AsyncTask是顺序执行么，for循环中执行200次new AsyncTask并execute，会有异常吗

IntentService生命周期是怎样的，使用场合等

RecyclerView和ListView有什么区别？局部刷新？前者使用时多重type场景下怎么避免滑动卡顿。懒加载怎么实现，怎么优化滑动体验。

SQLite的数据库升级用过么

开放问题：如果提高启动速度，设计一个延迟加载框架或者sdk的方法和注意的问题。

Scroller有什么方法，怎么使用的。

分享下项目中遇到的问题

webwiew了解？怎么实现和javascript的通信？相互双方的通信。@JavascriptInterface在？版本有bug，除了这个还有其他调用android方法的方案吗？
ReactiveNative了解多少

JNI和NDK熟悉么？Java和C方法之前的相互调用怎么做？

### 美团

static synchronized 方法的多线程访问和作用，同一个类里面两个synchronized方法，两个线程同时访问的问题

内部类和静态内部类和匿名内部类，以及项目中的应用

handler发消息给子线程，looper怎么启动

View事件传递

activity栈

封装view的时候怎么知道view的大小

arraylist和linkedlist的区别，以及应用场景

怎么启动service，service和activity怎么进行数据交互

下拉状态栏是不是影响activity的生命周期，如果在onStop的时候做了网络请求，onResume的时候怎么恢复

view渲染

### 今日头条

数据结构中堆的概念，堆排序

死锁的概念，怎么避免死锁

ReentrantLock 、synchronized和volatile（n面）

HashMap

singleTask启动模式

用到的一些开源框架，介绍一个看过源码的，内部实现过程。

消息机制实现

ReentrantLock的内部实现

App启动崩溃异常捕捉

事件传递机制的介绍

ListView的优化

二叉树，给出根节点和目标节点，找出从根节点到目标节点的路径

模式MVP，MVC介绍

断点续传的实现

集合的接口和具体实现类，介绍

TreeMap具体实现

synchronized与ReentrantLock

手写生产者/消费者模式

逻辑地址与物理地址，为什么使用逻辑地址

一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法

.Android进程分类

前台切换到后台，然后再回到前台，Activity生命周期回调方法。弹出Dialog，生命值周期回调方法。

Activity的启动模式

### 爱奇艺

RxJava的功能与原理实现

RecycleView的使用，原理，RecycleView优化

ANR的原因

四大组件

Service的开启方式

Activity与Service通信的方式

Activity之间的通信方式

HashMap的实现，与HashSet的区别

JVM内存模型，内存区域

Java中同步使用的关键字，死锁

MVP模式

Java设计模式，观察者模式

Activity与Fragment之间生命周期比较

广播的使用场景

###  百度

Bitmap 使用时候注意什么？

Oom 是否可以try catch ？

内存泄露如何产生？

适配器模式，装饰者模式，外观模式的异同？

ANR 如何产生？

String buffer 与string builder 的区别？

如何保证线程安全？

java四中引用

Jni 用过么？

多进程场景遇见过么？

关于handler，在任何地方new handler 都是什么线程下

sqlite升级，增加字段的语句

bitmap recycler 相关

强引用置为null，会不会被回收？

glide 使用什么缓存？

Glide 内存缓存如何控制大小？

如何保证多线程读写文件的安全？

### 携程

Activity启动模式

广播的使用方式，场景

App中唤醒其他进程的实现方式

AndroidManifest的作用与理解

List,Set,Map的区别

HashSet与HashMap怎么判断集合元素重复

Java中内存区域与垃圾回收机制

EventBus作用，实现方式，代替EventBus的方式

Android中开启摄像头的主要步骤

### 网易

集合

concurrenthashmap

volatile

synchronized与Lock

Java线程池

wait/notify

NIO

垃圾收集器

Activity生命周期

AlertDialog,popupWindow,Activity区别

### 小米

String 为什么要设计成不可变的？

fragment 各种情况下的生命周期

Activity 上有 Dialog 的时候按 home 键时的生命周期

横竖屏切换的时候，Activity 各种情况下的生命周期

Application 和 Activity 的 context 对象的区别

序列化的作用，以及 Android 两种序列化的区别。

List 和 Map 的实现方式以及存储方式。

静态内部类的设计意图。

线程如何关闭，以及如何防止线程的内存泄漏

### 360

软引用、弱引用区别

垃圾回收

多线程：怎么用、有什么问题要注意；Android线程有没有上限，然后提到线程池的上限

JVM

锁

OOM，内存泄漏

ANR怎么分析解决

LinearLayout、RelativeLayout、FrameLayout的特性、使用场景

如何实现Fragment的滑动

ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化

ListView重用的是什么

进程间通信的机制

AIDL机制

AsyncTask机制

如何取消AsyncTask

序列化

Android为什么引入Parcelable

有没有尝试简化Parcelable的使用

AIDL机制

项目：拉活怎么做的

应用安装过程

### 某海外直播公司

线程和进程的区别？

为什么要有线程，而不是仅仅用进程？

算法判断单链表成环与否？

如何实现线程同步？

hashmap数据结构？

arraylist 与 linkedlist 异同？

object类的equal 和hashcode 方法重写，为什么？

hashmap如何put数据（从hashmap源码角度讲解）？

简述IPC？

fragment之间传递数据的方式？

简述tcp四次挥手?

threadlocal原理

内存泄漏的可能原因？

用IDE如何分析内存泄漏？

OOM的可能原因？

线程死锁的4个条件？

差值器&估值器

简述消息机制相关

进程间通信方式？

Binder相关？

触摸事件的分发？

简述Activity启动全部过程？

okhttp源码？

RxJava简介及其源码解读？

性能优化如何分析systrace？

广播的分类？

点击事件被拦截，但是相传到下面的view，如何操作？

Glide源码？

ActicityThread相关？

volatile的原理

synchronize的原理

lock原理

翻转一个单项链表

string to integer

合并多个单有序链表（假设都是递增的）

### 其他公司

四大组件

Android中数据存储方式

微信主页面的实现方式

微信上消息小红点的原理

两个不重复的数组集合中，求共同的元素。

上一问扩展，海量数据，内存中放不下，怎么求出。

Java中String的了解。

ArrayList与LinkedList区别

堆排序过程，时间复杂度，空间复杂度

快速排序的时间复杂度，空间复杂度

RxJava的作用，与平时使用的异步操作来比，优势

Android消息机制原理

Binder机制介绍

为什么不能在子线程更新UI

JVM内存模型

Android中进程内存的分配，能不能自己分配定额内存

垃圾回收机制与调用System.gc()区别

Android事件分发机制

断点续传的实现

RxJava的作用，优缺点

## personnel

### 非技术问题

介绍你做过的哪些项目
都使用过哪些框架、平台？
都使用过哪些自定义控件？
研究比较深入的领域有哪些？
对业内信息的关注渠道有哪些？
最近都读哪些书？
有没有什么开源项目？
自己最擅长的技术点，最感兴趣的技术领域和技术点
项目中用了哪些开源库，如何避免因为引入开源库而导致的安全性和稳定性问题
实习过程中做了什么，有什么产出？

### HR提出的面试问题

您在前一家公司的离职原因是什么？
讲一件你印象最深的一件事情
介绍一个你影响最深的项目
介绍你最热爱最擅长的专业领域
公司实习最大的收获是什么？
与上级意见不一致时，你将怎么办？
自己的优点和缺点是什么？并举例说明？
你的学习方法是什么样的？实习过程中如何学习？实习项目中遇到的最大困难是什么以及如何解决的？
说一件最能证明你能力的事情
针对你你申请的这个职位，你认为你还欠缺什么
如果通过这次面试我们单位录用了你，但工作一段时间却发现你根本不适合这个职位，你怎么办？
项目中遇到最大的困难是什么？如何解决的？
你的职业规划以及个人目标、未来发展路线及求职定位
如果你在这次面试中没有被录用，你怎么打算？
评价下自己，评价下自己的技术水平，个人代码量如何？
通过哪些渠道了解的招聘信息，其他同学都投了哪些公司？
业余都有哪些爱好？
你做过的哪件事最令自己感到骄傲？
假如你晚上要去送一个出国的同学去机场，可单位临时有事非你办不可，你怎么办？
就你申请的这个职位，你认为你还欠缺什么？
当前的offer状况；如果BATH都给了offer该如何选？
你对一份工作更看重哪些方面？平台，技术，氛围，城市，还是money？
理想薪资范围；杭州岗和北京岗选哪个？
理想中的工作环境是什么？
谈谈你对跳槽的看法
说说你对行业、技术发展趋势的看法
实习过程中周围同事/同学有哪些值得学习的地方？
家人对你的工作期望及自己的工作期望
如果你的工作出现失误，给本公司造成经济损失，你认为该怎么办？
若上司在公开会议上误会你了，该如何解决？
是否可以实习，可以实习多久？
在五年的时间内，你的职业规划
你看中公司的什么？或者公司的那些方面最吸引你？



参考内容:

http://mp.weixin.qq.com/s/NBrEwFI8e8xtLsX0uadm7w

http://mp.weixin.qq.com/s/p3l9wr4DX976Lr62-dYe8w