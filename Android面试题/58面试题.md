#### Java中的集合类有哪些。区别是什么，如何保证安全性。

##### Collection、Map:

> Collection 分为两种类，List、Set，区别是 List 有序&可重复，而 Set 无序&不可重复。
> Map 为key-value的对应关系，key不可以重复

##### List
> List 接口是有序可重复的 Collection 接口实现，可以通过索引来访问 List 中的元素；
> 实现类 LinkedList、ArrayList、Vector；

> LinkedList 允许元素为null，并且提供了get、remove、insert方法在 LinkedList 的首部或尾部操作数据；
> 所以LinkedList可以作为堆栈（stack）、队列（queue）、双向队列（deque）；
> 需要注意的是，LinkedList 不是线程安全的，需要自己实现数据的访问同步，常用的解决方法是在创建List的时候构造一个同步List：
> List list = Collection.synchronizedList(new LinkedList());

> ArrayList 允许元素为null，同样也不是线程安全的，需要自己实现数据的同步访问。
> ArrayList 实例有一个容量 Capacity ，也就是用于存储元素的数组的大，从JDK1.8看到默认的出事容量为10，这个容量会随着不断添加新的元素而自动增加，
> 会通过调用 grow 方法对数组扩容量，使用的方法是，Arrays.copyof(elementData,newCapacity)进行数据拷贝，并设定新的容量。
> List list = Collection.synchronizedList(new LinkedList());

> Vector 与 ArrayList 类似都是使用数组实现的，默认容量为10，但是 Vector 是线程安全的。所以由 Vector 创建的 Iterator 被使用的时候，
> 另一个线程改变 Vector 状态，会抛出 ConcurrentModificationException，因此必须捕获这个异常。

> 使用场景：
> 当需要快速插入、删除元素，应该使用 LinkedList，如果需要快速随机访问元素，应该使用 ArrayList。
> 如果是单个线程使用，需要效率更更高。
> 如果是多线程同时操作一个类，因该使用线程安全的类。
> 使用的时候尽量的使用接口类声明，例如：List。目的是考虑到以后业务变成，由ArrayList 替换成了LinkedList，减少代码的修改。

> 总结 ArrayList & LinkedList
> - ArrayList 是基于动态数组的数据结构，LinkedList是基于链表的数据结构；
> - 随机访问数据，get和set，ArrayList更优于 LinkedList ，因为 LinkedList 是链表结构，需要移动指针，效率更低；
> - 对于新增和删除操作：
    如果只是对单条数据插入或删除，ArrayList 速度更快些。
    如果是批量随机的插入或删除数据，LinkedList 速度更快些。
    原因是 ArrayList 每插入一条数据就要移动插入点及后面的所有数据，效率更低，而 LinkedList 只需要替换插入点的前后指针引用即可完成操作；

> 总结 Vector 和 ArrayList
> - Vector 是线程同步的，所以是线程安全的，而 ArrayList 是线程异步的，不是线程安全的。通过源码看到，Vector 在操作的方法前使用 synchronized 进行同步操作
> - 默认情况下，在进行添加元素操作的时候，如果元素数目大于当前的集合数组的长度时，Vector 增长率为目前数组的 100% ，而 ArrayList 为 50%，同时 Vector 在创建时支持指定增长容量
> - 如果查找一个指定位置的数据， Vector 和 ArrayList 的使用时间是相同的O(1)。但移动一个指定未知的数据使用的时间是 O(n-1),n为总长度，这个时候就会考虑使用 LinkedList ，因为它使用的时间为O(1),而查询指定位置数据使用的时间为O(i)
> - ArrayList 和 Vector 都是采用数组的方式进行存储的，且数组元素数量大于实际存储的数据，以便增加或插入，可以直接通过索引访问元素。
> - Vector 由于使用了 synchronized 方法所以性能上会比 ArrayList 差一些，LinkedList 使用的是双链表实现的存储，按照序号索引数据可以进行向前或向后遍历，但是插入数据时只需要记录当前元素的前后项即可，所以插入速度更快些。

##### Set
> Set 接口是无序不可重复 Collection 接口实现，
> 实现类有，HashSet、TreeSet

> HashSet 无序，不可重复，可以存储null，是通过哈希算法来实现防止重复的，存放元素也是key-value的形式，可以通过迭代器遍历获取数据；
> 不是线程安全的。

> TreeSet 有序，不可重复，不可以存储null，相对于 HashSet 提供了排序方法，TreeSet 是基于 TreeMap 实现的，底层数据结构是：二叉树。
> 不是线程安全的。


##### Map
> key-value 形式存在，key不能重复。
> 实现类有，HashMap、TreeMap、LinkedHashMap、Hashtable

> HashMap 无序的，根据key的HashCode值存储数据，根据键直接获取它对应的值，具有很快的访问速度，遍历时获取的数据顺序是随机的。
> 因为键不可以重复，所以 HashMap 只允许记录一条 key 为 null 的数据，不限制 value 为 null 的数据。
> 使用 Node数组+链表+恭嘿书的数据结构实现的。
> 如果 key 是自定义类的话，需要实现 hashCode() 和 equals() 方法实现。
> 不是线程安全的。
> 可以使用 Collection.synchronizedMap(hashMap)来达到同步的效果

> Hashtable 与 HashMap 特性相似，不同的地方 Hashtable 是线程安全的，支持线程同步，任一时刻只有一个线程能写 Hashtable ,
> 因此导致效率比较差，继承自 Dictionary 类。同时也不允许记录，key 或 value 为 null 的数据。
> 线程安全

> ConcurrentHashMap 是线程安全的，实现原理如下：
> 使用锁分离思想，只锁住一个node，而锁住的Node之前的操作是基于在 volatile 和 CAS算法 之上无锁并且线程安全的；
> CAS 是一种算法，基本思想就是不断的去比较当前内存中的变量值与指定的一个变量值是否相等，如果相等则接受，否则拒绝。

> LinkedHashMap 具有HashMap全部特性，不同的是，记录了插入数据的顺序，在使用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，速度比 HashMap 慢;

> TreeMap 实现了 SortMap 接口，能够把保存的记录根据键排序，默认是按键值的升序排序，也可以指定比较器；
> 当使用 Iterator 遍历 TreeMap 时，得到的记录是排序后的，不允许 kye 为 null
> 不是线程不安全

> 总结
> - 当在Map中插入、删除、定位元素，HashMap 速度比较快，因为是无序的，通过 HashCode 定位；
> - 如果需要自然然排序或自定义排序，TreeMap 是最好的选择，因为它实现了 SortMap 默认按照key升序排序；
> - 如果需要输出数据与输入时候相同，LinkedHashMap 是比较好的选择。


#### 为什么使用线程池？Java线程池关键参数？解决什么问题？有什么业务场景？如果超出了线程池的大小会发什么？

##### 为什么使用线程池？
```markdown
因为使用传统的 new Thread() 创建子线程会有以下问题：
- 1 

```




安卓应用间可以进行通讯的方式有哪些，有什么区别。

安卓广播机制有哪些，区别是什么。

Java中的集合类有哪些。区别是什么，如何保证安全性。

Android的集合类有哪些？如何保证安全性，有什么好处。

做过哪些安卓性能优化？

如何检测应用卡顿，如何优化？

造成安卓oom的原因有哪些？如何处理。

RxJava的实现机制，如何处理背压。

RetureFate实现原理

对现在存在的Glide还有哪些优化方案？

安卓中的内存泄漏如何解决，为什么会造成内存泄漏？

如何检测内存泄漏？

点击桌面应用图标之后发什么什么，回调了哪些方法。

java中的lock相关。

Activity  与 Fragment 相关生命周期对照

能不能试用Applaction启动一个Activity为什么不能？

AMS，PMS，WMS

文件存储，分别使用的场景，SP是线程安全的么？是进程安全的么？如何保证安全性