# Java内存模型
> JMM(Java 内存模型)：当多个线程再访问同一个变量的时候，其中一个线程改变了该变量的值，但是并未写入主存，那么其他线程就会读取到旧值，无法获取到最新的值


Java 内存模型定义了线程和主存之间的抽象关系，线程之间的共享变量存储在主存中，每个线程都会拥有属于自己的私有工作内存（这个内存分配在栈里面），在工作内存中，只会存储该线程使用到的共享变量的副本，这里的私有工作内存其实是一个抽象的概念，它包括了缓存，写缓冲区，寄存器等。Java 内存模型控制线程之间的通信，它决定一个线程对驻村共享变量的写入何时对另一个线程可见。
![jmm]($resource/jmm.jpg)

通过图中分析出：
1、每个线程在执行的时候都会有自己的工作内存，其中包括了方法里面所包含的所有变量等；
2、每个线程的私有工作内存是不能互相访问的，这也就解释了为什么我们不能在同一个方法中访问另一个方法的局部变量；
3、当线程想要访问共享变量的时候，需要从主存中获取，在自己的方法区中只是保存的变量的副本。
4、当我们修改完共享变量的时候，需要把改过的变量写入主存中，这样才能让其他的线程获取正确的值。

总结：
- 线程 A 把线程 A 本地内存中更新过的共享变量刷新到主存中
- 线程 B 到主存中去读取线程 A 之前已经更新过的共享变量的值

```java
int i = 1；
```
被线程执行的时候的场景：执行线程先把变量 i 的值的副本存放到自己的工作线程，然后再把值写入到主存中，而不是直接写入到主存；

# Java 内存分区
![fenqu]($resource/fenqu.jpg)
- 寄存器
  - JVM 内部虚拟寄存器,存取速度非常快,程序不可控
- Java 虚拟机栈
  - 它是线程私有的，生命周期与线程相同。
  - 每个方法被执行的时候都会同时创建一个栈帧（StackFrame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。
  - 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。存放了编译器可知的各种基本数据类型（boolean、char、int、long、short、byte、double、float）、对象引用（reference 类型，不同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。
  - 
- 堆
  - Java 堆是 Java 虚拟机所管理的内存中最大的一块。
  - Java 堆是被线程共享的一块内存区域，在虚拟机启动时创建。
  - Java 堆的唯一作用就是存放对象实例。几乎所有的对象实例都在这里分配内存。
  - 所有的对象实例，以及数组都要在堆上分配。
  - Java 堆是垃圾收集器管理的主要区域。

- 方法区
  - 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 常量池（其实是方法区的一部分）
  - JVM 为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量（基本类型，String）和对其他类型、方法、字段等符号引用。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在 Java 的动态链接中起到了核心作用。

### 注意事项
- 对象所拥有的方法以及里面涉及到的变量都存储在栈里面，方法里面使用到的局部变量是随着对象实例一起存储在堆里面，在方法中使用的时候也是使用该全局变量的副本。
- 对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储在堆区；
- 方法区和堆一样，是各个线程共享的区域，里面存放 Java 虚拟机加载的类信息，常量，静态变量，即使编译器编译后的代码等数据。
- 分清什么是实例，什么是对象，Class a = new Class();此时 a 叫实例，而不能说 a 是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。（一个对象可以有多个引用地址）

# 关于 Volatile 关键字
- 不保证原子性
- 保证有序性
- 保证可见性
当使用 Volatile 修饰共享变量的时候，线程访问到该变量时候都会去主存中获取变量的值，它的工作内存中的缓存将失效，这样就保证了每个线程访问该变量的时候都是从主存中读写的。这就是使用 Volatile 关键字来修饰线程间共享变量的原因。

# 拓展面试
## 对于字符串，其对象的引用都是存储在栈中。
- 如果是编译期已经创建好的（直接使用双引号声明的）就存储在常量池中。
- 如果是运行期（new 出来的）存储在堆中
- 对于 equals 相等的字符串，在常量池中永远只有一份，在堆中有多份。
```java
String s1 = "china";
String s2 = "china";
String s3 = "china";

String ss1 = new String("china");
String ss2 = new String("china");
String ss3 = new String("china");
```
![String 内存模型]($resource/908514-20160720101024841-238269977.jpg)
Java 中 String 的内存模型比较特殊，使用 new 创建一个字符串『ABC』的时候，会先去常量池中查找是否已经有了『ABC』对象，如果没有则在常量池中创建一个『ABC』对象，然后堆中再创建一个常量池中『ABC』对象的拷贝对象。

**问：```String str=new String("ABC");``` 产生几个对象？**
**答： 如果常量池中原来没有"ABC"即，创建两个，如果有，则创建一个；**

## **成员变量和局部变量在内存中的分配**
- 成员变量就是方法外部，类内部定定义的变量；
- 局部变量就是方法或语句块内部定义的变量；
- 局部变量必须初始化，方法的形参也是局部变量，局部变量的数据存在栈内存中；
- 栈内存中的局部变量随着方法的小时而消失；
- 成员变量存储在堆中的对象里面，由垃圾回收器 GC 负责回收；
```java
class BirthDate{
  private int day;
  private int month;
  private int year;

  public BirthDate(int d,int m,int y){
     day = d;
     month = m;
     year = y;
  }
}

public class Test{
  public void change(int i){
    i = 1122;
  }

  public static void main(String args[]){
    int date = 9;
    Test test = new Test();
    test.change(date);
    BirthDate d1 = new BirthDate(9,9,1999);
  }
}
```
分析上面代码：
- date 为局部变量，i、d、m、y 都是形参同为局部变量，day、month、year 为成员变量。
  - main 方法开始执行：int date = 9；date 为局部变量，基础类型，引用和值都存在栈中；
  - Test test = new Test()；test 为对象的引用，存在栈中，对象 new Test() 存在堆中；
    - **这里需要注意的是调用 test.change(date)；是值传递；**
  - BirthDate d1 = new BirthDate(9，9，1999)；
    - d1 为对象引用，存在栈中，对象 new BirthDate() 存在堆中，它的构造函数中的 d、m、y 均为局部变量存储在栈中，且它们的类型为基础类型，因此他们的数据也存储在栈中。
    - day、month、year 均为成员变量，他们存储在堆中 new BirthDate() 里面，当 BirthDate 构造方法执行完之后，d、m、y 也将从栈中消失；
  - main 方法执行完之后，date 变量，test，d1 引用将从栈中消失，new Test()，new BirthDate()将等待垃圾回收；
![20190330153004]($resource/20190330153004.png)

