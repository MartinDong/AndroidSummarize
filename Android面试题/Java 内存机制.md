# Java内存模型
> JMM(Java 内存模型)：当多个线程再访问同一个变量的时候，其中一个线程改变了该变量的值，但是并未写入主存，那么其他线程就会读取到旧值，无法获取到最新的值


Java 内存模型定义了线程和主存之间的抽象关系，线程之间的共享变量存储在主存中，每个线程都会拥有属于自己的私有工作内存（这个内存分配在栈里面），在工作内存中，只会存储该线程使用到的共享变量的副本，这里的私有工作内存其实是一个抽象的概念，它包括了缓存，写缓冲区，寄存器等。Java 内存模型控制线程之间的通信，它决定一个线程对驻村共享变量的写入何时对另一个线程可见。
![jmm]($resource/jmm.jpg)

通过图中分析出：
1、每个线程在执行的时候都会有自己的工作内存，其中包括了方法里面所包含的所有变量等；
2、每个线程的私有工作内存是不能互相访问的，这也就解释了为什么我们不能在同一个方法中访问另一个方法的局部变量；
3、当线程想要访问共享变量的时候，需要从主存中获取，在自己的方法区中只是保存的变量的副本。
4、当我们修改完共享变量的时候，需要把改过的变量写入主存中，这样才能让其他的线程获取正确的值。

总结：
- 线程 A 把线程 A 本地内存中更新过的共享变量刷新到主存中
- 线程 B 到主存中去读取线程 A 之前已经更新过的共享变量的值

```java
int i = 1；
```
被线程执行的时候的场景：执行线程先把变量 i 的值的副本存放到自己的工作线程，然后再把值写入到主存中，而不是直接写入到主存；

# Java 内存分区
![fenqu]($resource/fenqu.jpg)
- 寄存器
  - JVM 内部虚拟寄存器,存取速度非常快,程序不可控
- Java 虚拟机栈
  - 它是线程私有的，生命周期与线程相同。
  - 每个方法被执行的时候都会同时创建一个栈帧（StackFrame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。
  - 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。存放了编译器可知的各种基本数据类型（boolean、char、int、long、short、byte、double、float）、对象引用（reference 类型，不同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。
  - 
- 堆
  - Java 堆是 Java 虚拟机所管理的内存中最大的一块。
  - Java 堆是被线程共享的一块内存区域，在虚拟机启动时创建。
  - Java 堆的唯一作用就是存放对象实例。几乎所有的对象实例都在这里分配内存。
  - 所有的对象实例，以及数组都要在堆上分配。
  - Java 堆是垃圾收集器管理的主要区域。

- 方法区
  - 方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- 常量池（其实是方法区的一部分）
  - JVM 为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量（基本类型，String）和对其他类型、方法、字段等符号引用。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在 Java 的动态链接中起到了核心作用。

### 注意事项
- 对象所拥有的方法以及里面涉及到的变量都存储在栈里面，方法里面使用到的局部变量是随着对象实例一起存储在堆里面，在方法中使用的时候也是使用该全局变量的副本。
- 对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储在堆区；
- 方法区和堆一样，是各个线程共享的区域，里面存放 Java 虚拟机加载的类信息，常量，静态变量，即使编译器编译后的代码等数据。
- 分清什么是实例，什么是对象，Class a = new Class();此时 a 叫实例，而不能说 a 是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。（一个对象可以有多个引用地址）

# 关于 Volatile 关键字
- 不保证原子性
- 保证有序性
- 保证可见性
当使用 Volatile 修饰共享变量的时候，线程访问到该变量时候都会去主存中获取变量的值，它的工作内存中的缓存将失效，这样就保证了每个线程访问该变量的时候都是从主存中读写的。这就是使用 Volatile 关键字来修饰线程间共享变量的原因。