{"compress":true,"commitItems":[["1bc3b572-47fa-49a2-a690-c1110d3a4d7e",1519699489238,"",[[1519699474819,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,0,"阿里ARouter使用及源码解析（一）\n===\n\n\n"]],[0,0],[26,26]]],[1519699488637,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,0,"阿里"],[1,2,"![](//upload-images.jianshu.io/upload_images/5994347-767a114aa4746c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\napp中可能存在多个模块，每个模块下面都有一个root结点，每个root结点都会管理整个模块中的group节点，每个group结点则包含了该分组下的所有页面，而每个模块允许存在多个分组，每个模块中都会有一个拦截器节点就是Interceptor结点，除此之外每个模块还会有控制拦截反转的provider结点\n\n##### 最后\n\n到此，关于"],[-1,9,"使用及源码解析（一）\n===\n\n\n"],[1,26,"的基本用法以及原理分析的就全部结束了，如果有不清楚或者错误的地方，希望各位同学指出。关于ARouter拦截器，各种服务，依赖注入等更多进阶用法及源码分析会更新在后续的文章。\n\n作者：time_fly\n链接：https://www.jianshu.com/p/46d174f37e82\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[0,26],[484,484]]],[1519699499503,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,0,"在app的开发中，页面之间的相互跳转是最基本常用的功能。在Android中的跳转一般通过显式intent和隐式intent两种方式实现的，而Android的原生跳转方式会存在一些缺点：\n\n*   显式intent的实现方式，因为会存在直接的类依赖的问题，导致耦合严重；\n*   隐式intent的实现方式，则会出现规则集中式管理，导致协作变得困难；\n*   可配置性较差，一般而言配置规则都是在Manifest中的，这就导致了扩展性较差；\n*   跳转过程无法控制，一旦使用了StartActivity()就无法插手其中任何环节了，只能交给系统管理；\n*   当多组件化开发，使用原生的路由方式很难实现完全解耦；\n\n而阿里的[ARouter](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)路由框架具有解耦、简单易用、支持多模块项目、定制性较强、支持拦截逻辑等诸多优点，很好的解决了上述的问题。关于ARouter具体实现功能，典型应用以及相应技术方案实现的介绍不在这详细介绍，具体可参见[开源最佳实践：Android平台页面路由框架ARouter](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)。\n\n阿里ARouter的分析计划\n\n*   [阿里ARouter使用及源码解析（一）](https://www.jianshu.com/p/46d174f37e82)\n*   [阿里ARouter拦截器使用及源码解析（二）](https://www.jianshu.com/p/c8d7b1379c1b)\n*   阿里ARouter参数自动装载使用及源码解析（三）\n\n##### 基本功能使用\n\n1.添加依赖和配置\n\n```\nandroid {\n    defaultConfig {\n    ...\n    javaCompileOptions {\n        annotationProcessorOptions {\n        arguments = [ moduleName : project.getName() ]\n        }\n    }\n    }\n}\n\ndependencies {\n    compile 'com.alibaba:arouter-api:1.2.1.1'\n    annotationProcessor 'com.alibaba:arouter-compiler:1.1.2.1'\n    ...\n}\n\n```\n\n2.添加注解\n\n```\n// 在支持路由的页面上添加注解(必选)\n// 这里的路径需要注意的是至少需要有两级，/xx/xx\n@Route(path = \"/test/test1\")\npublic class Test1Activity extends AppCompatActivity{\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_test1);\n    }\n}\n\n```\n\n3.初始化SDK\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            // 如果使用了InstantRun，必须在初始化之前开启调试模式，但是上线前需要关闭，InstantRun仅用于开发阶段，\n            // 线上开启调试模式有安全风险，可以使用BuildConfig.DEBUG来区分环境\n            ARouter.openDebug();\n            ARouter.init(getApplication()); // 尽可能早，推荐在Application中初始化\n        }\n    }\n}\n\n```\n\n4.发起跳转操作\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            ....\n        } else if (v.getId() == R.id.btn2){\n            ARouter.getInstance().build(\"/test/test1\").navigation();\n        }\n    }\n}\n\n```\n\n以上相关代码就是ARouter的最基本功能使用的步骤，下面来分析跳转功能是如何实现的。\n\n##### 原理分析\n\n###### 1.ARouter编译的过程\n\nARouter在编译期的时候，利用自定义注解完成了页面的自动注册。相关注解源码参见[arouter-annotation](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)，编译处理器源码参见[arouter-compiler](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n\n下面是注解`@Route`的源码介绍：\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.CLASS)\npublic @interface Route {\n\n    /**\n     *路由的路径，标识一个路由节点\n     */\n    String path();\n\n    /**\n     * 将路由节点进行分组，可以实现按组动态加载\n     */\n    String group() default \"\";\n\n    /**\n     * 路由节点名称，可用于生成javadoc文档\n     */\n    String name() default \"undefined\";\n\n    /**\n     * 用32位int类型标示，可用于页面的一些配置\n     */\n    int extras() default Integer.MIN_VALUE;\n\n    /**\n     * 路由的优先级\n     */\n    int priority() default -1;\n}\n\n```\n\nRoute中的`extra`值是个int值，由32位表示，即转换成二进制后，一个int中可以配置31个1或者0，而每一个0或者1都可以表示一项配置（排除符号位），如果从这31个位置中随便挑选出一个表示是否需要登录就可以了，只要将标志位置为1，就可以在声明的拦截器中获取到这个标志位，通过位运算的方式判断目标页面是否需要登录。所以可以通过`extra`给页面配置30多个属性，然后在拦截器中去进行处理。\nARouter在拦截器中会把目标页面的信息封装一个类`Postcard`，这个类就包含了目标页面注解上`@Route`标识的各种信息。关于拦截器的使用以及源码分析，后续会有介绍。\n\n将代码编译一遍，可以看到ARouter生成下面几个源文件：\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n\n上面三个文件均是通过注解处理器`RouteProcessor`生成的，关于如何自定义注解处理器，可以阅读[Android编译时注解APT实战（AbstractProcessor）](https://www.jianshu.com/p/07ef8ba80562)，同时也需要学习**JavaPoet**的基本使用。下面我们看`RouteProcessor`是如何生成相关文件的。\n\n```\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //判断被注解了的元素集合是否为空\n        if (CollectionUtils.isNotEmpty(annotations)) {\n            //获取所有被@Route注解的元素集合，Element可以是类、方法、变量等\n            Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);\n            try {\n                logger.info(\">>> Found routes, start... <<<\");\n                //具体处理注解，生成java文件的方法\n                this.parseRoutes(routeElements);\n\n            } catch (Exception e) {\n                logger.error(e);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n```\n\n`process()`方法相当于处理器的主函数`main()`，可以在这个方法中扫描、评估和处理注解的代码，以及生成Java文件。`RouteProcessor`中调用了`parseRoutes()`，用来处理所有被`@Route`注解的元素。在分析上述三个java文件如何生成之前，先看看生成文件的具体代码。\n\n*   ARouter$$Root$$app类\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n*   ARouter$$Group$$test类\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/test/test1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/test1\", \"test\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   ARouter$$Providers$$app类\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n  }\n}\n\n```\n\n我们接着分析上述三个文件是如何生成的\n\n1.首先获取生成方法的参数的类型和参数名称\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n\n            logger.info(\">>> Found routes, size is \" + routeElements.size() + \" <<<\");\n\n            rootMap.clear();\n             // TypeElement 表示一个类或接口元素\n            // public static final String ACTIVITY = \"android.app.Activity\";\n            //得到类activity元素\n            TypeElement type_Activity = elementUtil.getTypeElement(ACTIVITY);\n            // public static final String SERVICE = \"android.app.Service\";\n            //得到类service的元素\n            TypeElement type_Service = elementUtil.getTypeElement(SERVICE);\n            // public static final String SERVICE = \"android.app.Fragment\";\n            TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();\n             // public static final String SERVICE = \"android.support.v4.app.Fragment\";\n            TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();\n\n            // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IRouteGroup\";\n            //得到接口IRouteGroup元素\n            TypeElement type_IRouteGroup = elementUtil.getTypeElement(IROUTE_GROUP);\n          // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IProviderGroup\";\n            //得到接口IProviderGroup元素\n            TypeElement type_IProviderGroup = elementUtil.getTypeElement(IPROVIDER_GROUP);\n            //获取RouteMeta，RouteType类名\n            ClassName routeMetaCn = ClassName.get(RouteMeta.class);\n            ClassName routeTypeCn = ClassName.get(RouteType.class);\n\n            //下面代码是获取生成java文件中方法的参数类型名称和参数名称。\n            /*\n              获取获取ARouter$$Root$$app 类中方法参数Map<String, Class<? extends IRouteGroup>>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ParameterizedTypeName.get(\n                            ClassName.get(Class.class),\n                            WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))\n                    )\n            );\n\n            /*\n              获取ARouter$$Group$$test，ARouter$$Providers$$app类中方法参数 Map<String, RouteMeta>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ClassName.get(RouteMeta.class)\n            );\n\n            /*\n             获取相关的参数\n             */\n            //获取ARouter$$Root$$app 类中方法的参数Map<String, Class<? extends IRouteGroup>> routes\n            ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, \"routes\").build();\n           //获取ARouter$$Group$$test类中方法的参数Map<String, RouteMeta> atlas\n            ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"atlas\").build();\n             //获取ARouter$$Providers$$app类中方法的参数Map<String, RouteMeta> providers\n            ParameterSpec providerParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"providers\").build();  \n\n          .....\n        }\n    }\n\n```\n\n2.获取了方法的参数的类型和参数名称后，下面便是生成相应的方法\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n            /*\n              首先创建ARouter$$Root$$xxx 类中的loadInto()方法\n              @Override\n              public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(rootParamSpec);\n\n            //  遍历所有被@Route注解的元素\n            for (Element element : routeElements) {\n                TypeMirror tm = element.asType();\n                Route route = element.getAnnotation(Route.class);\n                RouteMeta routeMete = null;\n\n                //判断该元素否为 Activity 、IProvider 、 Service 的子类，然后创建相应的RouteMeta 对象\n                if (typeUtil.isSubtype(tm, type_Activity.asType())) {                 // Activity\n                    logger.info(\">>> Found activity route: \" + tm.toString() + \" <<<\");\n\n                    // 如果是acitiviy类型，获取所有被@Autowired的属性\n                    //关于@Autowired的注解，我们之后再进行分析\n                    Map<String, Integer> paramsType = new HashMap<>();\n                    for (Element field : element.getEnclosedElements()) {\n                        if (field.getKind().isField() && field.getAnnotation(Autowired.class) != null && !typeUtil.isSubtype(field.asType(), iProvider)) {\n                            // It must be field, then it has annotation, but it not be provider.\n                            Autowired paramConfig = field.getAnnotation(Autowired.class);\n                            paramsType.put(StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name(), TypeUtils.typeExchange(field.asType()));\n                        }\n                    }\n                    // ACTIVITY类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.ACTIVITY, paramsType);\n                } else if (typeUtil.isSubtype(tm, iProvider)) {         // IProvider\n                    logger.info(\">>> Found provider route: \" + tm.toString() + \" <<<\");\n                    //从该判断可看出，如果要想成功注册一个 PROVIDER 类型的路由节点，\n                    //一定要实现 com.alibaba.android.arouter.facade.template.IProvider 这个接口\n                    routeMete = new RouteMeta(route, element, RouteType.PROVIDER, null);\n                } else if (typeUtil.isSubtype(tm, type_Service.asType())) {           // Service\n                    logger.info(\">>> Found service route: \" + tm.toString() + \" <<<\");\n                     //SERVICE类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(SERVICE), null);\n                } else if (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) {\n                    logger.info(\">>> Found fragment route: \" + tm.toString() + \" <<<\");\n                   //FRAGMENT类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(FRAGMENT), null);\n                }\n\n                //routeMete包含了每个路由节点的各种信息，下面的方法的主要功能就是根据@Route注解信息对节点进行分组，保存在groupMap集合中。\n               //关于方法的具体实现，后面会有解析\n                categories(routeMete);\n\n            }\n\n            .........\n        }\n    }\n\n```\n\n以上代码主要功能就是遍历所有被@Route注解的元素，然后将每个路由节点的信息按照类型（ACTIVITY类型，实现了IProvider 接口类型以及SERVICE类型）封装到`RouteMeta`中，最后调用`categories(routeMete)`方法将节点分组，保存在`groupMap`集合。\n\n继续往下分析\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n             /*\n              然后创建ARouter$$Providers$$xxx 类中的loadInto()方法\n             @Override\n             public void loadInto(Map<String, RouteMeta> providers) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfProviderBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(providerParamSpec);\n\n            //遍历分组的集合，生成相应的java文件\n           //因为本文使用的例子没有对页面进行分组，所以只生成了一个组文件ARouter$$Group$$xxx\n            for (Map.Entry<String, Set<RouteMeta>> entry : groupMap.entrySet()) {\n                String groupName = entry.getKey();\n               /*\n                  创建ARouter$$Group$$xxx 类中的loadInto()方法\n                 @Override\n                 public void loadInto(Map<String, RouteMeta> atlas) {}\n             */\n                MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                        .addAnnotation(Override.class)\n                        .addModifiers(PUBLIC)\n                        .addParameter(groupParamSpec);\n\n                // 生成loadInto()方法体\n                Set<RouteMeta> groupData = entry.getValue();\n                //遍历每个组里面的路由节点\n                for (RouteMeta routeMeta : groupData) {\n                    switch (routeMeta.getType()) {\n                        //如果节点类型是PROVIDER，\n                        case PROVIDER:  \n                          //获取路由节点元素的接口集合\n                            List<? extends TypeMirror> interfaces = ((TypeElement) routeMeta.getRawType()).getInterfaces();\n                            for (TypeMirror tm : interfaces) {\n                             if (types.isSameType(tm, iProvider)) {   // Its implements iProvider interface himself.\n                                   //路由节点元素其中一个接口是 com.alibaba.android.arouter.facade.template.IProvider \n                                  //给ARouter$$Providers$$xxx 类中的loadInto()添加方法体\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            (routeMeta.getRawType()).toString(),//路由节点元素的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                } else if (types.isSubtype(tm, iProvider)) {\n                                   //路由节点元素其中一个接口是com.alibaba.android.arouter.facade.template.IProvider 接口的子类型\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            tm.toString(),   //IProvider子类型的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                }\n                            //上面方法体的代码为：\n                          //providers.put(\"实现接口的名称\", RouteMeta.build(RouteType.PROVIDER, 类名.class,   \"@Route.path\", \"@Route.group\", null, @Route.priority, @Route.extras));\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n\n                    // 将路由节点中被@Autowired注解的属性集合转换成字符串\n                    StringBuilder mapBodyBuilder = new StringBuilder();\n                    //获取路由节点中被@Autowired注解的属性集合\n                    Map<String, Integer> paramsType = routeMeta.getParamsType();\n                    if (MapUtils.isNotEmpty(paramsType)) {\n                        for (Map.Entry<String, Integer> types : paramsType.entrySet()) {\n                            mapBodyBuilder.append(\"put(\\\"\").append(types.getKey()).append(\"\\\", \").append(types.getValue()).append(\"); \");\n                        }\n                    }\n                    String mapBody = mapBodyBuilder.toString();\n\n                    //给ARouter$$Group$$xxx 类中的loadInto()添加方法体\n                    //注意：有多个分组就会创建多个组文件\n                    loadIntoMethodOfGroupBuilder.addStatement(\n                            \"atlas.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, \" + (StringUtils.isEmpty(mapBody) ? null : (\"new java.util.HashMap<String, Integer>(){{\" + mapBodyBuilder.toString() + \"}}\")) + \", \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                            routeMeta.getPath(),\n                            routeMetaCn,\n                            routeTypeCn,\n                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                            routeMeta.getPath().toLowerCase(),\n                            routeMeta.getGroup().toLowerCase());\n                }\n\n                  // 真正生成ARouter$$Group$$test JAVA文件\n                 //NAME_OF_GROUP = ARouter$$Group$$\n                //  groupName = test; 关于groupname的值在方法categories(routeMete)中会有讲解\n                String groupFileName = NAME_OF_GROUP + groupName;\n                JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                        TypeSpec.classBuilder(groupFileName)\n                                .addJavadoc(WARNING_TIPS)\n                                .addSuperinterface(ClassName.get(type_IRouteGroup))\n                                .addModifiers(PUBLIC)\n                                .addMethod(loadIntoMethodOfGroupBuilder.build())\n                                .build()\n                ).build().writeTo(mFiler);\n\n                logger.info(\">>> Generated group: \" + groupName + \"<<<\");\n                //将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备\n                rootMap.put(groupName, groupFileName);\n            }\n\n         .......\n        }\n    }\n\n```\n\n以上代码主要功能由几点：\n\n*   遍历`groupmap`集合给ARouter$$Group$$xxx类中的`loadInto()`添加方法体，并且生成ARouter$$Group$$xxx JAVA文件，而文件命名为ARouter$$Group$$+groupname，其中有多个分组就会创建多个组文件。比如`AROUTER`源码中的样例就生成了多个分组文件\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n\n两个分组文件\n\n关于生成的`loadInto()`中的方法体的例子，来自 `AROUTER`源码中的样例：\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    //存在被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/activity1\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"name\", 18); put(\"boy\", 0); put(\"age\", 3); put(\"url\", 18); }}, -1, -2147483648));\n    .....\n   //没有被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity4\", RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, \"/test/activity4\", \"test\", null, -1, -2147483648));\n    ....\n  }\n}\n\n```\n\n*   遍历每个组里面的路由节点，查找节点类型是否为PROVIDER类型，如果是就向给ARouter$$Providers$$xxx类中的`loadInto()`添加方法，其文件命名ARouter$$Providers$$+modulename。关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.HelloService\", RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, \"/service/hello\", \"service\", null, -1, -2147483648));\n    //路由节点元素其中一个接口是IProvider的子类型\n    providers.put(\"com.alibaba.android.arouter.facade.service.SerializationService\", RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, \"/service/json\", \"service\", null, -1, -2147483648));\n     //路由节点元素其中一个接口是IProvider接口\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.SingleService\", RouteMeta.build(RouteType.PROVIDER, SingleService.class, \"/service/single\", \"service\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备，其文件命名ARouter$$Root$$+modulename。\n\n我们接着分析`parseRoutes()`方法最后一段代码，这段代码其实很简单，主要目的就是给ARouter$$Root$$xxx的`loadInto()`添加方法体，最后生成Router$$Providers$$xxx，ARouter$$Root$$xxx文件\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n            //遍历rootMap集合，给ARouter$$Root$$xxx的`loadInto()`添加方法体\n            if (MapUtils.isNotEmpty(rootMap)) {\n                // Generate root meta by group name, it must be generated before root, then I can findout the class of group.\n                for (Map.Entry<String, String> entry : rootMap.entrySet()) {\n                    loadIntoMethodOfRootBuilder.addStatement(\"routes.put($S, $T.class)\", entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));\n                }\n            }\n\n            // 生成Router$$Providers$$xxx文件\n            String providerMapFileName = NAME_OF_PROVIDER + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(providerMapFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(type_IProviderGroup))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfProviderBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated provider map, name is \" + providerMapFileName + \" <<<\");\n\n            // 生成ARouter$$Root$$xxx文件\n            String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(rootFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(elementUtil.getTypeElement(ITROUTE_ROOT)))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfRootBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated root, name is \" + rootFileName + \" <<<\");\n        }\n    }\n\n```\n\n关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"service\", ARouter$$Group$$service.class);\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n**上面分析的便是`parseRoutes()`方法所有代码的解析**\n\n3.最后我们看下`categories()`方法是如何分组的\n\n```\n   private void categories(RouteMeta routeMete) {\n        //如果路由路径合法，且有groupname进行执行\n        if (routeVerify(routeMete)) {\n            logger.info(\">>> Start categories, group = \" + routeMete.getGroup() + \", path = \" + routeMete.getPath() + \" <<<\");\n             //根据groupname获取该组的路由节点集合，如果集合为空，则创建一个新的组，将该节点添加进去，并将组集合保存在groupmap中；\n          //不为空，则添加到所属的组集合中去\n            Set<RouteMeta> routeMetas = groupMap.get(routeMete.getGroup());\n            if (CollectionUtils.isEmpty(routeMetas)) {\n                Set<RouteMeta> routeMetaSet = new TreeSet<>(new Comparator<RouteMeta>() {\n                    @Override\n                    public int compare(RouteMeta r1, RouteMeta r2) {\n                        try {\n                            return r1.getPath().compareTo(r2.getPath());\n                        } catch (NullPointerException npe) {\n                            logger.error(npe.getMessage());\n                            return 0;\n                        }\n                    }\n                });\n                routeMetaSet.add(routeMete);\n                groupMap.put(routeMete.getGroup(), routeMetaSet);\n            } else {\n                routeMetas.add(routeMete);\n            }\n        } else {\n            logger.warning(\">>> Route meta verify error, group is \" + routeMete.getGroup() + \" <<<\");\n        }\n    }\n\n//判断路由路径是否合法，并且设置groupname\n private boolean routeVerify(RouteMeta meta) {\n        String path = meta.getPath();\n        //如果路径为空，或者不是由'/'开头，返回false\n        if (StringUtils.isEmpty(path) || !path.startsWith(\"/\")) {   // The path must be start with '/' and not empty!\n            return false;\n        }\n\n         //如果在@Route注解中没有设置group标识，那么就默认取path路径第一段路径名作为groupname\n        if (StringUtils.isEmpty(meta.getGroup())) { // Use default group(the first word in path)\n            try {\n                String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n                if (StringUtils.isEmpty(defaultGroup)) {\n                    return false;\n                }\n\n                meta.setGroup(defaultGroup);\n                return true;\n            } catch (Exception e) {\n                logger.error(\"Failed to extract default group! \" + e.getMessage());\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n```\n\n通过分析，如果@Route注解中有设置group标识，作为groupname，如果没有就取/xxx1/xxx2，xxx1作为groupname，并将同一组的路由节点放到同一个集合中去。\n\n至此关于`@Route`注解在编译期时生成ARouter$$Root$$xxx，Router$$Providers$$xxx，ARouter$$Group$$xxx三种映射文件的源码分析完毕。\n\n###### 2.ARouter初始化过程\n\nARouter经过代码编译后，生成了相应的映射文件，我们可以断定，ARouter 的初始化会将这些文件加载到内存中去，形成一个路由表，以供后面路由查找跳转之用。其相关源码可参见 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `ARouter`的`init()`方法\n\n```\npublic static void init(Application application) {\n        if (!hasInit) {\n            logger = _ARouter.logger;\n            _ARouter.logger.info(Consts.TAG, \"ARouter init start.\");\n            hasInit = _ARouter.init(application);\n\n            if (hasInit) {\n                _ARouter.afterInit();\n            }\n\n            _ARouter.logger.info(Consts.TAG, \"ARouter init over.\");\n        }\n    }\n\n```\n\n由上面代码可以看出，其初始化实际上是调用了`_ARouter` 的 `init ()`方法，而且其他的跳转方法最终调用的也是`_ARouter` 种的方法。\n\n*   `_ARouter`的`init()`方法\n\n```\n  protected static synchronized boolean init(Application application) {\n        mContext = application;\n        LogisticsCenter.init(mContext, executor);\n        logger.info(Consts.TAG, \"ARouter init success!\");\n        hasInit = true;\n\n        return true;\n    }\n\n```\n\n`_ARouter`中又调用了`LogisticsCenter.init()`，继续追踪下去，其中传入了一个线程池`executor`，这个线程池在拦截器的时候会使用到。\n\n```\n    public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n        mContext = context;\n        executor = tpe;\n\n        try {\n             //ROUTE_ROOT_PAKCAGE = \"com.alibaba.android.arouter.routes\"\n            // 获取ROUTE_ROOT_PAKCAGE 包里面的所有文件\n            List<String> classFileNames = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n\n            //遍历所有ROUTE_ROOT_PAKCAGE 包里的文件\n            for (String className : classFileNames) {\n                //文件名以“com.alibaba.android.arouter.routes.ARouter$$Root”开头执行下面代码\n                if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                    // 通过反射实例化，并且调用loadInto()，目的即是将编译生成的ARouter$$Group$$xxx文件加载到内存中，保存在Warehouse.groupsIndex；\n                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n                    //文件名以“com.alibaba.android.arouter.routes.ARouter$$Interceptors”开头执行下面代码\n                    //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()，将自定义拦截器类存放在Warehouse.interceptorsIndex中\n                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n                     //文件名以“com.alibaba.android.arouter.routes.ARouter$$Providers”开头执行下面代码\n                   //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()\n                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n                }\n            }\n\n            if (Warehouse.groupsIndex.size() == 0) {\n                logger.error(TAG, \"No mapping files were found, check your configuration please!\");\n            }\n\n            if (ARouter.debuggable()) {\n                logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));\n            }\n        } catch (Exception e) {\n            throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n        }\n    }\n\n```\n\n*   `_ARouter`的`afterInit()`方法\n\n```\nstatic void afterInit() {\n        // 通过路由机制，初始化路由拦截机制。关于路由拦截机制的使用和原理，后续文章会有分析\n        interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation();\n    }\n\n```\n\n以上就是ARouter初始化的所有代码，关于如何查找到`com.alibaba.android.arouter.routes`包内所有文件这里便不做过多分析，大家可以去阅读 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)中`ClassUtils`这个类的源码。\n**总结下来，其实ARouter 的初始化只做了一件事，找到自己编译期产生的清单文件，把 Group 、Interceptor 、Provider 三种清单加载到 Warehouse 内存仓库中。**即下面这些文件，来源自AROUTER源码中的样例\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n\n值得注意的是，在初始化阶段，ARouter 仅载入了 Group 清单，并没有具体载入每个 Group 中包含的具体的路由节点清单，只有当使用到具体的 Group 时，才会加载对应的 Group 列表。这种分组管理，按需加载，大大的降低了初始化时的内存压力。并且`Warehouse`类中保存了路由清单，并且将使用过的路由对象缓存起来，之后查找都是直接使用缓存的对象 。\n\n###### 3.ARouter调用过程分析\n\n页面跳转最基本方法\n\n> ARouter.getInstance().build(\"/test/activity2\").navigation();\n\n获取Provider服务（实现了IProvider接口以及IProvider子类接口的服务类）的方法有两种：\n\n> 1.byName方式\n> ARouter.getInstance().build(\"/service/hello\").navigation()\n\n> 2.byType方式\n> ARouter.getInstance().navigation(HelloService.class)\n\nARouter路由跳转采用链式调用，`ARouter.getInstance()`其中采用的单例模式，获取ARouter的实例，这个就不作过多分析，主要分析`build()`和`navigation()`。\n\n**build()方法**\nARouter的`build(String path)`和`init()`方法一样，调用的是`_ARouter`的`build(String path)`方法。\n\n```\n  protected Postcard build(String path) {\n        if (TextUtils.isEmpty(path)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return build(path, extractGroup(path));\n        }\n    }\n\n```\n\n其中`extractGroup(String path)`就是根据path获取分组名，即path第一段“/”符号之间的值\n\n```\n  private String extractGroup(String path) {\n        if (TextUtils.isEmpty(path) || !path.startsWith(\"/\")) {\n            throw new HandlerException(Consts.TAG + \"Extract the default group failed, the path must be start with '/' and contain more than 2 '/'!\");\n        }\n\n        try {\n            //    /xxx1/xxx2   ===>  defaulGroup = xxx1\n            String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n            if (TextUtils.isEmpty(defaultGroup)) {\n                throw new HandlerException(Consts.TAG + \"Extract the default group failed! There's nothing between 2 '/'!\");\n            } else {\n                return defaultGroup;\n            }\n        } catch (Exception e) {\n            logger.warning(Consts.TAG, \"Failed to extract default group! \" + e.getMessage());\n            return null;\n        }\n    }\n\n```\n\n`build(String path)`方法最终调用的是`build(String path, String group)`\n\n```\n    protected Postcard build(String path, String group) {\n        if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return new Postcard(path, group);\n        }\n    }\n\n```\n\n**值得注意的是其中`ARouter.getInstance().navigation(PathReplaceService.class)`就是得到实现`PathReplaceService`接口的一个服务对象，对原始path进行处理后，生成新的path路径。而这个类需要我们自己自定义去实现，如果没有实现，pService=null，原始path不做任何处理。**\n下面是`PathReplaceService`接口，我们可以通过实现`forString()`和`forUri()`方法，对某些url进行替换处理，跳转到其他的目标页面。\n\n```\npublic interface PathReplaceService extends IProvider {\n\n    /**\n     * For normal path.\n     *\n     * @param path raw path\n     */\n    String forString(String path);\n\n    /**\n     * For uri type.\n     *\n     * @param uri raw uri\n     */\n    Uri forUri(Uri uri);\n}\n\n```\n\n最后返回一个`Postcard`实例对象，里面封装了路由节点的路径，分组等节点信息。其实`build()`方法的目的只有一个就是根据路由，封装成`Postcard`对象，其对象贯穿之后整个路由过程。Postcard 包含了众多的属性值，提供了路由过程中所有的控制变量。\n\n```\npublic final class Postcard extends RouteMeta {\n    private Uri uri;\n    private Object tag;             // A tag prepare for some thing wrong.\n    private Bundle mBundle;         // 传递的参数\n    private int flags = -1;         // intent 的flag标志\n    private int timeout = 300;      // Navigation timeout, TimeUnit.Second !\n    private IProvider provider;     // IProvider服务对象\n    private boolean greenChannal;\n    private SerializationService serializationService;//序列化服务对象\n\n     // 跳转动画\n    private Bundle optionsCompat;    // The transition animation of activity\n    private int enterAnim;\n    private int exitAnim;\n\n    // copy from RouteMeta \n    private RouteType type;         // 路由节点类型\n    private Element rawType;        \n    private Class<?> destination;  //需要跳转到的页面\n    private String path;            // 路径\n    private String group;           // 分组\n    private int priority = -1;      // 优先级\n    private int extra;              // 配置标识\n    private Map<String, Integer> paramsType;  // 路由页面被@Autowired注解属性\n    // ......\n}\n\n```\n\n**navigation()方法**\n关于页面跳转的`navigation()`方法有多个重载的方法，但最终都会调用`_ARouter`下面这个方法\n\n```\n    protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        try {\n            //首先对postcard进行一些处理，设置postcard的destination，type，priority 等一些属性值，completion()后面会有分析\n            LogisticsCenter.completion(postcard);\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n\n            if (debuggable()) { // Show friendly tips for user.\n                Toast.makeText(mContext, \"There's no route matched!\\n\" +\n                        \" Path = [\" + postcard.getPath() + \"]\\n\" +\n                        \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show();\n            }\n            // 如果处理postcard失败，通过 callback 回调失败结果\n           // callback为空的情况下，如果有定义全局的降级处理（DegradeService），则使用全局处理\n           //降级处理也需要我们自己实现DegradeService接口\n            if (null != callback) {\n                callback.onLost(postcard);\n            } else {    // No callback for this invoke, then we use the global degrade service.\n                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);\n                if (null != degradeService) {\n                    degradeService.onLost(context, postcard);\n                }\n            }\n\n            return null;\n        }\n         //路由处理成功，回调callback.onFound()\n        if (null != callback) {\n            callback.onFound(postcard);\n        }\n\n        //目前来说，PROVIDER服务类型，以及FRAGMENT类型不需要通过拦截器外，其他类型均需要通过拦截器\n        //关于拦截器相关用法及原理分析在后续的文章中会讲解到，大家去可以关注下\n        if (!postcard.isGreenChannel()) {   \n            interceptorService.doInterceptions(postcard, new InterceptorCallback() {\n                /**\n                 * Continue process\n                 *\n                 * @param postcard route meta\n                 */\n                @Override\n                public void onContinue(Postcard postcard) {\n                    _navigation(context, postcard, requestCode, callback);\n                }\n\n                /**\n                 * Interrupt process, pipeline will be destory when this method called.\n                 *\n                 * @param exception Reson of interrupt.\n                 */\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    if (null != callback) {\n                        callback.onInterrupt(postcard);\n                    }\n\n                    logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage());\n                }\n            });\n        } else {\n            return _navigation(context, postcard, requestCode, callback);\n        }\n\n        return null;\n    }\n\n```\n\n**值得注意的是，当跳转路由处理失败的时候，会获取一个降级服务，我们可以实现`DegradeService`接口，实现`onLost()`方法，对路由处理失败的情况进行处理，比如跳转到一个信息提示页面，让用户去更新版本等操作等。** 下面是`DegradeService`接口：\n\n```\npublic interface DegradeService extends IProvider {\n\n    /**\n     * Router has lost.\n     *\n     * @param postcard meta\n     */\n    void onLost(Context context, Postcard postcard);\n}\n\n```\n\n通过上面代码的分析，不管是否通过拦截器进行处理，最后都会调用`_navigation()`达到路由的目的：\n\n```\nprivate Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                //下面就是最基本的使用intent进行activity进行跳转\n                // 创建intent\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                //设置传参\n                intent.putExtras(postcard.getExtras());\n\n                //activity启动标志\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n\n                // 在主线程中进行跳转\n                new Handler(Looper.getMainLooper()).post(new Runnable() {\n                    @Override\n                    public void run() {\n                        //新版本带转场动画的启动方式\n                        if (requestCode > 0) {  // Need start for result\n                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());\n                        } else {\n                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());\n                        }\n\n                        if ((0 != postcard.getEnterAnim() || 0 != postcard.getExitAnim()) && currentContext instanceof Activity) {    // Old version.\n                            //老版本的跳转动画\n                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());\n                        }\n                        //跳转成功，回调callback.onArrival()\n                        if (null != callback) { // Navigation over.\n                            callback.onArrival(postcard);\n                        }\n                    }\n                });\n\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                     //实例化fragment，并传递参数\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n\n```\n\n目前仅ARouter实现了 ACTIVITY ， PROVIDER ，FRAGMENT三种种类型。上面关于postcard的provider，destination的值都是在`completion()`中设置的。我们接着看`LogisticsCenter`的`completion(Postcard postcard)`。\n\n```\n    public synchronized static void completion(Postcard postcard) {\n        if (null == postcard) {\n            throw new NoRouteFoundException(TAG + \"No postcard!\");\n        }\n\n        // 查找Warehouse仓库的路由节点缓存，看是否已在缓存中\n        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n        if (null == routeMeta) {   \n          // 如果没有，查找仓库的组别清单中是否存在该组别，组别清单已经在初始化的时候加载到仓库中去了\n            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  \n            //如果没有抛出异常\n            if (null == groupMeta) {\n                throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n            } else {\n                // Load route and cache it into memory, then delete from metas.\n                try {\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                    // 实例化个组别的类，调用loadInto()，将组别中所有的路由节点加载进仓库Warehouse.routes，缓存\n                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n                    iGroupInstance.loadInto(Warehouse.routes);\n                     // 从组别清单中删除已加载的组别，防止重复加载\n                    Warehouse.groupsIndex.remove(postcard.getGroup());\n\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                } catch (Exception e) {\n                    throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\");\n                }\n                //当路由节点加载到缓存中去后，重新查找执行else代码，对postcard进行处理\n                completion(postcard);   // Reload\n            }\n        } else {\n            //给postcard设置destination,type,priority等值，供上面讲解到的_navigation()进行使用\n            // 其中routeMeta是在ARouter$$Group$$xxx的loadInto中创建的\n            postcard.setDestination(routeMeta.getDestination());\n            postcard.setType(routeMeta.getType());\n            postcard.setPriority(routeMeta.getPriority());\n            postcard.setExtra(routeMeta.getExtra());\n\n            //如果通过build(Uri url) 进行跳转的话 通过解析url ，将传参保存进bundle中\n            Uri rawUri = postcard.getUri();\n            if (null != rawUri) {  \n                //splitQueryParameters()就是在uri中携带的参数进行解析\n                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);\n                Map<String, Integer> paramsType = routeMeta.getParamsType();\n\n                if (MapUtils.isNotEmpty(paramsType)) {\n                    // Set value by its type, just for params which annotation by @Param\n                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {\n                        setValue(postcard,\n                                params.getValue(),\n                                params.getKey(),\n                                resultMap.get(params.getKey()));\n                    }\n\n                    // Save params name which need autoinject.\n                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));\n                }\n\n                // Save raw uri\n                postcard.withString(ARouter.RAW_URI, rawUri.toString());\n            }\n\n            //从这里也可以看出PROVIDER，FRAGMENT不需要通过拦截器\n            switch (routeMeta.getType()) {\n                case PROVIDER:  \n                    // 如果是PROVIDER节点类型，从服务节点列表中获取，如果没有，则实例化，并保存在服务节点列表Warehouse.providers中\n                  //并将实例化的对象设置给postcard的provider属性\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    if (null == instance) { // There's no instance of this provider\n                        IProvider provider;\n                        try {\n                            provider = providerMeta.getConstructor().newInstance();\n                            provider.init(mContext);\n                            Warehouse.providers.put(providerMeta, provider);\n                            instance = provider;\n                        } catch (Exception e) {\n                            throw new HandlerException(\"Init provider failed! \" + e.getMessage());\n                        }\n                    }\n                    postcard.setProvider(instance);\n                    postcard.greenChannel();    // Provider should skip all of interceptors\n                    break;\n                case FRAGMENT:\n                    postcard.greenChannel();    // Fragment needn't interceptors\n                default:\n                    break;\n            }\n        }\n    }\n\n```\n\n分析到这里，关于页面基本跳转的原理分析就已经结束了。最后就是关于获取Provider服务两种方法的源码分析。其中byName方式，和页面跳转是一模一样的。我们只需要看看byType方式即可。byType方式最后调用的是`_ARouter`的`navigation(Class<? extends T> service)`\n\n```\n  protected <T> T navigation(Class<? extends T> service) {\n        try {\n            // 通过 className 获取 Postcard 对象\n            Postcard postcard = LogisticsCenter.buildProvider(service.getName());\n\n            // 兼容1.0.5 compiler sdk版本.\n            if (null == postcard) { // No service, or this service in old version.\n                postcard = LogisticsCenter.buildProvider(service.getSimpleName());\n            }\n           // 对 Postcard 对象进行处理\n            LogisticsCenter.completion(postcard);\n             //返回 Postcard 中的 provider 属性值\n            return (T) postcard.getProvider();\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n            return null;\n        }\n    }\n\n```\n\n上面代码中的`completion()`方法之前已经分析过了，只需要看下`LogisticsCenter.buildProvider(service.getName())`即可。\n\n```\n  public static Postcard buildProvider(String serviceName) {\n        RouteMeta meta = Warehouse.providersIndex.get(serviceName);\n\n        if (null == meta) {\n            return null;\n        } else {\n            return new Postcard(meta.getPath(), meta.getGroup());\n        }\n    }\n\n```\n\n这个方法非常的简单，就是根据服务类名去仓库Warehouse.providersIndex中获去路由节点元素，然后封装在Postcard对象中。服务类清单列表Warehouse.providersIndex中的值是在初始化时缓存的。**值得注意的是，PROVIDER 类型的路由节点既存在于对应的分组中，也存在于服务类清单列表中。所以，ARouter 可通过byType，byName两种方式来获取**。\n\n##### 补充\n\n关于ARouter的基本用法上面只有最基本跳转的介绍，下面对其他一些基本使用进行下补充\n\n*   **带参数跳转**\n\n```\n//1.传递参数\n ARouter.getInstance().build(\"/test/activity1\")\n                        .withString(\"name\", \"老王\")\n                        .withInt(\"age\", 18)\n                        .withBoolean(\"boy\", true)\n                        .withLong(\"high\", 180)\n                        .withString(\"url\", \"https://a.b.c\")\n                        .withParcelable(\"pac\", testParcelable)\n                        .withObject(\"obj\", testObj)\n                        .navigation();\n\n//2.直接传递Bundle\n  Bundle params = new Bundle();\n  ARouter.getInstance()\n          .build(\"/test/activity1\")\n          .with(params)\n          .navigation();\n\n```\n\n这些传参都是保存在生成的`postcard`对象中的`mBundle`属性里，然后在跳转的时候通过`intent.putExtras(postcard.getExtras())`达到传送参数的目的。\n值得注意的是，关于对象的传递有两种，一种是`withParcelable()`方法，不过此方法需要传递的对象实现`Parcelable`接口，达到序列化的目的；另外一种是`withObject()`方法，此方法的原理是将实体类转换成json字符串，通过String的方式进行传递，而且使用这种方式需要实现 SerializationService，并使用@Route注解标注，下面是ARouter样例：\n\n```\n@Route(path = \"/service/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n\n```\n\n而且，需要在跳转到的页面获取`JsonServiceImpl`服务，将json字符串转换成对象。\n\n```\nSerializationService serializationService = ARouter.getInstance().navigation(SerializationService.class);\nTestObj obj = serializationService.json2Object(getIntent().getString(\"obj\"), TestObj.class);\n\n```\n\n*   **带返回结果跳转**\n\n```\nARouter.getInstance().build(\"/test/activity2\").navigation(this, 666);\n\n```\n\n值得注意的是，这时候的 `navigation`需要传递activit和requestCode。\n\n*   **获取Fragment的实例**\n\n定义一个fragment\n\n```\n@Route(path = \"/test/fragment\")\npublic class BlankFragment extends Fragment {\n    public BlankFragment() {\n        //必须要一个空的构造器\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        TextView textView = new TextView(getActivity());\n        return textView;\n    }\n\n}\n\n```\n\n获取frament\n\n```\nFragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation();\n\n```\n\n*   **带转场动画跳转**\n\n```\n// 转场动画(常规方式)\n ARouter.getInstance() .build(\"/test/activity2\")\n                      .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)\n                      .navigation(this);\n\n// 转场动画(API16+)\n ActivityOptionsCompat compat = ActivityOptionsCompat.makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);\nARouter.getInstance().build(\"/test/activity2\").withOptionsCompat(compat) .navigation();\n\n```\n\n*   **获取服务**\n\n服务是全局单例的，只有在第一次使用到的时候才会被初始化。\n暴露服务，必须实现IProvider 接口 或者其子类型\n\n```\n// 声明接口,其他组件通过接口来调用服务\npublic interface HelloService extends IProvider {\n    String sayHello(String name);\n}\n\n// 实现接口\n@Route(path = \"/service/hello\", name = \"测试服务\")\npublic class HelloServiceImpl implements HelloService {\n\n    @Override\n    public String sayHello(String name) {\n    return \"hello, \" + name;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n}\n\n```\n\n获取服务\n\n```\n//bytype\nHelloService helloService1 = ARouter.getInstance().navigation(HelloService.class);\n//byname\nHelloService helloService2 = (HelloService) ARouter.getInstance().build(\"/service/hello\").navigation();\n\n```\n\n*   **多模块结构**\n\n"],[1,388,"\n\n**如果各位同学认为本文对你有一些帮助，希望能点个喜欢，谢谢！**\n\n小礼物走一走，来简书关注我\n\n赞赏支持\n\n[android开发问题](/nb/12473806)\n\n© 著作权归作者所有\n\n举报文章\n\n[![96](//upload.jianshu.io/users/upload_avatars/5994347/dd34592b-ad62-4e24-bb66-f7c689766b2f.png?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96) ](/u/d65e2e163603) 关注 [time_fly](/u/d65e2e163603)\n\n写了 24037 字，被 37 人关注，获得了 92 个喜欢\n\n喜欢\n\n12\n\n[](javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f='http://v.t.sina.com.cn/share/share.php?appkey=1881139527',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function%20a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,'','','', '推荐 @龍儱滝 的文章《阿里ARouter使用及源码解析（一）》（ 分享自 @简书 ）','https://www.jianshu.com/p/46d174f37e82?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo','页面编码gb2312|utf-8默认gb2312'));)[](http://cwb.assets.jianshu.io/notes/images/13526520/weibo/image_bcbd18a5f866.png)[更多分享](javascript:void(0);)\n\n![](//upload.jianshu.io/users/upload_avatars/1786025/f63ccf82f6f8?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114) \n\n3条评论 只看作者 关闭评论\n\n按喜欢排序按时间正序按时间倒序\n\n[![](//cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/ab7bfd384c72)\n\n[winter818](/u/ab7bfd384c72)\n\n2楼 · 2017.08.23 17:56\n\n666 学习了\n\n1人赞 回复 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/426662/e85a4080db83?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/a2a56d463e3d)\n\n[夏鸣浩](/u/a2a56d463e3d)\n\n3楼 · 2017.09.04 17:40\n\n正在拜读，博主辛苦\n\n赞 回复 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/7293029/42130be5-9eb3-4cf2-8874-1f32e70d81e2?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/df76f81fe3ff)\n\n[却把清梅嗅2](/u/df76f81fe3ff)\n\n4楼 · 2017.12.13 16:23\n\n好文，楼主辛苦\n\n赞 回复 举报"]],[0,484],[54215,54215]]],[1519699551344,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,92,"\r"],[1,93,"\r"],[-1,94,"*   "],[1,134,"\r"],[-1,135,"*   "],[1,174,"\r"],[-1,175,"*   "],[1,219,"\r"],[-1,220,"*   "],[1,275,"\r"],[-1,276,"*   "],[-1,306,"\n"],[1,307,"\r"],[-1,312,"["],[-1,320,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)"],[-1,482,"["],[-1,512,"](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)"],[1,584,"\r"],[1,585,"\r"],[1,600,"\r"],[1,601,"\r"],[-1,602,"*   ["],[-1,626,"](https://www.jianshu.com/p/46d174f37e82)\n*   ["],[1,673,"\r\n"],[-1,695,"](https://www.jianshu.com/p/c8d7b1379c1b)\n*   "],[1,741,"\r\n"],[-1,766,"\n\n##### "],[1,774,"\r\n"],[-1,780,"\n"],[1,781,"\r"],[-1,791,"\n\n```"],[1,796,"\r\n\r"],[1,806,"\r"],[1,826,"\r"],[1,834,"\r"],[1,859,"\r"],[1,896,"\r"],[1,951,"\r"],[1,961,"\r"],[1,967,"\r"],[1,973,"\r"],[1,975,"\r"],[1,976,"\r"],[1,991,"\r"],[1,1037,"\r"],[1,1100,"\r"],[1,1108,"\r"],[-1,1110,"\n\n```\n"],[1,1116,"\r"],[-1,1123,"\n\n```"],[1,1128,"\r\n\r"],[1,1149,"\r"],[1,1178,"\r"],[1,1207,"\r"],[1,1261,"\r"],[1,1262,"\r"],[1,1276,"\r"],[1,1343,"\r"],[1,1387,"\r"],[1,1436,"\r"],[1,1442,"\r"],[-1,1444,"\n\n```\n"],[1,1450,"\r"],[-1,1459,"\n\n```"],[1,1464,"\r\n\r"],[1,1550,"\r"],[1,1580,"\r"],[1,1594,"\r"],[1,1651,"\r"],[1,1695,"\r"],[1,1743,"\r"],[1,1792,"\r"],[1,1841,"\r"],[1,1842,"\r"],[1,1881,"\r"],[1,1920,"\r"],[1,1926,"\r"],[1,1927,"\r"],[1,1941,"\r"],[1,1975,"\r"],[1,2013,"\r"],[1,2088,"\r"],[1,2144,"\r"],[1,2177,"\r"],[1,2248,"\r"],[1,2258,"\r"],[1,2264,"\r"],[-1,2266,"\n\n```\n"],[1,2272,"\r"],[-1,2281,"\n\n```"],[1,2286,"\r\n\r"],[1,2372,"\r"],[1,2402,"\r"],[1,2416,"\r"],[1,2473,"\r"],[1,2517,"\r"],[1,2565,"\r"],[1,2614,"\r"],[1,2663,"\r"],[1,2664,"\r"],[1,2703,"\r"],[1,2742,"\r"],[1,2748,"\r"],[1,2749,"\r"],[1,2763,"\r"],[1,2797,"\r"],[1,2835,"\r"],[1,2852,"\r"],[1,2896,"\r"],[1,2965,"\r"],[1,2975,"\r"],[1,2981,"\r"],[-1,2983,"\n\n```\n"],[1,2989,"\r"],[1,3033,"\r"],[1,3034,"\r"],[-1,3035,"##### "],[-1,3045,"\n\n###### "],[1,3054,"\r\n"],[-1,3068,"\n"],[1,3069,"\r"],[-1,3111,"["],[-1,3130,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)"],[-1,3235,"["],[-1,3252,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n"],[1,3346,"\r\n\r"],[-1,3352,"`"],[-1,3359,"`"],[-1,3366,"\n\n```"],[1,3371,"\r\n\r"],[1,3399,"\r"],[1,3433,"\r"],[1,3459,"\r"],[1,3460,"\r"],[1,3468,"\r"],[1,3489,"\r"],[1,3497,"\r"],[1,3516,"\r"],[1,3517,"\r"],[1,3525,"\r"],[1,3553,"\r"],[1,3561,"\r"],[1,3592,"\r"],[1,3593,"\r"],[1,3601,"\r"],[1,3630,"\r"],[1,3638,"\r"],[1,3677,"\r"],[1,3678,"\r"],[1,3686,"\r"],[1,3716,"\r"],[1,3724,"\r"],[1,3768,"\r"],[1,3769,"\r"],[1,3777,"\r"],[1,3791,"\r"],[1,3799,"\r"],[1,3830,"\r"],[-1,3832,"\n\n```\n"],[1,3838,"\r"],[-1,3846,"`"],[-1,3852,"`"],[-1,4007,"`"],[-1,4013,"`"],[1,4039,"\r"],[-1,4066,"`"],[-1,4075,"`"],[-1,4091,"`"],[-1,4098,"`"],[1,4129,"\r"],[1,4130,"\r"],[-1,4160,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n"],[1,4287,"\r\n\r\n\r"],[-1,4303,"`"],[-1,4318,"`"],[-1,4340,"["],[-1,4377,"](https://www.jianshu.com/p/07ef8ba80562)"],[-1,4426,"**"],[-1,4436,"**"],[-1,4449,"`"],[-1,4464,"`"],[-1,4476,"\n\n```"],[1,4481,"\r\n\r"],[1,4495,"\r"],[1,4591,"\r"],[1,4617,"\r"],[1,4672,"\r"],[1,4724,"\r"],[1,4823,"\r"],[1,4841,"\r"],[1,4904,"\r"],[1,4941,"\r"],[1,4990,"\r"],[1,4991,"\r"],[1,5027,"\r"],[1,5060,"\r"],[1,5074,"\r"],[1,5099,"\r"],[1,5109,"\r"],[1,5110,"\r"],[1,5132,"\r"],[-1,5138,"\n\n```\n\n`"],[1,5146,"\r\n"],[-1,5155,"`"],[-1,5168,"`"],[-1,5175,"`"],[-1,5210,"`"],[-1,5225,"`"],[-1,5230,"`"],[-1,5244,"`"],[-1,5253,"`"],[-1,5260,"`"],[1,5300,"\r"],[1,5301,"\r"],[-1,5302,"*   "],[-1,5325,"\n\n```"],[1,5330,"\r"],[1,5386,"\r"],[1,5398,"\r"],[1,5473,"\r"],[1,5525,"\r"],[1,5529,"\r"],[-1,5531,"\n\n```\n\n*   "],[1,5542,"\r\n"],[-1,5563,"\n\n```"],[1,5568,"\r"],[1,5627,"\r"],[1,5639,"\r"],[1,5694,"\r"],[1,5828,"\r"],[1,5832,"\r"],[-1,5834,"\n\n```\n\n*   "],[1,5845,"\r\n"],[-1,5869,"\n\n```"],[1,5874,"\r"],[1,5939,"\r"],[1,5951,"\r"],[1,6010,"\r"],[1,6014,"\r"],[-1,6016,"\n\n```\n"],[1,6022,"\r"],[1,6041,"\r"],[1,6042,"\r"],[-1,6064,"\n\n```"],[1,6069,"\r\n\r"],[1,6154,"\r"],[1,6211,"\r"],[1,6212,"          \r"],[1,6299,"\r"],[1,6300,"\r"],[1,6329,"\r"],[1,6368,"\r"],[1,6445,"\r"],[1,6473,"\r"],[1,6551,"\r"],[1,6626,"\r"],[1,6654,"\r"],[1,6730,"\r"],[1,6806,"\r"],[1,6886,"\r"],[1,6974,"\r"],[1,7066,"\r"],[1,7067,"\r"],[1,7183,"\r"],[1,7215,"\r"],[1,7300,"\r"],[1,7417,"\r"],[1,7452,"\r"],[1,7543,"\r"],[1,7581,"\r"],[1,7649,"\r"],[1,7717,"\r"],[1,7718,"\r"],[1,7764,"\r"],[1,7779,"\r"],[1,7869,"\r"],[1,7885,"\r"],[1,7967,"\r"],[1,8013,"\r"],[1,8062,"\r"],[1,8109,"\r"],[1,8165,"\r"],[1,8253,"\r"],[1,8275,"\r"],[1,8290,"\r"],[1,8291,"\r"],[1,8306,"\r"],[1,8401,"\r"],[1,8417,"\r"],[1,8500,"\r"],[1,8546,"\r"],[1,8595,"\r"],[1,8646,"\r"],[1,8661,"\r"],[1,8662,"\r"],[1,8677,"\r"],[1,8698,"\r"],[1,8714,"\r"],[1,8805,"\r"],[1,8908,"\r"],[1,8979,"\r"],[1,9083,"\r"],[1,9163,"\r"],[1,9276,"\r"],[1,9277,"\r\n          \r"],[1,9293,"\r"],[1,9303,"\r"],[-1,9309,"\n\n```\n"],[1,9315,"\r"],[-1,9347,"\n\n```"],[1,9352,"\r\n\r"],[1,9437,"\r"],[1,9494,"\r"],[1,9515,"\r"],[1,9516,"\r"],[1,9531,"\r"],[1,9584,"\r"],[1,9608,"\r"],[1,9696,"\r"],[1,9712,"\r"],[1,9816,"\r"],[1,9867,"\r"],[1,9909,"\r"],[1,9959,"\r"],[1,9960,"\r"],[1,9993,"\r"],[1,10045,"\r"],[1,10095,"\r"],[1,10161,"\r"],[1,10205,"\r"],[1,10206,"                \r"],[1,10286,"\r"],[1,10384,"\r"],[1,10472,"\r"],[1,10473,"\r"],[1,10529,"\r"],[1,10577,"\r"],[1,10648,"\r"],[1,10722,"\r"],[1,10877,"\r"],[1,10974,"\r"],[1,11064,"\r"],[1,11245,"\r"],[1,11271,"\r"],[1,11293,"\r"],[1,11329,"\r"],[1,11424,"\r"],[1,11509,"\r"],[1,11597,"\r"],[1,11656,"\r"],[1,11743,"\r"],[1,11832,"\r"],[1,11929,"\r"],[1,12016,"\r"],[1,12051,"\r"],[1,12146,"\r"],[1,12245,"\r"],[1,12333,"\r"],[1,12367,"\r"],[1,12463,"\r"],[1,12481,"\r"],[1,12482,"                \r"],[1,12572,"\r"],[1,12606,"\r"],[1,12645,"\r"],[1,12646,"          \r"],[1,12660,"\r"],[1,12661,"\r"],[1,12683,"\r"],[1,12693,"\r"],[-1,12699,"\n\n```\n"],[1,12705,"\r"],[-1,12793,"`"],[-1,12803,"`"],[-1,12810,"`"],[-1,12832,"`"],[-1,12844,"`"],[-1,12853,"`"],[1,12857,"\r"],[1,12858,"\r"],[-1,12865,"\n\n```"],[1,12870,"\r\n\r"],[1,12955,"\r"],[1,13012,"\r"],[1,13033,"\r"],[1,13034,"\r"],[1,13050,"\r"],[1,13108,"\r"],[1,13131,"\r"],[1,13202,"\r"],[1,13218,"\r"],[1,13326,"\r"],[1,13377,"\r"],[1,13419,"\r"],[1,13473,"\r"],[1,13474,"\r"],[1,13508,"\r"],[1,13571,"\r"],[1,13653,"\r"],[1,13704,"\r"],[1,13722,"\r"],[1,13778,"\r"],[1,13805,"\r"],[1,13876,"\r"],[1,13892,"\r"],[1,14001,"\r"],[1,14056,"\r"],[1,14102,"\r"],[1,14157,"\r"],[1,14158,"\r"],[1,14193,"\r"],[1,14254,"\r"],[1,14285,"\r"],[1,14341,"\r"],[1,14392,"\r"],[1,14435,"\r"],[1,14476,"\r"],[1,14518,"\r"],[1,14642,"\r"],[1,14705,"\r"],[1,14822,"\r"],[1,14928,"\r"],[1,15008,"\r"],[1,15090,"\r"],[1,15284,"\r"],[1,15376,"\r"],[1,15433,"\r"],[1,15490,"\r"],[1,15587,"\r"],[1,15652,"\r"],[1,15719,"\r"],[1,15796,"\r"],[1,15907,"\r"],[1,15989,"\r"],[1,16183,"\r"],[1,16262,"\r"],[1,16319,"\r"],[1,16376,"\r"],[1,16473,"\r"],[1,16538,"\r"],[1,16605,"\r"],[1,16639,"\r"],[1,16680,"\r"],[1,16852,"\r"],[1,16882,"\r"],[1,16917,"\r"],[1,16950,"\r"],[1,16985,"\r"],[1,17007,"\r"],[1,17008,"\r"],[1,17062,"\r"],[1,17134,"\r"],[1,17182,"\r"],[1,17263,"\r"],[1,17322,"\r"],[1,17411,"\r"],[1,17549,"\r"],[1,17575,"\r"],[1,17597,"\r"],[1,17661,"\r"],[1,17662,"                    \r"],[1,17724,"\r"],[1,17764,"\r"],[1,17827,"\r"],[1,18126,"\r"],[1,18175,"\r"],[1,18216,"\r"],[1,18257,"\r"],[1,18338,"\r"],[1,18401,"\r"],[1,18466,"\r"],[1,18484,"\r"],[1,18485,"\r"],[1,18538,"\r"],[1,18590,"\r"],[1,18671,"\r"],[1,18737,"\r"],[1,18796,"\r"],[1,18857,"\r"],[1,18915,"\r"],[1,18999,"\r"],[1,19053,"\r"],[1,19134,"\r"],[1,19175,"\r"],[1,19218,"\r"],[1,19219,"\r"],[1,19293,"\r"],[1,19361,"\r"],[1,19416,"\r"],[1,19430,"\r"],[1,19431,"\r"],[1,19448,"\r"],[1,19458,"\r"],[-1,19464,"\n\n```\n"],[1,19470,"\r"],[1,19483,"\r"],[1,19484,"\r"],[-1,19485,"*   "],[-1,19491,"`"],[-1,19500,"`"],[-1,19526,"`"],[-1,19537,"`"],[-1,19627,"`"],[-1,19635,"`"],[-1,19652,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n"],[1,19779,"\r"],[-1,19786,"\n"],[1,19787,"\r"],[-1,19793,"`"],[-1,19804,"`"],[-1,19817,"`"],[-1,19825,"`"],[-1,19833,"\n\n```"],[1,19838,"\r\n\r"],[1,19897,"\r"],[1,19909,"\r"],[1,19964,"\r"],[1,19993,"\r"],[1,20238,"\r"],[1,20248,"\r"],[1,20276,"\r"],[1,20418,"\r"],[1,20427,"\r"],[1,20431,"\r"],[-1,20433,"\n\n```\n\n*   "],[1,20444,"\r\n"],[-1,20509,"`"],[-1,20520,"`"],[-1,20568,"`"],[-1,20579,"`"],[-1,20606,"\n\n```"],[1,20611,"\r"],[1,20676,"\r"],[1,20688,"\r"],[1,20747,"\r"],[1,20940,"\r"],[1,20973,"\r"],[1,21170,"\r"],[1,21202,"\r"],[1,21394,"\r"],[1,21398,"\r"],[-1,21400,"\n\n```\n\n*   "],[1,21411,"\r\n"],[-1,21493,"\n"],[1,21494,"\r"],[-1,21501,"`"],[-1,21515,"`"],[-1,21561,"`"],[-1,21572,"`"],[-1,21626,"\n\n```"],[1,21631,"\r\n\r"],[1,21716,"\r"],[1,21773,"\r"],[1,21794,"\r"],[1,21858,"\r"],[1,21906,"\r"],[1,22032,"\r"],[1,22109,"\r"],[1,22274,"\r"],[1,22292,"\r"],[1,22306,"\r"],[1,22307,"\r"],[1,22349,"\r"],[1,22433,"\r"],[1,22488,"\r"],[1,22551,"\r"],[1,22605,"\r"],[1,22688,"\r"],[1,22738,"\r"],[1,22818,"\r"],[1,22855,"\r"],[1,22894,"\r"],[1,22895,"\r"],[1,22991,"\r"],[1,22992,"\r"],[1,23030,"\r"],[1,23103,"\r"],[1,23158,"\r"],[1,23214,"\r"],[1,23268,"\r"],[1,23372,"\r"],[1,23422,"\r"],[1,23498,"\r"],[1,23535,"\r"],[1,23574,"\r"],[1,23575,"\r"],[1,23656,"\r"],[1,23666,"\r"],[-1,23672,"\n\n```\n"],[1,23678,"\r"],[-1,23684,"`"],[-1,23695,"`"],[-1,23722,"\n\n```"],[1,23727,"\r\n\r"],[1,23783,"\r"],[1,23795,"\r"],[1,23870,"\r"],[1,23928,"\r"],[1,23980,"\r"],[1,23984,"\r"],[-1,23986,"\n\n```\n\n**"],[1,23995,"\r\n"],[-1,24002,"`"],[-1,24016,"`"],[-1,24026,"**\n"],[1,24029,"\r\n\r"],[-1,24038,"`"],[-1,24051,"`"],[-1,24060,"\n\n```"],[1,24065,"\r\n\r"],[1,24115,"\r"],[1,24150,"\r"],[1,24188,"\r"],[1,24315,"\r"],[1,24397,"\r"],[1,24426,"\r"],[1,24502,"\r"],[1,24557,"\r"],[1,24647,"\r"],[1,24677,"\r"],[1,24746,"\r"],[1,24776,"\r"],[1,24849,"\r"],[1,24910,"\r"],[1,24970,"\r"],[1,25008,"\r"],[1,25034,"\r"],[1,25056,"\r"],[1,25076,"\r"],[1,25121,"\r"],[1,25187,"\r"],[1,25208,"\r"],[1,25251,"\r"],[1,25265,"\r"],[1,25282,"\r"],[1,25384,"\r"],[1,25394,"\r"],[1,25400,"\r"],[1,25401,"\r"],[1,25428,"\r"],[1,25475,"\r"],[1,25513,"\r"],[1,25549,"\r"],[1,25667,"\r"],[1,25693,"\r"],[1,25703,"\r"],[1,25704,"\r"],[1,25769,"\r"],[1,25866,"\r"],[1,25884,"\r"],[1,25963,"\r"],[1,26020,"\r"],[1,26054,"\r"],[1,26072,"\r"],[1,26073,"\r"],[1,26118,"\r"],[1,26147,"\r"],[1,26183,"\r"],[1,26267,"\r"],[1,26297,"\r"],[1,26311,"\r"],[1,26321,"\r"],[1,26322,"\r"],[1,26343,"\r"],[-1,26349,"\n\n```\n"],[1,26355,"\r"],[1,26448,"\r"],[1,26449,"\r"],[-1,26454,"`"],[-1,26461,"`"],[1,26546,"\r"],[1,26547,"\r"],[-1,26548,"###### "],[-1,26569,"\n"],[1,26570,"\r"],[-1,26660,"["],[-1,26672,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `"],[1,26767,"\r\n\r\n"],[-1,26774,"`"],[-1,26776,"`"],[-1,26783,"`"],[-1,26786,"\n\n```"],[1,26791,"\r"],[1,26842,"\r"],[1,26866,"\r"],[1,26904,"\r"],[1,26973,"\r"],[1,27023,"\r"],[1,27024,"\r"],[1,27051,"\r"],[1,27089,"\r"],[1,27103,"\r"],[1,27104,"\r"],[1,27172,"\r"],[1,27182,"\r"],[-1,27188,"\n\n```\n"],[1,27194,"\r"],[-1,27216,"`"],[-1,27225,"`"],[-1,27229,"`"],[-1,27237,"`"],[-1,27257,"`"],[-1,27266,"`"],[1,27273,"\r"],[1,27274,"\r"],[-1,27275,"*   `"],[-1,27288,"`"],[-1,27290,"`"],[-1,27297,"`"],[-1,27300,"\n\n```"],[1,27305,"\r"],[1,27377,"\r"],[1,27409,"\r"],[1,27459,"\r"],[1,27517,"\r"],[1,27541,"\r"],[1,27542,"\r"],[1,27563,"\r"],[-1,27569,"\n\n```\n\n`"],[1,27577,"\r\n"],[-1,27585,"`"],[-1,27591,"`"],[-1,27614,"`"],[-1,27633,"`"],[-1,27642,"`"],[-1,27661,"\n\n```"],[1,27666,"\r\n\r"],[1,27774,"\r"],[1,27802,"\r"],[1,27826,"\r"],[1,27827,"\r"],[1,27841,"\r"],[1,27914,"\r"],[1,27959,"\r"],[1,28068,"\r"],[1,28069,"\r"],[1,28112,"\r"],[1,28166,"\r"],[1,28247,"\r"],[1,28354,"\r"],[1,28464,"\r"],[1,28590,"\r"],[1,28712,"\r"],[1,28805,"\r"],[1,28914,"\r"],[1,29053,"\r"],[1,29172,"\r"],[1,29263,"\r"],[1,29331,"\r"],[1,29464,"\r"],[1,29482,"\r"],[1,29496,"\r"],[1,29497,"\r"],[1,29550,"\r"],[1,29650,"\r"],[1,29664,"\r"],[1,29665,"\r"],[1,29705,"\r"],[1,29975,"\r"],[1,29989,"\r"],[1,30021,"\r"],[1,30136,"\r"],[1,30146,"\r"],[-1,30152,"\n\n```\n\n*   `"],[1,30164,"\r\n"],[-1,30172,"`"],[-1,30174,"`"],[-1,30186,"`"],[-1,30189,"\n\n```"],[1,30194,"\r"],[1,30220,"\r"],[1,30272,"\r"],[1,30396,"\r"],[-1,30402,"\n\n```\n"],[1,30408,"\r"],[-1,30436,"`"],[-1,30471,"`"],[-1,30496,"["],[-1,30508,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)"],[-1,30597,"`"],[-1,30608,"`"],[1,30616,"\r"],[-1,30617,"**"],[-1,30715,"**"],[-1,30741,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n"],[1,30868,"\r\n\r\n\r"],[-1,31000,"`"],[-1,31010,"`"],[1,31054,"\r"],[1,31055,"\r"],[-1,31056,"###### "],[-1,31078,"\n"],[1,31079,"\r"],[1,31089,"\r"],[1,31090,"\r"],[-1,31091,"> "],[1,31153,"\r"],[1,31154,"\r"],[1,31209,"\r"],[1,31210,"\r"],[-1,31211,"> "],[1,31223,"\r"],[-1,31224,"> "],[1,31284,"\r"],[1,31285,"\r"],[-1,31286,"> "],[1,31298,"\r"],[-1,31299,"> "],[1,31353,"\r"],[1,31354,"\r"],[-1,31373,"`"],[-1,31395,"`"],[-1,31433,"`"],[-1,31441,"`"],[-1,31443,"`"],[-1,31456,"`"],[1,31458,"\r"],[1,31459,"\r"],[-1,31460,"**"],[-1,31471,"**"],[1,31473,"\r"],[-1,31482,"`"],[-1,31501,"`"],[-1,31503,"`"],[-1,31510,"`"],[-1,31520,"`"],[-1,31529,"`"],[-1,31531,"`"],[-1,31550,"`"],[-1,31554,"\n\n```"],[1,31559,"\r\n\r"],[1,31601,"\r"],[1,31640,"\r"],[1,31718,"\r"],[1,31735,"\r"],[1,31837,"\r"],[1,31873,"\r"],[1,31922,"\r"],[1,31936,"\r"],[1,31988,"\r"],[1,31998,"\r"],[-1,32004,"\n\n```\n"],[1,32010,"\r"],[-1,32013,"`"],[-1,32039,"`"],[-1,32071,"\n\n```"],[1,32076,"\r\n\r"],[1,32121,"\r"],[1,32185,"\r"],[1,32336,"\r"],[1,32346,"\r"],[1,32347,"\r"],[1,32361,"\r"],[1,32417,"\r"],[1,32492,"\r"],[1,32543,"\r"],[1,32668,"\r"],[1,32689,"\r"],[1,32726,"\r"],[1,32740,"\r"],[1,32772,"\r"],[1,32866,"\r"],[1,32891,"\r"],[1,32901,"\r"],[-1,32907,"\n\n```\n\n`"],[1,32915,"\r\n"],[-1,32933,"`"],[-1,32942,"`"],[-1,32975,"`\n\n```"],[1,32981,"\r\n\r"],[1,33039,"\r"],[1,33106,"\r"],[1,33184,"\r"],[1,33201,"\r"],[1,33303,"\r"],[1,33339,"\r"],[1,33388,"\r"],[1,33402,"\r"],[1,33448,"\r"],[1,33458,"\r"],[-1,33464,"\n\n```\n\n**"],[1,33473,"\r\n"],[-1,33481,"`"],[-1,33540,"`"],[-1,33547,"`"],[-1,33566,"`"],[-1,33652,"**"],[1,33654,"\r"],[-1,33658,"`"],[-1,33677,"`"],[-1,33689,"`"],[-1,33701,"`"],[-1,33703,"`"],[-1,33712,"`"],[-1,33740,"\n\n```"],[1,33745,"\r\n\r"],[1,33801,"\r"],[1,33802,"\r"],[1,33810,"\r"],[1,33834,"\r"],[1,33841,"\r"],[1,33869,"\r"],[1,33877,"\r"],[1,33912,"\r"],[1,33913,"\r"],[1,33921,"\r"],[1,33942,"\r"],[1,33949,"\r"],[1,33975,"\r"],[1,33983,"\r"],[1,34008,"\r"],[-1,34010,"\n\n```\n"],[1,34016,"\r\n\r"],[-1,34023,"`"],[-1,34032,"`"],[-1,34061,"`"],[-1,34069,"`"],[-1,34089,"`"],[-1,34098,"`"],[-1,34151,"\n\n```"],[1,34156,"\r\n\r"],[1,34204,"\r"],[1,34225,"\r"],[1,34300,"\r"],[1,34345,"\r"],[1,34399,"\r"],[1,34476,"\r"],[1,34529,"\r"],[1,34563,"\r"],[1,34627,"\r"],[1,34628,"\r"],[1,34641,"\r"],[1,34718,"\r"],[1,34745,"\r"],[1,34771,"\r"],[1,34772,"\r"],[1,34800,"\r"],[1,34846,"\r"],[1,34883,"\r"],[1,34929,"\r"],[1,34971,"\r"],[1,35013,"\r"],[1,35056,"\r"],[1,35100,"\r"],[1,35169,"\r"],[1,35183,"\r"],[-1,35185,"\n\n```\n\n**"],[1,35194,"\r\n"],[-1,35208,"**"],[1,35210,"\r"],[-1,35218,"`"],[-1,35231,"`"],[-1,35250,"`"],[-1,35259,"`"],[-1,35266,"\n\n```"],[1,35271,"\r\n\r"],[1,35411,"\r"],[1,35425,"\r"],[1,35520,"\r"],[1,35570,"\r"],[1,35615,"\r"],[1,35672,"\r"],[1,35673,"\r"],[1,35737,"\r"],[1,35810,"\r"],[1,35877,"\r"],[1,35970,"\r"],[1,35984,"\r"],[1,36033,"\r"],[1,36099,"\r"],[1,36142,"\r"],[1,36178,"\r"],[1,36221,"\r"],[1,36317,"\r"],[1,36421,"\r"],[1,36467,"\r"],[1,36529,"\r"],[1,36547,"\r"],[1,36561,"\r"],[1,36562,"\r"],[1,36587,"\r"],[1,36597,"\r"],[1,36636,"\r"],[1,36668,"\r"],[1,36708,"\r"],[1,36718,"\r"],[1,36719,"        \r"],[1,36782,"\r"],[1,36827,"\r"],[1,36872,"\r"],[1,36957,"\r"],[1,36977,"\r"],[1,37013,"\r"],[1,37032,"\r"],[1,37078,"\r"],[1,37098,"\r"],[1,37124,"\r"],[1,37184,"\r"],[1,37259,"\r"],[1,37277,"\r"],[1,37278,"\r"],[1,37298,"\r"],[1,37386,"\r"],[1,37405,"\r"],[1,37461,"\r"],[1,37481,"\r"],[1,37507,"\r"],[1,37570,"\r"],[1,37614,"\r"],[1,37670,"\r"],[1,37692,"\r"],[1,37693,"\r"],[1,37815,"\r"],[1,37833,"\r"],[1,37849,"\r"],[1,37866,"\r"],[1,37940,"\r"],[1,37950,"\r"],[1,37951,"\r"],[1,37972,"\r"],[1,37978,"\r"],[-1,37979,"\n```\n\n**"],[-1,38023,"`"],[-1,38038,"`"],[-1,38044,"`"],[-1,38053,"`"],[-1,38099,"**"],[-1,38105,"`"],[-1,38120,"`"],[-1,38124,"\n\n```"],[1,38129,"\r\n\r"],[1,38181,"\r"],[1,38182,"\r"],[1,38190,"\r"],[1,38214,"\r"],[1,38221,"\r"],[1,38249,"\r"],[1,38257,"\r"],[1,38310,"\r"],[-1,38312,"\n\n```\n"],[1,38318,"\r\n\r"],[-1,38349,"`"],[-1,38363,"`"],[-1,38372,"\n\n```"],[1,38377,"\r\n\r"],[1,38512,"\r"],[1,38589,"\r"],[1,38590,"\r"],[1,38628,"\r"],[1,38655,"\r"],[1,38704,"\r"],[1,38732,"\r"],[1,38825,"\r"],[1,38848,"\r"],[1,38904,"\r"],[1,38905,"\r"],[1,38936,"\r"],[1,38985,"\r"],[1,39020,"\r"],[1,39064,"\r"],[1,39172,"\r"],[1,39240,"\r"],[1,39258,"\r"],[1,39259,"\r"],[1,39288,"\r"],[1,39362,"\r"],[1,39392,"\r"],[1,39432,"\r"],[1,39472,"\r"],[1,39545,"\r"],[1,39689,"\r"],[1,39722,"\r"],[1,39833,"\r"],[1,39859,"\r"],[1,39860,"\r"],[1,40010,"\r"],[1,40049,"\r"],[1,40181,"\r"],[1,40207,"\r"],[1,40261,"\r"],[1,40329,"\r"],[1,40387,"\r"],[1,40413,"\r"],[1,40435,"\r"],[1,40455,"\r"],[1,40456,"\r"],[1,40479,"\r"],[1,40506,"\r"],[1,40553,"\r"],[1,40581,"\r"],[1,40616,"\r"],[1,40643,"\r"],[1,40707,"\r"],[1,40729,"\r"],[1,40770,"\r"],[1,40853,"\r"],[1,40909,"\r"],[1,40991,"\r"],[1,41077,"\r"],[1,41182,"\r"],[1,41204,"\r"],[1,41205,"\r"],[1,41242,"\r"],[1,41283,"\r"],[1,41413,"\r"],[1,41431,"\r"],[1,41456,"\r"],[1,41482,"\r"],[1,41503,"\r"],[1,41532,"\r"],[1,41542,"\r"],[1,41543,"\r"],[1,41564,"\r"],[-1,41570,"\n\n```\n"],[1,41576,"\r"],[-1,41664,"`"],[-1,41677,"`"],[-1,41688,"`"],[-1,41704,"`"],[-1,41706,"`"],[-1,41736,"`。\n\n```"],[1,41743,"。\r\n\r"],[1,41811,"\r"],[1,41843,"\r"],[1,41910,"\r"],[1,41920,"\r"],[1,41921,"      \r"],[1,41962,"\r"],[1,42034,"\r"],[1,42070,"\r"],[1,42128,"\r"],[1,42231,"\r"],[1,42254,"\r"],[1,42291,"\r"],[1,42451,"\r"],[1,42472,"\r"],[1,42552,"\r"],[1,42574,"\r"],[1,42622,"\r"],[1,42792,"\r"],[1,42814,"\r"],[1,42895,"\r"],[1,42986,"\r"],[1,43049,"\r"],[1,43095,"\r"],[1,43166,"\r"],[1,43167,"\r"],[1,43215,"\r"],[1,43394,"\r"],[1,43416,"\r"],[1,43456,"\r"],[1,43579,"\r"],[1,43597,"\r"],[1,43656,"\r"],[1,43706,"\r"],[1,43720,"\r"],[1,43737,"\r"],[1,43815,"\r"],[1,43876,"\r"],[1,43941,"\r"],[1,43992,"\r"],[1,44051,"\r"],[1,44104,"\r"],[1,44105,"\r"],[1,44168,"\r"],[1,44212,"\r"],[1,44248,"\r"],[1,44305,"\r"],[1,44393,"\r"],[1,44470,"\r"],[1,44471,"\r"],[1,44526,"\r"],[1,44615,"\r"],[1,44701,"\r"],[1,44744,"\r"],[1,44795,"\r"],[1,44844,"\r"],[1,44909,"\r"],[1,44931,"\r"],[1,44932,"\r"],[1,44995,"\r"],[1,45118,"\r"],[1,45136,"\r"],[1,45137,"\r"],[1,45169,"\r"],[1,45242,"\r"],[1,45256,"\r"],[1,45257,"            \r"],[1,45305,"\r"],[1,45348,"\r"],[1,45381,"\r"],[1,45472,"\r"],[1,45523,"\r"],[1,45642,"\r"],[1,45722,"\r"],[1,45806,"\r"],[1,45850,"\r"],[1,45880,"\r"],[1,45964,"\r"],[1,46017,"\r"],[1,46094,"\r"],[1,46143,"\r"],[1,46191,"\r"],[1,46290,"\r"],[1,46316,"\r"],[1,46338,"\r"],[1,46390,"\r"],[1,46482,"\r"],[1,46509,"\r"],[1,46540,"\r"],[1,46621,"\r"],[1,46646,"\r"],[1,46673,"\r"],[1,46687,"\r"],[1,46697,"\r"],[-1,46703,"\n\n```\n"],[1,46709,"\r"],[-1,46819,"`"],[-1,46828,"`"],[-1,46830,"`"],[-1,46869,"`\n\n```"],[1,46875,"\r\n\r"],[1,46934,"\r"],[1,46948,"\r"],[1,46991,"\r"],[1,47073,"\r"],[1,47074,"\r"],[1,47113,"\r"],[1,47196,"\r"],[1,47279,"\r"],[1,47293,"\r"],[1,47325,"\r"],[1,47375,"\r"],[1,47418,"\r"],[1,47465,"\r"],[1,47510,"\r"],[1,47567,"\r"],[1,47592,"\r"],[1,47602,"\r"],[-1,47608,"\n\n```\n"],[1,47614,"\r\n\r"],[-1,47621,"`"],[-1,47634,"`"],[-1,47651,"`"],[-1,47700,"`"],[-1,47704,"\n\n```"],[1,47709,"\r\n\r"],[1,47770,"\r"],[1,47838,"\r"],[1,47839,"\r"],[1,47867,"\r"],[1,47892,"\r"],[1,47909,"\r"],[1,47975,"\r"],[1,47985,"\r"],[-1,47991,"\n\n```\n"],[1,47997,"\r"],[-1,48114,"**"],[-1,48197,"**"],[1,48200,"\r"],[1,48201,"\r"],[-1,48202,"##### "],[-1,48210,"\n"],[1,48211,"\r"],[1,48255,"\r"],[1,48256,"\r"],[-1,48257,"*   **"],[-1,48268,"**\n\n```"],[1,48275,"\r"],[1,48284,"\r"],[1,48332,"\r"],[1,48382,"\r"],[1,48426,"\r"],[1,48476,"\r"],[1,48523,"\r"],[1,48583,"\r"],[1,48646,"\r"],[1,48698,"\r"],[1,48737,"\r"],[1,48738,"\r"],[1,48753,"\r"],[1,48785,"\r"],[1,48809,"\r"],[1,48845,"\r"],[1,48869,"\r"],[-1,48894,"\n\n```\n"],[1,48900,"\r"],[-1,48913,"`"],[-1,48922,"`"],[-1,48927,"`"],[-1,48935,"`"],[-1,48950,"`"],[-1,48989,"`"],[1,49000,"\r"],[-1,49022,"`"],[-1,49039,"`"],[-1,49057,"`"],[-1,49068,"`"],[-1,49086,"`"],[-1,49099,"`"],[-1,49202,"\n\n```"],[1,49207,"\r\n\r"],[1,49238,"\r"],[1,49301,"\r"],[1,49315,"\r"],[1,49355,"\r"],[1,49356,"\r"],[1,49362,"\r"],[1,49363,"\r"],[1,49377,"\r"],[1,49437,"\r"],[1,49483,"\r"],[1,49489,"\r"],[1,49490,"\r"],[1,49504,"\r"],[1,49553,"\r"],[1,49597,"\r"],[1,49603,"\r"],[-1,49605,"\n\n```\n"],[1,49611,"\r\n\r"],[-1,49626,"`"],[-1,49642,"`"],[-1,49660,"\n\n```"],[1,49665,"\r\n\r"],[1,49771,"\r"],[-1,49864,"\n\n```\n\n*   **"],[1,49877,"\r\n"],[-1,49884,"**\n\n```"],[1,49891,"\r"],[-1,49961,"\n\n```\n"],[1,49967,"\r"],[-1,49980,"`"],[-1,49991,"`"],[1,50016,"\r"],[1,50017,"\r"],[-1,50018,"*   **"],[-1,50037,"**\n"],[1,50040,"\r"],[-1,50053,"\n\n```"],[1,50058,"\r\n\r"],[1,50090,"\r"],[1,50136,"\r"],[1,50165,"\r"],[1,50186,"\r"],[1,50192,"\r"],[1,50193,"\r\n\r"],[1,50207,"\r"],[1,50282,"\r"],[1,50340,"\r"],[1,50397,"\r"],[1,50422,"\r"],[1,50428,"\r"],[1,50429,"\r"],[-1,50431,"\n\n```\n"],[1,50437,"\r"],[-1,50447,"\n\n```"],[1,50452,"\r\n\r"],[-1,50543,"\n\n```\n\n*   **"],[1,50556,"\r\n"],[-1,50563,"**\n\n```"],[1,50570,"\r"],[1,50584,"\r"],[1,50633,"\r"],[1,50720,"\r"],[1,50761,"\r"],[1,50762,"\r"],[1,50778,"\r"],[1,50900,"\r"],[-1,50988,"\n\n```\n\n*   **"],[1,51001,"\r\n"],[-1,51005,"**\n"],[1,51008,"\r"],[1,51037,"\r"],[-1,51066,"\n\n```"],[1,51071,"\r\n\r"],[1,51093,"\r"],[1,51143,"\r"],[1,51177,"\r"],[1,51179,"\r"],[1,51180,"\r"],[1,51188,"\r"],[1,51235,"\r"],[1,51291,"\r"],[1,51292,"\r"],[1,51306,"\r"],[1,51348,"\r"],[1,51377,"\r"],[1,51383,"\r"],[1,51384,"\r"],[1,51398,"\r"],[1,51438,"\r"],[1,51439,"\r"],[1,51445,"\r"],[-1,51447,"\n\n```\n"],[1,51453,"\r"],[-1,51458,"\n\n```"],[1,51463,"\r\n\r"],[1,51472,"\r"],[1,51555,"\r"],[1,51564,"\r"],[-1,51668,"\n\n```\n\n*   **"],[1,51681,"\r\n"],[-1,51686,"**\n\n![](//upload-images.jianshu.io/upload_images/5994347-767a114aa4746c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n"],[1,51815,"\r\n\r"],[1,51968,"\r"],[1,51969,"\r"],[-1,51970,"##### "],[-1,51978,"\n"],[1,51979,"\r"],[1,52078,"\r"],[1,52079,"\r"],[-1,52080,"**"],[-1,52111,"**\n"],[1,52114,"\r\n\r"],[1,52128,"\r"],[1,52129,"\r"],[-1,52134,"\n\n["],[1,52137,"\r\n "],[-1,52148,"](/nb/12473806)\n\n"],[1,52165," "],[-1,52175,"\n\n"],[1,52177," "],[1,52181,"\r"],[-1,52182,"\n[![96](//upload.jianshu.io/users/upload_avatars/5994347/dd34592b-ad62-4e24-bb66-f7c689766b2f.png?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96) ](/u/d65e2e163603) "],[-1,52354," ["],[-1,52364,"](/u/d65e2e163603)\n"],[1,52383,"\r"],[1,52414,"\r"],[1,52415,"\r"],[-1,52418,"\n\n12\n\n[](javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f='http://v.t.sina.com.cn/share/share.php?appkey=1881139527',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function%20a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,'','','', '推荐 @龍儱滝 的文章《阿里ARouter使用及源码解析（一）》（ 分享自 @简书 ）','https://www.jianshu.com/p/46d174f37e82?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo','页面编码gb2312|utf-8默认gb2312'));)[](http://cwb.assets.jianshu.io/notes/images/13526520/weibo/image_bcbd18a5f866.png)["],[1,53265," 12    "],[-1,53269,"](javascript:void(0);)\n\n![](//upload.jianshu.io/users/upload_avatars/1786025/f63ccf82f6f8?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114) \n"],[1,53415,"\r\n\r"],[-1,53426,"关闭评论\n\n"],[-1,53447,"\n\n[![](//cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/ab7bfd384c72)\n\n["],[1,53609,"\r\n "],[-1,53618,"](/u/ab7bfd384c72)\n"],[1,53637,"\r"],[-1,53659,"\n"],[1,53660,"\r"],[1,53668,"\r"],[1,53669,"\r"],[1,53674," "],[-1,53676," 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/426662/e85a4080db83?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/a2a56d463e3d)\n\n[夏鸣浩](/u/a2a56d463e3d)\n"],[1,53844,"\r\n 夏鸣浩\r"],[-1,53866,"\n"],[1,53867,"\r"],[1,53877,"\r"],[1,53878,"\r"],[1,53881," "],[-1,53883," 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/7293029/42130be5-9eb3-4cf2-8874-1f32e70d81e2?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/df76f81fe3ff)\n\n["],[1,54054,"\r\n "],[-1,54060,"](/u/df76f81fe3ff)\n"],[1,54079,"\r"],[-1,54101,"\n"],[1,54102,"\r"],[1,54110,"\r"],[1,54111,"\r"],[1,54114," "],[-1,54116," 举报\n"],[1,54120,"\r\n\r"],[1,54132,"\r"],[1,54174,"\r"],[1,54180,"\r"]],[0,54215],[51842,51842]]],[1519699554390,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,92,"\r"],[-1,94,"\r"],[1,96,"*   "],[-1,132,"\r"],[1,134,"*   "],[-1,169,"\r"],[1,171,"*   "],[-1,211,"\r"],[1,213,"*   "],[-1,264,"\r"],[1,266,"*   "],[1,292,"\n"],[-1,292,"\r"],[1,298,"["],[1,305,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)"],[1,403,"["],[1,432,"](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)"],[-1,433,"\r"],[-1,435,"\r"],[-1,451,"\r"],[-1,453,"\r"],[1,455,"*   ["],[1,474,"](https://www.jianshu.com/p/46d174f37e82)\n*   ["],[-1,474,"\r\n"],[1,498,"](https://www.jianshu.com/p/c8d7b1379c1b)\n*   "],[-1,498,"\r\n"],[1,525,"\n\n##### "],[-1,525,"\r\n"],[1,533,"\n"],[-1,533,"\r"],[1,544,"\n\n```"],[-1,544,"\r\n\r"],[-1,557,"\r"],[-1,578,"\r"],[-1,587,"\r"],[-1,613,"\r"],[-1,651,"\r"],[-1,707,"\r"],[-1,718,"\r"],[-1,725,"\r"],[-1,732,"\r"],[-1,735,"\r"],[-1,737,"\r"],[-1,753,"\r"],[-1,800,"\r"],[-1,864,"\r"],[-1,873,"\r"],[1,876,"\n\n```\n"],[-1,876,"\r"],[1,884,"\n\n```"],[-1,884,"\r\n\r"],[-1,908,"\r"],[-1,938,"\r"],[-1,968,"\r"],[-1,1023,"\r"],[-1,1025,"\r"],[-1,1040,"\r"],[-1,1108,"\r"],[-1,1153,"\r"],[-1,1203,"\r"],[-1,1210,"\r"],[1,1213,"\n\n```\n"],[-1,1213,"\r"],[1,1223,"\n\n```"],[-1,1223,"\r\n\r"],[-1,1312,"\r"],[-1,1343,"\r"],[-1,1358,"\r"],[-1,1416,"\r"],[-1,1461,"\r"],[-1,1510,"\r"],[-1,1560,"\r"],[-1,1610,"\r"],[-1,1612,"\r"],[-1,1652,"\r"],[-1,1692,"\r"],[-1,1699,"\r"],[-1,1701,"\r"],[-1,1716,"\r"],[-1,1751,"\r"],[-1,1790,"\r"],[-1,1866,"\r"],[-1,1923,"\r"],[-1,1957,"\r"],[-1,2029,"\r"],[-1,2040,"\r"],[-1,2047,"\r"],[1,2050,"\n\n```\n"],[-1,2050,"\r"],[1,2060,"\n\n```"],[-1,2060,"\r\n\r"],[-1,2149,"\r"],[-1,2180,"\r"],[-1,2195,"\r"],[-1,2253,"\r"],[-1,2298,"\r"],[-1,2347,"\r"],[-1,2397,"\r"],[-1,2447,"\r"],[-1,2449,"\r"],[-1,2489,"\r"],[-1,2529,"\r"],[-1,2536,"\r"],[-1,2538,"\r"],[-1,2553,"\r"],[-1,2588,"\r"],[-1,2627,"\r"],[-1,2645,"\r"],[-1,2690,"\r"],[-1,2760,"\r"],[-1,2771,"\r"],[-1,2778,"\r"],[1,2781,"\n\n```\n"],[-1,2781,"\r"],[-1,2826,"\r"],[-1,2828,"\r"],[1,2830,"##### "],[1,2834,"\n\n###### "],[-1,2834,"\r\n"],[1,2850,"\n"],[-1,2850,"\r"],[1,2893,"["],[1,2911,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)"],[1,2921,"["],[1,2937,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n"],[-1,2937,"\r\n\r"],[1,2946,"`"],[1,2952,"`"],[1,2958,"\n\n```"],[-1,2958,"\r\n\r"],[-1,2989,"\r"],[-1,3024,"\r"],[-1,3051,"\r"],[-1,3053,"\r"],[-1,3062,"\r"],[-1,3084,"\r"],[-1,3093,"\r"],[-1,3113,"\r"],[-1,3115,"\r"],[-1,3124,"\r"],[-1,3153,"\r"],[-1,3162,"\r"],[-1,3194,"\r"],[-1,3196,"\r"],[-1,3205,"\r"],[-1,3235,"\r"],[-1,3244,"\r"],[-1,3284,"\r"],[-1,3286,"\r"],[-1,3295,"\r"],[-1,3326,"\r"],[-1,3335,"\r"],[-1,3380,"\r"],[-1,3382,"\r"],[-1,3391,"\r"],[-1,3406,"\r"],[-1,3415,"\r"],[-1,3447,"\r"],[1,3450,"\n\n```\n"],[-1,3450,"\r"],[1,3459,"`"],[1,3464,"`"],[1,3618,"`"],[1,3623,"`"],[-1,3648,"\r"],[1,3676,"`"],[1,3684,"`"],[1,3699,"`"],[1,3705,"`"],[-1,3735,"\r"],[-1,3737,"\r"],[1,3768,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n"],[-1,3768,"\r\n\r\n\r"],[1,3789,"`"],[1,3803,"`"],[1,3824,"["],[1,3860,"](https://www.jianshu.com/p/07ef8ba80562)"],[1,3868,"**"],[1,3876,"**"],[1,3887,"`"],[1,3901,"`"],[1,3912,"\n\n```"],[-1,3912,"\r\n\r"],[-1,3929,"\r"],[-1,4026,"\r"],[-1,4053,"\r"],[-1,4109,"\r"],[-1,4162,"\r"],[-1,4262,"\r"],[-1,4281,"\r"],[-1,4345,"\r"],[-1,4383,"\r"],[-1,4433,"\r"],[-1,4435,"\r"],[-1,4472,"\r"],[-1,4506,"\r"],[-1,4521,"\r"],[-1,4547,"\r"],[-1,4558,"\r"],[-1,4560,"\r"],[-1,4583,"\r"],[1,4590,"\n\n```\n\n`"],[-1,4590,"\r\n"],[1,4601,"`"],[1,4613,"`"],[1,4619,"`"],[1,4653,"`"],[1,4667,"`"],[1,4671,"`"],[1,4684,"`"],[1,4692,"`"],[1,4698,"`"],[-1,4737,"\r"],[-1,4739,"\r"],[1,4741,"*   "],[1,4760,"\n\n```"],[-1,4760,"\r"],[-1,4817,"\r"],[-1,4830,"\r"],[-1,4906,"\r"],[-1,4959,"\r"],[-1,4964,"\r"],[1,4967,"\n\n```\n\n*   "],[-1,4967,"\r\n"],[1,4990,"\n\n```"],[-1,4990,"\r"],[-1,5050,"\r"],[-1,5063,"\r"],[-1,5119,"\r"],[-1,5254,"\r"],[-1,5259,"\r"],[1,5262,"\n\n```\n\n*   "],[-1,5262,"\r\n"],[1,5288,"\n\n```"],[-1,5288,"\r"],[-1,5354,"\r"],[-1,5367,"\r"],[-1,5427,"\r"],[-1,5432,"\r"],[1,5435,"\n\n```\n"],[-1,5435,"\r"],[-1,5455,"\r"],[-1,5457,"\r"],[1,5480,"\n\n```"],[-1,5480,"\r\n\r"],[-1,5568,"\r"],[-1,5626,"\r"],[-1,5628,"          \r"],[-1,5726,"\r"],[-1,5728,"\r"],[-1,5758,"\r"],[-1,5798,"\r"],[-1,5876,"\r"],[-1,5905,"\r"],[-1,5984,"\r"],[-1,6060,"\r"],[-1,6089,"\r"],[-1,6166,"\r"],[-1,6243,"\r"],[-1,6324,"\r"],[-1,6413,"\r"],[-1,6506,"\r"],[-1,6508,"\r"],[-1,6625,"\r"],[-1,6658,"\r"],[-1,6744,"\r"],[-1,6862,"\r"],[-1,6898,"\r"],[-1,6990,"\r"],[-1,7029,"\r"],[-1,7098,"\r"],[-1,7167,"\r"],[-1,7169,"\r"],[-1,7216,"\r"],[-1,7232,"\r"],[-1,7323,"\r"],[-1,7340,"\r"],[-1,7423,"\r"],[-1,7470,"\r"],[-1,7520,"\r"],[-1,7568,"\r"],[-1,7625,"\r"],[-1,7714,"\r"],[-1,7737,"\r"],[-1,7753,"\r"],[-1,7755,"\r"],[-1,7771,"\r"],[-1,7867,"\r"],[-1,7884,"\r"],[-1,7968,"\r"],[-1,8015,"\r"],[-1,8065,"\r"],[-1,8117,"\r"],[-1,8133,"\r"],[-1,8135,"\r"],[-1,8151,"\r"],[-1,8173,"\r"],[-1,8190,"\r"],[-1,8282,"\r"],[-1,8386,"\r"],[-1,8458,"\r"],[-1,8563,"\r"],[-1,8644,"\r"],[-1,8758,"\r"],[-1,8760,"\r\n          \r"],[-1,8789,"\r"],[-1,8800,"\r"],[1,8807,"\n\n```\n"],[-1,8807,"\r"],[1,8840,"\n\n```"],[-1,8840,"\r\n\r"],[-1,8928,"\r"],[-1,8986,"\r"],[-1,9008,"\r"],[-1,9010,"\r"],[-1,9026,"\r"],[-1,9080,"\r"],[-1,9105,"\r"],[-1,9194,"\r"],[-1,9211,"\r"],[-1,9316,"\r"],[-1,9368,"\r"],[-1,9411,"\r"],[-1,9462,"\r"],[-1,9464,"\r"],[-1,9498,"\r"],[-1,9551,"\r"],[-1,9602,"\r"],[-1,9669,"\r"],[-1,9714,"\r"],[-1,9716,"                \r"],[-1,9813,"\r"],[-1,9912,"\r"],[-1,10001,"\r"],[-1,10003,"\r"],[-1,10060,"\r"],[-1,10109,"\r"],[-1,10181,"\r"],[-1,10256,"\r"],[-1,10412,"\r"],[-1,10510,"\r"],[-1,10601,"\r"],[-1,10783,"\r"],[-1,10810,"\r"],[-1,10833,"\r"],[-1,10870,"\r"],[-1,10966,"\r"],[-1,11052,"\r"],[-1,11141,"\r"],[-1,11201,"\r"],[-1,11289,"\r"],[-1,11379,"\r"],[-1,11477,"\r"],[-1,11565,"\r"],[-1,11601,"\r"],[-1,11697,"\r"],[-1,11797,"\r"],[-1,11886,"\r"],[-1,11921,"\r"],[-1,12018,"\r"],[-1,12037,"\r"],[-1,12039,"                \r"],[-1,12146,"\r"],[-1,12181,"\r"],[-1,12221,"\r"],[-1,12223,"          \r"],[-1,12248,"\r"],[-1,12250,"\r"],[-1,12273,"\r"],[-1,12284,"\r"],[1,12291,"\n\n```\n"],[-1,12291,"\r"],[1,12380,"`"],[1,12389,"`"],[1,12395,"`"],[1,12416,"`"],[1,12427,"`"],[1,12435,"`"],[-1,12438,"\r"],[-1,12440,"\r"],[1,12448,"\n\n```"],[-1,12448,"\r\n\r"],[-1,12536,"\r"],[-1,12594,"\r"],[-1,12616,"\r"],[-1,12618,"\r"],[-1,12635,"\r"],[-1,12694,"\r"],[-1,12718,"\r"],[-1,12790,"\r"],[-1,12807,"\r"],[-1,12916,"\r"],[-1,12968,"\r"],[-1,13011,"\r"],[-1,13066,"\r"],[-1,13068,"\r"],[-1,13103,"\r"],[-1,13167,"\r"],[-1,13250,"\r"],[-1,13302,"\r"],[-1,13321,"\r"],[-1,13378,"\r"],[-1,13406,"\r"],[-1,13478,"\r"],[-1,13495,"\r"],[-1,13605,"\r"],[-1,13661,"\r"],[-1,13708,"\r"],[-1,13764,"\r"],[-1,13766,"\r"],[-1,13802,"\r"],[-1,13864,"\r"],[-1,13896,"\r"],[-1,13953,"\r"],[-1,14005,"\r"],[-1,14049,"\r"],[-1,14091,"\r"],[-1,14134,"\r"],[-1,14259,"\r"],[-1,14323,"\r"],[-1,14441,"\r"],[-1,14548,"\r"],[-1,14629,"\r"],[-1,14712,"\r"],[-1,14907,"\r"],[-1,15000,"\r"],[-1,15058,"\r"],[-1,15116,"\r"],[-1,15214,"\r"],[-1,15280,"\r"],[-1,15348,"\r"],[-1,15426,"\r"],[-1,15538,"\r"],[-1,15621,"\r"],[-1,15816,"\r"],[-1,15896,"\r"],[-1,15954,"\r"],[-1,16012,"\r"],[-1,16110,"\r"],[-1,16176,"\r"],[-1,16244,"\r"],[-1,16279,"\r"],[-1,16321,"\r"],[-1,16494,"\r"],[-1,16525,"\r"],[-1,16561,"\r"],[-1,16595,"\r"],[-1,16631,"\r"],[-1,16654,"\r"],[-1,16656,"\r"],[-1,16711,"\r"],[-1,16784,"\r"],[-1,16833,"\r"],[-1,16915,"\r"],[-1,16975,"\r"],[-1,17065,"\r"],[-1,17204,"\r"],[-1,17231,"\r"],[-1,17254,"\r"],[-1,17319,"\r"],[-1,17321,"                    \r"],[-1,17404,"\r"],[-1,17445,"\r"],[-1,17509,"\r"],[-1,17809,"\r"],[-1,17859,"\r"],[-1,17901,"\r"],[-1,17943,"\r"],[-1,18025,"\r"],[-1,18089,"\r"],[-1,18155,"\r"],[-1,18174,"\r"],[-1,18176,"\r"],[-1,18230,"\r"],[-1,18283,"\r"],[-1,18365,"\r"],[-1,18432,"\r"],[-1,18492,"\r"],[-1,18554,"\r"],[-1,18613,"\r"],[-1,18698,"\r"],[-1,18753,"\r"],[-1,18835,"\r"],[-1,18877,"\r"],[-1,18921,"\r"],[-1,18923,"\r"],[-1,18998,"\r"],[-1,19067,"\r"],[-1,19123,"\r"],[-1,19138,"\r"],[-1,19140,"\r"],[-1,19158,"\r"],[-1,19169,"\r"],[1,19176,"\n\n```\n"],[-1,19176,"\r"],[-1,19190,"\r"],[-1,19192,"\r"],[1,19194,"*   "],[1,19196,"`"],[1,19204,"`"],[1,19229,"`"],[1,19239,"`"],[1,19328,"`"],[1,19335,"`"],[1,19351,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n"],[-1,19351,"\r"],[1,19359,"\n"],[-1,19359,"\r"],[1,19366,"`"],[1,19376,"`"],[1,19388,"`"],[1,19395,"`"],[1,19402,"\n\n```"],[-1,19402,"\r\n\r"],[-1,19464,"\r"],[-1,19477,"\r"],[-1,19533,"\r"],[-1,19563,"\r"],[-1,19809,"\r"],[-1,19820,"\r"],[-1,19849,"\r"],[-1,19992,"\r"],[-1,20002,"\r"],[-1,20007,"\r"],[1,20010,"\n\n```\n\n*   "],[-1,20010,"\r\n"],[1,20077,"`"],[1,20087,"`"],[1,20134,"`"],[1,20144,"`"],[1,20170,"\n\n```"],[-1,20170,"\r"],[-1,20236,"\r"],[-1,20249,"\r"],[-1,20309,"\r"],[-1,20503,"\r"],[-1,20537,"\r"],[-1,20735,"\r"],[-1,20768,"\r"],[-1,20961,"\r"],[-1,20966,"\r"],[1,20969,"\n\n```\n\n*   "],[-1,20969,"\r\n"],[1,21053,"\n"],[-1,21053,"\r"],[1,21061,"`"],[1,21074,"`"],[1,21119,"`"],[1,21129,"`"],[1,21182,"\n\n```"],[-1,21182,"\r\n\r"],[-1,21270,"\r"],[-1,21328,"\r"],[-1,21350,"\r"],[-1,21415,"\r"],[-1,21464,"\r"],[-1,21591,"\r"],[-1,21669,"\r"],[-1,21835,"\r"],[-1,21854,"\r"],[-1,21869,"\r"],[-1,21871,"\r"],[-1,21914,"\r"],[-1,21999,"\r"],[-1,22055,"\r"],[-1,22119,"\r"],[-1,22174,"\r"],[-1,22258,"\r"],[-1,22309,"\r"],[-1,22390,"\r"],[-1,22428,"\r"],[-1,22468,"\r"],[-1,22470,"\r"],[-1,22567,"\r"],[-1,22569,"\r"],[-1,22608,"\r"],[-1,22682,"\r"],[-1,22738,"\r"],[-1,22795,"\r"],[-1,22850,"\r"],[-1,22955,"\r"],[-1,23006,"\r"],[-1,23083,"\r"],[-1,23121,"\r"],[-1,23161,"\r"],[-1,23163,"\r"],[-1,23245,"\r"],[-1,23256,"\r"],[1,23263,"\n\n```\n"],[-1,23263,"\r"],[1,23270,"`"],[1,23280,"`"],[1,23306,"\n\n```"],[-1,23306,"\r\n\r"],[-1,23365,"\r"],[-1,23378,"\r"],[-1,23454,"\r"],[-1,23513,"\r"],[-1,23566,"\r"],[-1,23571,"\r"],[1,23574,"\n\n```\n\n**"],[-1,23574,"\r\n"],[1,23583,"`"],[1,23596,"`"],[1,23605,"**\n"],[-1,23605,"\r\n\r"],[1,23617,"`"],[1,23629,"`"],[1,23637,"\n\n```"],[-1,23637,"\r\n\r"],[-1,23690,"\r"],[-1,23726,"\r"],[-1,23765,"\r"],[-1,23893,"\r"],[-1,23976,"\r"],[-1,24006,"\r"],[-1,24083,"\r"],[-1,24139,"\r"],[-1,24230,"\r"],[-1,24261,"\r"],[-1,24331,"\r"],[-1,24362,"\r"],[-1,24436,"\r"],[-1,24498,"\r"],[-1,24559,"\r"],[-1,24598,"\r"],[-1,24625,"\r"],[-1,24648,"\r"],[-1,24669,"\r"],[-1,24715,"\r"],[-1,24782,"\r"],[-1,24804,"\r"],[-1,24848,"\r"],[-1,24863,"\r"],[-1,24881,"\r"],[-1,24984,"\r"],[-1,24995,"\r"],[-1,25002,"\r"],[-1,25004,"\r"],[-1,25032,"\r"],[-1,25080,"\r"],[-1,25119,"\r"],[-1,25156,"\r"],[-1,25275,"\r"],[-1,25302,"\r"],[-1,25313,"\r"],[-1,25315,"\r"],[-1,25381,"\r"],[-1,25479,"\r"],[-1,25498,"\r"],[-1,25578,"\r"],[-1,25636,"\r"],[-1,25671,"\r"],[-1,25690,"\r"],[-1,25692,"\r"],[-1,25738,"\r"],[-1,25768,"\r"],[-1,25805,"\r"],[-1,25890,"\r"],[-1,25921,"\r"],[-1,25936,"\r"],[-1,25947,"\r"],[-1,25949,"\r"],[-1,25971,"\r"],[1,25978,"\n\n```\n"],[-1,25978,"\r"],[-1,26072,"\r"],[-1,26074,"\r"],[1,26080,"`"],[1,26086,"`"],[-1,26170,"\r"],[-1,26172,"\r"],[1,26174,"###### "],[1,26188,"\n"],[-1,26188,"\r"],[1,26279,"["],[1,26290,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `"],[-1,26290,"\r\n\r\n"],[1,26301,"`"],[1,26302,"`"],[1,26308,"`"],[1,26310,"\n\n```"],[-1,26310,"\r"],[-1,26362,"\r"],[-1,26387,"\r"],[-1,26426,"\r"],[-1,26496,"\r"],[-1,26547,"\r"],[-1,26549,"\r"],[-1,26577,"\r"],[-1,26616,"\r"],[-1,26631,"\r"],[-1,26633,"\r"],[-1,26702,"\r"],[-1,26713,"\r"],[1,26720,"\n\n```\n"],[-1,26720,"\r"],[1,26743,"`"],[1,26751,"`"],[1,26754,"`"],[1,26761,"`"],[1,26780,"`"],[1,26788,"`"],[-1,26794,"\r"],[-1,26796,"\r"],[1,26798,"*   `"],[1,26806,"`"],[1,26807,"`"],[1,26813,"`"],[1,26815,"\n\n```"],[-1,26815,"\r"],[-1,26888,"\r"],[-1,26921,"\r"],[-1,26972,"\r"],[-1,27031,"\r"],[-1,27056,"\r"],[-1,27058,"\r"],[-1,27080,"\r"],[1,27087,"\n\n```\n\n`"],[-1,27087,"\r\n"],[1,27097,"`"],[1,27102,"`"],[1,27124,"`"],[1,27142,"`"],[1,27150,"`"],[1,27168,"\n\n```"],[-1,27168,"\r\n\r"],[-1,27279,"\r"],[-1,27308,"\r"],[-1,27333,"\r"],[-1,27335,"\r"],[-1,27350,"\r"],[-1,27424,"\r"],[-1,27470,"\r"],[-1,27580,"\r"],[-1,27582,"\r"],[-1,27626,"\r"],[-1,27681,"\r"],[-1,27763,"\r"],[-1,27871,"\r"],[-1,27982,"\r"],[-1,28109,"\r"],[-1,28232,"\r"],[-1,28326,"\r"],[-1,28436,"\r"],[-1,28576,"\r"],[-1,28696,"\r"],[-1,28788,"\r"],[-1,28857,"\r"],[-1,28991,"\r"],[-1,29010,"\r"],[-1,29025,"\r"],[-1,29027,"\r"],[-1,29081,"\r"],[-1,29182,"\r"],[-1,29197,"\r"],[-1,29199,"\r"],[-1,29240,"\r"],[-1,29511,"\r"],[-1,29526,"\r"],[-1,29559,"\r"],[-1,29675,"\r"],[-1,29686,"\r"],[1,29693,"\n\n```\n\n*   `"],[-1,29693,"\r\n"],[1,29703,"`"],[1,29704,"`"],[1,29715,"`"],[1,29717,"\n\n```"],[-1,29717,"\r"],[-1,29744,"\r"],[-1,29797,"\r"],[-1,29922,"\r"],[1,29929,"\n\n```\n"],[-1,29929,"\r"],[1,29958,"`"],[1,29992,"`"],[1,30016,"["],[1,30027,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)"],[1,30028,"`"],[1,30038,"`"],[-1,30045,"\r"],[1,30047,"**"],[1,30143,"**"],[1,30167,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n"],[-1,30167,"\r\n\r\n\r"],[1,30304,"`"],[1,30313,"`"],[-1,30356,"\r"],[-1,30358,"\r"],[1,30360,"###### "],[1,30375,"\n"],[-1,30375,"\r"],[-1,30386,"\r"],[-1,30388,"\r"],[1,30390,"> "],[-1,30450,"\r"],[-1,30452,"\r"],[-1,30508,"\r"],[-1,30510,"\r"],[1,30512,"> "],[-1,30522,"\r"],[1,30524,"> "],[-1,30582,"\r"],[-1,30584,"\r"],[1,30586,"> "],[-1,30596,"\r"],[1,30598,"> "],[-1,30650,"\r"],[-1,30652,"\r"],[1,30672,"`"],[1,30693,"`"],[1,30730,"`"],[1,30737,"`"],[1,30738,"`"],[1,30750,"`"],[-1,30751,"\r"],[-1,30753,"\r"],[1,30755,"**"],[1,30764,"**"],[-1,30764,"\r"],[1,30774,"`"],[1,30792,"`"],[1,30793,"`"],[1,30799,"`"],[1,30808,"`"],[1,30816,"`"],[1,30817,"`"],[1,30835,"`"],[1,30838,"\n\n```"],[-1,30838,"\r\n\r"],[-1,30883,"\r"],[-1,30923,"\r"],[-1,31002,"\r"],[-1,31020,"\r"],[-1,31123,"\r"],[-1,31160,"\r"],[-1,31210,"\r"],[-1,31225,"\r"],[-1,31278,"\r"],[-1,31289,"\r"],[1,31296,"\n\n```\n"],[-1,31296,"\r"],[1,31300,"`"],[1,31325,"`"],[1,31356,"\n\n```"],[-1,31356,"\r\n\r"],[-1,31404,"\r"],[-1,31469,"\r"],[-1,31621,"\r"],[-1,31632,"\r"],[-1,31634,"\r"],[-1,31649,"\r"],[-1,31706,"\r"],[-1,31782,"\r"],[-1,31834,"\r"],[-1,31960,"\r"],[-1,31982,"\r"],[-1,32020,"\r"],[-1,32035,"\r"],[-1,32068,"\r"],[-1,32163,"\r"],[-1,32189,"\r"],[-1,32200,"\r"],[1,32207,"\n\n```\n\n`"],[-1,32207,"\r\n"],[1,32227,"`"],[1,32235,"`"],[1,32267,"`\n\n```"],[-1,32267,"\r\n\r"],[-1,32328,"\r"],[-1,32396,"\r"],[-1,32475,"\r"],[-1,32493,"\r"],[-1,32596,"\r"],[-1,32633,"\r"],[-1,32683,"\r"],[-1,32698,"\r"],[-1,32745,"\r"],[-1,32756,"\r"],[1,32763,"\n\n```\n\n**"],[-1,32763,"\r\n"],[1,32773,"`"],[1,32831,"`"],[1,32837,"`"],[1,32855,"`"],[1,32940,"**"],[-1,32940,"\r"],[1,32945,"`"],[1,32963,"`"],[1,32974,"`"],[1,32985,"`"],[1,32986,"`"],[1,32994,"`"],[1,33021,"\n\n```"],[-1,33021,"\r\n\r"],[-1,33080,"\r"],[-1,33082,"\r"],[-1,33091,"\r"],[-1,33116,"\r"],[-1,33124,"\r"],[-1,33153,"\r"],[-1,33162,"\r"],[-1,33198,"\r"],[-1,33200,"\r"],[-1,33209,"\r"],[-1,33231,"\r"],[-1,33239,"\r"],[-1,33266,"\r"],[-1,33275,"\r"],[-1,33301,"\r"],[1,33304,"\n\n```\n"],[-1,33304,"\r\n\r"],[1,33314,"`"],[1,33322,"`"],[1,33350,"`"],[1,33357,"`"],[1,33376,"`"],[1,33384,"`"],[1,33436,"\n\n```"],[-1,33436,"\r\n\r"],[-1,33487,"\r"],[-1,33509,"\r"],[-1,33585,"\r"],[-1,33631,"\r"],[-1,33686,"\r"],[-1,33764,"\r"],[-1,33818,"\r"],[-1,33853,"\r"],[-1,33918,"\r"],[-1,33920,"\r"],[-1,33934,"\r"],[-1,34012,"\r"],[-1,34040,"\r"],[-1,34067,"\r"],[-1,34069,"\r"],[-1,34098,"\r"],[-1,34145,"\r"],[-1,34183,"\r"],[-1,34230,"\r"],[-1,34273,"\r"],[-1,34316,"\r"],[-1,34360,"\r"],[-1,34405,"\r"],[-1,34475,"\r"],[-1,34490,"\r"],[1,34493,"\n\n```\n\n**"],[-1,34493,"\r\n"],[1,34509,"**"],[-1,34509,"\r"],[1,34518,"`"],[1,34530,"`"],[1,34548,"`"],[1,34556,"`"],[1,34562,"\n\n```"],[-1,34562,"\r\n\r"],[-1,34705,"\r"],[-1,34720,"\r"],[-1,34816,"\r"],[-1,34867,"\r"],[-1,34913,"\r"],[-1,34971,"\r"],[-1,34973,"\r"],[-1,35038,"\r"],[-1,35112,"\r"],[-1,35180,"\r"],[-1,35274,"\r"],[-1,35289,"\r"],[-1,35339,"\r"],[-1,35406,"\r"],[-1,35450,"\r"],[-1,35487,"\r"],[-1,35531,"\r"],[-1,35628,"\r"],[-1,35733,"\r"],[-1,35780,"\r"],[-1,35843,"\r"],[-1,35862,"\r"],[-1,35877,"\r"],[-1,35879,"\r"],[-1,35905,"\r"],[-1,35916,"\r"],[-1,35956,"\r"],[-1,35989,"\r"],[-1,36030,"\r"],[-1,36041,"\r"],[-1,36043,"        \r"],[-1,36115,"\r"],[-1,36161,"\r"],[-1,36207,"\r"],[-1,36293,"\r"],[-1,36314,"\r"],[-1,36351,"\r"],[-1,36371,"\r"],[-1,36418,"\r"],[-1,36439,"\r"],[-1,36466,"\r"],[-1,36527,"\r"],[-1,36603,"\r"],[-1,36622,"\r"],[-1,36624,"\r"],[-1,36645,"\r"],[-1,36734,"\r"],[-1,36754,"\r"],[-1,36811,"\r"],[-1,36832,"\r"],[-1,36859,"\r"],[-1,36923,"\r"],[-1,36968,"\r"],[-1,37025,"\r"],[-1,37048,"\r"],[-1,37050,"\r"],[-1,37173,"\r"],[-1,37192,"\r"],[-1,37209,"\r"],[-1,37227,"\r"],[-1,37302,"\r"],[-1,37313,"\r"],[-1,37315,"\r"],[-1,37337,"\r"],[-1,37344,"\r"],[1,37346,"\n```\n\n**"],[1,37382,"`"],[1,37396,"`"],[1,37401,"`"],[1,37409,"`"],[1,37454,"**"],[1,37458,"`"],[1,37472,"`"],[1,37475,"\n\n```"],[-1,37475,"\r\n\r"],[-1,37530,"\r"],[-1,37532,"\r"],[-1,37541,"\r"],[-1,37566,"\r"],[-1,37574,"\r"],[-1,37603,"\r"],[-1,37612,"\r"],[-1,37666,"\r"],[1,37669,"\n\n```\n"],[-1,37669,"\r\n\r"],[1,37703,"`"],[1,37716,"`"],[1,37724,"\n\n```"],[-1,37724,"\r\n\r"],[-1,37862,"\r"],[-1,37940,"\r"],[-1,37942,"\r"],[-1,37981,"\r"],[-1,38009,"\r"],[-1,38059,"\r"],[-1,38088,"\r"],[-1,38182,"\r"],[-1,38206,"\r"],[-1,38263,"\r"],[-1,38265,"\r"],[-1,38297,"\r"],[-1,38347,"\r"],[-1,38383,"\r"],[-1,38428,"\r"],[-1,38537,"\r"],[-1,38606,"\r"],[-1,38625,"\r"],[-1,38627,"\r"],[-1,38657,"\r"],[-1,38732,"\r"],[-1,38763,"\r"],[-1,38804,"\r"],[-1,38845,"\r"],[-1,38919,"\r"],[-1,39064,"\r"],[-1,39098,"\r"],[-1,39210,"\r"],[-1,39237,"\r"],[-1,39239,"\r"],[-1,39390,"\r"],[-1,39430,"\r"],[-1,39563,"\r"],[-1,39590,"\r"],[-1,39645,"\r"],[-1,39714,"\r"],[-1,39773,"\r"],[-1,39800,"\r"],[-1,39823,"\r"],[-1,39844,"\r"],[-1,39846,"\r"],[-1,39870,"\r"],[-1,39898,"\r"],[-1,39946,"\r"],[-1,39975,"\r"],[-1,40011,"\r"],[-1,40039,"\r"],[-1,40104,"\r"],[-1,40127,"\r"],[-1,40169,"\r"],[-1,40253,"\r"],[-1,40310,"\r"],[-1,40393,"\r"],[-1,40480,"\r"],[-1,40586,"\r"],[-1,40609,"\r"],[-1,40611,"\r"],[-1,40649,"\r"],[-1,40691,"\r"],[-1,40822,"\r"],[-1,40841,"\r"],[-1,40867,"\r"],[-1,40894,"\r"],[-1,40916,"\r"],[-1,40946,"\r"],[-1,40957,"\r"],[-1,40959,"\r"],[-1,40981,"\r"],[1,40988,"\n\n```\n"],[-1,40988,"\r"],[1,41077,"`"],[1,41089,"`"],[1,41099,"`"],[1,41114,"`"],[1,41115,"`"],[1,41144,"`。\n\n```"],[-1,41144,"。\r\n\r"],[-1,41216,"\r"],[-1,41249,"\r"],[-1,41317,"\r"],[-1,41328,"\r"],[-1,41330,"      \r"],[-1,41378,"\r"],[-1,41451,"\r"],[-1,41488,"\r"],[-1,41547,"\r"],[-1,41651,"\r"],[-1,41675,"\r"],[-1,41713,"\r"],[-1,41874,"\r"],[-1,41896,"\r"],[-1,41977,"\r"],[-1,42000,"\r"],[-1,42049,"\r"],[-1,42220,"\r"],[-1,42243,"\r"],[-1,42325,"\r"],[-1,42417,"\r"],[-1,42481,"\r"],[-1,42528,"\r"],[-1,42600,"\r"],[-1,42602,"\r"],[-1,42651,"\r"],[-1,42831,"\r"],[-1,42854,"\r"],[-1,42895,"\r"],[-1,43019,"\r"],[-1,43038,"\r"],[-1,43098,"\r"],[-1,43149,"\r"],[-1,43164,"\r"],[-1,43182,"\r"],[-1,43261,"\r"],[-1,43323,"\r"],[-1,43389,"\r"],[-1,43441,"\r"],[-1,43501,"\r"],[-1,43555,"\r"],[-1,43557,"\r"],[-1,43621,"\r"],[-1,43666,"\r"],[-1,43703,"\r"],[-1,43761,"\r"],[-1,43850,"\r"],[-1,43928,"\r"],[-1,43930,"\r"],[-1,43986,"\r"],[-1,44076,"\r"],[-1,44163,"\r"],[-1,44207,"\r"],[-1,44259,"\r"],[-1,44309,"\r"],[-1,44375,"\r"],[-1,44398,"\r"],[-1,44400,"\r"],[-1,44464,"\r"],[-1,44588,"\r"],[-1,44607,"\r"],[-1,44609,"\r"],[-1,44642,"\r"],[-1,44716,"\r"],[-1,44731,"\r"],[-1,44733,"            \r"],[-1,44794,"\r"],[-1,44838,"\r"],[-1,44872,"\r"],[-1,44964,"\r"],[-1,45016,"\r"],[-1,45136,"\r"],[-1,45217,"\r"],[-1,45302,"\r"],[-1,45347,"\r"],[-1,45378,"\r"],[-1,45463,"\r"],[-1,45517,"\r"],[-1,45595,"\r"],[-1,45645,"\r"],[-1,45694,"\r"],[-1,45794,"\r"],[-1,45821,"\r"],[-1,45844,"\r"],[-1,45897,"\r"],[-1,45990,"\r"],[-1,46018,"\r"],[-1,46050,"\r"],[-1,46132,"\r"],[-1,46158,"\r"],[-1,46186,"\r"],[-1,46201,"\r"],[-1,46212,"\r"],[1,46219,"\n\n```\n"],[-1,46219,"\r"],[1,46330,"`"],[1,46338,"`"],[1,46339,"`"],[1,46377,"`\n\n```"],[-1,46377,"\r\n\r"],[-1,46439,"\r"],[-1,46454,"\r"],[-1,46498,"\r"],[-1,46581,"\r"],[-1,46583,"\r"],[-1,46623,"\r"],[-1,46707,"\r"],[-1,46791,"\r"],[-1,46806,"\r"],[-1,46839,"\r"],[-1,46890,"\r"],[-1,46934,"\r"],[-1,46982,"\r"],[-1,47028,"\r"],[-1,47086,"\r"],[-1,47112,"\r"],[-1,47123,"\r"],[1,47130,"\n\n```\n"],[-1,47130,"\r\n\r"],[1,47140,"`"],[1,47152,"`"],[1,47168,"`"],[1,47216,"`"],[1,47219,"\n\n```"],[-1,47219,"\r\n\r"],[-1,47283,"\r"],[-1,47352,"\r"],[-1,47354,"\r"],[-1,47383,"\r"],[-1,47409,"\r"],[-1,47427,"\r"],[-1,47494,"\r"],[-1,47505,"\r"],[1,47512,"\n\n```\n"],[-1,47512,"\r"],[1,47630,"**"],[1,47711,"**"],[-1,47712,"\r"],[-1,47714,"\r"],[1,47716,"##### "],[1,47718,"\n"],[-1,47718,"\r"],[-1,47763,"\r"],[-1,47765,"\r"],[1,47767,"*   **"],[1,47772,"**\n\n```"],[-1,47772,"\r"],[-1,47782,"\r"],[-1,47831,"\r"],[-1,47882,"\r"],[-1,47927,"\r"],[-1,47978,"\r"],[-1,48026,"\r"],[-1,48087,"\r"],[-1,48151,"\r"],[-1,48204,"\r"],[-1,48244,"\r"],[-1,48246,"\r"],[-1,48262,"\r"],[-1,48295,"\r"],[-1,48320,"\r"],[-1,48357,"\r"],[-1,48382,"\r"],[1,48408,"\n\n```\n"],[-1,48408,"\r"],[1,48422,"`"],[1,48430,"`"],[1,48434,"`"],[1,48441,"`"],[1,48455,"`"],[1,48493,"`"],[-1,48503,"\r"],[1,48526,"`"],[1,48542,"`"],[1,48559,"`"],[1,48569,"`"],[1,48586,"`"],[1,48598,"`"],[1,48700,"\n\n```"],[-1,48700,"\r\n\r"],[-1,48734,"\r"],[-1,48798,"\r"],[-1,48813,"\r"],[-1,48854,"\r"],[-1,48856,"\r"],[-1,48863,"\r"],[-1,48865,"\r"],[-1,48880,"\r"],[-1,48941,"\r"],[-1,48988,"\r"],[-1,48995,"\r"],[-1,48997,"\r"],[-1,49012,"\r"],[-1,49062,"\r"],[-1,49107,"\r"],[-1,49114,"\r"],[1,49117,"\n\n```\n"],[-1,49117,"\r\n\r"],[1,49135,"`"],[1,49150,"`"],[1,49167,"\n\n```"],[-1,49167,"\r\n\r"],[-1,49276,"\r"],[1,49370,"\n\n```\n\n*   **"],[-1,49370,"\r\n"],[1,49379,"**\n\n```"],[-1,49379,"\r"],[1,49450,"\n\n```\n"],[-1,49450,"\r"],[1,49464,"`"],[1,49474,"`"],[-1,49498,"\r"],[-1,49500,"\r"],[1,49502,"*   **"],[1,49515,"**\n"],[-1,49515,"\r"],[1,49529,"\n\n```"],[-1,49529,"\r\n\r"],[-1,49564,"\r"],[-1,49611,"\r"],[-1,49641,"\r"],[-1,49663,"\r"],[-1,49670,"\r"],[-1,49672,"\r\n\r"],[-1,49689,"\r"],[-1,49765,"\r"],[-1,49824,"\r"],[-1,49882,"\r"],[-1,49908,"\r"],[-1,49915,"\r"],[-1,49917,"\r"],[1,49920,"\n\n```\n"],[-1,49920,"\r"],[1,49931,"\n\n```"],[-1,49931,"\r\n\r"],[1,50025,"\n\n```\n\n*   **"],[-1,50025,"\r\n"],[1,50034,"**\n\n```"],[-1,50034,"\r"],[-1,50049,"\r"],[-1,50099,"\r"],[-1,50187,"\r"],[-1,50229,"\r"],[-1,50231,"\r"],[-1,50248,"\r"],[-1,50371,"\r"],[1,50460,"\n\n```\n\n*   **"],[-1,50460,"\r\n"],[1,50466,"**\n"],[-1,50466,"\r"],[-1,50496,"\r"],[1,50526,"\n\n```"],[-1,50526,"\r\n\r"],[-1,50551,"\r"],[-1,50602,"\r"],[-1,50637,"\r"],[-1,50640,"\r"],[-1,50642,"\r"],[-1,50651,"\r"],[-1,50699,"\r"],[-1,50756,"\r"],[-1,50758,"\r"],[-1,50773,"\r"],[-1,50816,"\r"],[-1,50846,"\r"],[-1,50853,"\r"],[-1,50855,"\r"],[-1,50870,"\r"],[-1,50911,"\r"],[-1,50913,"\r"],[-1,50920,"\r"],[1,50923,"\n\n```\n"],[-1,50923,"\r"],[1,50929,"\n\n```"],[-1,50929,"\r\n\r"],[-1,50941,"\r"],[-1,51025,"\r"],[-1,51035,"\r"],[1,51140,"\n\n```\n\n*   **"],[-1,51140,"\r\n"],[1,51147,"**\n\n![](//upload-images.jianshu.io/upload_images/5994347-767a114aa4746c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n"],[-1,51147,"\r\n\r"],[-1,51303,"\r"],[-1,51305,"\r"],[1,51307,"##### "],[1,51309,"\n"],[-1,51309,"\r"],[-1,51409,"\r"],[-1,51411,"\r"],[1,51413,"**"],[1,51442,"**\n"],[-1,51442,"\r\n\r"],[-1,51459,"\r"],[-1,51461,"\r"],[1,51467,"\n\n["],[-1,51467,"\r\n "],[1,51481,"](/nb/12473806)\n\n"],[-1,51481," "],[1,51492,"\n\n"],[-1,51492," "],[-1,51497,"\r"],[1,51499,"\n[![96](//upload.jianshu.io/users/upload_avatars/5994347/dd34592b-ad62-4e24-bb66-f7c689766b2f.png?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96) ](/u/d65e2e163603) "],[1,51501," ["],[1,51509,"](/u/d65e2e163603)\n"],[-1,51509,"\r"],[-1,51541,"\r"],[-1,51543,"\r"],[1,51547,"\n\n12\n\n[](javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f='http://v.t.sina.com.cn/share/share.php?appkey=1881139527',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function%20a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,'','','', '推荐 @龍儱滝 的文章《阿里ARouter使用及源码解析（一）》（ 分享自 @简书 ）','https://www.jianshu.com/p/46d174f37e82?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo','页面编码gb2312|utf-8默认gb2312'));)[](http://cwb.assets.jianshu.io/notes/images/13526520/weibo/image_bcbd18a5f866.png)["],[-1,51547," 12    "],[1,51558,"](javascript:void(0);)\n\n![](//upload.jianshu.io/users/upload_avatars/1786025/f63ccf82f6f8?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114) \n"],[-1,51558,"\r\n\r"],[1,51572,"关闭评论\n\n"],[1,51587,"\n\n[![](//cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/ab7bfd384c72)\n\n["],[-1,51587,"\r\n "],[1,51599,"](/u/ab7bfd384c72)\n"],[-1,51599,"\r"],[1,51622,"\n"],[-1,51622,"\r"],[-1,51631,"\r"],[-1,51633,"\r"],[-1,51639," "],[1,51642," 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/426662/e85a4080db83?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/a2a56d463e3d)\n\n[夏鸣浩](/u/a2a56d463e3d)\n"],[-1,51642,"\r\n 夏鸣浩\r"],[1,51671,"\n"],[-1,51671,"\r"],[-1,51682,"\r"],[-1,51684,"\r"],[-1,51688," "],[1,51691," 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/7293029/42130be5-9eb3-4cf2-8874-1f32e70d81e2?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/df76f81fe3ff)\n\n["],[-1,51691,"\r\n "],[1,51700,"](/u/df76f81fe3ff)\n"],[-1,51700,"\r"],[1,51723,"\n"],[-1,51723,"\r"],[-1,51732,"\r"],[-1,51734,"\r"],[-1,51738," "],[1,51741," 举报\n"],[-1,51741,"\r\n\r"],[-1,51756,"\r"],[-1,51799,"\r"],[-1,51806,"\r"]],[51842,51842],[0,54215]]],[1519699556056,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,92,"\r"],[1,93,"\r"],[-1,94,"*   "],[1,134,"\r"],[-1,135,"*   "],[1,174,"\r"],[-1,175,"*   "],[1,219,"\r"],[-1,220,"*   "],[1,275,"\r"],[-1,276,"*   "],[-1,306,"\n"],[1,307,"\r"],[-1,312,"["],[-1,320,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)"],[-1,482,"["],[-1,512,"](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)"],[1,584,"\r"],[1,585,"\r"],[1,600,"\r"],[1,601,"\r"],[-1,602,"*   ["],[-1,626,"](https://www.jianshu.com/p/46d174f37e82)\n*   ["],[1,673,"\r\n"],[-1,695,"](https://www.jianshu.com/p/c8d7b1379c1b)\n*   "],[1,741,"\r\n"],[-1,766,"\n\n##### "],[1,774,"\r\n"],[-1,780,"\n"],[1,781,"\r"],[-1,791,"\n\n```"],[1,796,"\r\n\r"],[1,806,"\r"],[1,826,"\r"],[1,834,"\r"],[1,859,"\r"],[1,896,"\r"],[1,951,"\r"],[1,961,"\r"],[1,967,"\r"],[1,973,"\r"],[1,975,"\r"],[1,976,"\r"],[1,991,"\r"],[1,1037,"\r"],[1,1100,"\r"],[1,1108,"\r"],[-1,1110,"\n\n```\n"],[1,1116,"\r"],[-1,1123,"\n\n```"],[1,1128,"\r\n\r"],[1,1149,"\r"],[1,1178,"\r"],[1,1207,"\r"],[1,1261,"\r"],[1,1262,"\r"],[1,1276,"\r"],[1,1343,"\r"],[1,1387,"\r"],[1,1436,"\r"],[1,1442,"\r"],[-1,1444,"\n\n```\n"],[1,1450,"\r"],[-1,1459,"\n\n```"],[1,1464,"\r\n\r"],[1,1550,"\r"],[1,1580,"\r"],[1,1594,"\r"],[1,1651,"\r"],[1,1695,"\r"],[1,1743,"\r"],[1,1792,"\r"],[1,1841,"\r"],[1,1842,"\r"],[1,1881,"\r"],[1,1920,"\r"],[1,1926,"\r"],[1,1927,"\r"],[1,1941,"\r"],[1,1975,"\r"],[1,2013,"\r"],[1,2088,"\r"],[1,2144,"\r"],[1,2177,"\r"],[1,2248,"\r"],[1,2258,"\r"],[1,2264,"\r"],[-1,2266,"\n\n```\n"],[1,2272,"\r"],[-1,2281,"\n\n```"],[1,2286,"\r\n\r"],[1,2372,"\r"],[1,2402,"\r"],[1,2416,"\r"],[1,2473,"\r"],[1,2517,"\r"],[1,2565,"\r"],[1,2614,"\r"],[1,2663,"\r"],[1,2664,"\r"],[1,2703,"\r"],[1,2742,"\r"],[1,2748,"\r"],[1,2749,"\r"],[1,2763,"\r"],[1,2797,"\r"],[1,2835,"\r"],[1,2852,"\r"],[1,2896,"\r"],[1,2965,"\r"],[1,2975,"\r"],[1,2981,"\r"],[-1,2983,"\n\n```\n"],[1,2989,"\r"],[1,3033,"\r"],[1,3034,"\r"],[-1,3035,"##### "],[-1,3045,"\n\n###### "],[1,3054,"\r\n"],[-1,3068,"\n"],[1,3069,"\r"],[-1,3111,"["],[-1,3130,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)"],[-1,3235,"["],[-1,3252,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n"],[1,3346,"\r\n\r"],[-1,3352,"`"],[-1,3359,"`"],[-1,3366,"\n\n```"],[1,3371,"\r\n\r"],[1,3399,"\r"],[1,3433,"\r"],[1,3459,"\r"],[1,3460,"\r"],[1,3468,"\r"],[1,3489,"\r"],[1,3497,"\r"],[1,3516,"\r"],[1,3517,"\r"],[1,3525,"\r"],[1,3553,"\r"],[1,3561,"\r"],[1,3592,"\r"],[1,3593,"\r"],[1,3601,"\r"],[1,3630,"\r"],[1,3638,"\r"],[1,3677,"\r"],[1,3678,"\r"],[1,3686,"\r"],[1,3716,"\r"],[1,3724,"\r"],[1,3768,"\r"],[1,3769,"\r"],[1,3777,"\r"],[1,3791,"\r"],[1,3799,"\r"],[1,3830,"\r"],[-1,3832,"\n\n```\n"],[1,3838,"\r"],[-1,3846,"`"],[-1,3852,"`"],[-1,4007,"`"],[-1,4013,"`"],[1,4039,"\r"],[-1,4066,"`"],[-1,4075,"`"],[-1,4091,"`"],[-1,4098,"`"],[1,4129,"\r"],[1,4130,"\r"],[-1,4160,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n"],[1,4287,"\r\n\r\n\r"],[-1,4303,"`"],[-1,4318,"`"],[-1,4340,"["],[-1,4377,"](https://www.jianshu.com/p/07ef8ba80562)"],[-1,4426,"**"],[-1,4436,"**"],[-1,4449,"`"],[-1,4464,"`"],[-1,4476,"\n\n```"],[1,4481,"\r\n\r"],[1,4495,"\r"],[1,4591,"\r"],[1,4617,"\r"],[1,4672,"\r"],[1,4724,"\r"],[1,4823,"\r"],[1,4841,"\r"],[1,4904,"\r"],[1,4941,"\r"],[1,4990,"\r"],[1,4991,"\r"],[1,5027,"\r"],[1,5060,"\r"],[1,5074,"\r"],[1,5099,"\r"],[1,5109,"\r"],[1,5110,"\r"],[1,5132,"\r"],[-1,5138,"\n\n```\n\n`"],[1,5146,"\r\n"],[-1,5155,"`"],[-1,5168,"`"],[-1,5175,"`"],[-1,5210,"`"],[-1,5225,"`"],[-1,5230,"`"],[-1,5244,"`"],[-1,5253,"`"],[-1,5260,"`"],[1,5300,"\r"],[1,5301,"\r"],[-1,5302,"*   "],[-1,5325,"\n\n```"],[1,5330,"\r"],[1,5386,"\r"],[1,5398,"\r"],[1,5473,"\r"],[1,5525,"\r"],[1,5529,"\r"],[-1,5531,"\n\n```\n\n*   "],[1,5542,"\r\n"],[-1,5563,"\n\n```"],[1,5568,"\r"],[1,5627,"\r"],[1,5639,"\r"],[1,5694,"\r"],[1,5828,"\r"],[1,5832,"\r"],[-1,5834,"\n\n```\n\n*   "],[1,5845,"\r\n"],[-1,5869,"\n\n```"],[1,5874,"\r"],[1,5939,"\r"],[1,5951,"\r"],[1,6010,"\r"],[1,6014,"\r"],[-1,6016,"\n\n```\n"],[1,6022,"\r"],[1,6041,"\r"],[1,6042,"\r"],[-1,6064,"\n\n```"],[1,6069,"\r\n\r"],[1,6154,"\r"],[1,6211,"\r"],[1,6212,"          \r"],[1,6299,"\r"],[1,6300,"\r"],[1,6329,"\r"],[1,6368,"\r"],[1,6445,"\r"],[1,6473,"\r"],[1,6551,"\r"],[1,6626,"\r"],[1,6654,"\r"],[1,6730,"\r"],[1,6806,"\r"],[1,6886,"\r"],[1,6974,"\r"],[1,7066,"\r"],[1,7067,"\r"],[1,7183,"\r"],[1,7215,"\r"],[1,7300,"\r"],[1,7417,"\r"],[1,7452,"\r"],[1,7543,"\r"],[1,7581,"\r"],[1,7649,"\r"],[1,7717,"\r"],[1,7718,"\r"],[1,7764,"\r"],[1,7779,"\r"],[1,7869,"\r"],[1,7885,"\r"],[1,7967,"\r"],[1,8013,"\r"],[1,8062,"\r"],[1,8109,"\r"],[1,8165,"\r"],[1,8253,"\r"],[1,8275,"\r"],[1,8290,"\r"],[1,8291,"\r"],[1,8306,"\r"],[1,8401,"\r"],[1,8417,"\r"],[1,8500,"\r"],[1,8546,"\r"],[1,8595,"\r"],[1,8646,"\r"],[1,8661,"\r"],[1,8662,"\r"],[1,8677,"\r"],[1,8698,"\r"],[1,8714,"\r"],[1,8805,"\r"],[1,8908,"\r"],[1,8979,"\r"],[1,9083,"\r"],[1,9163,"\r"],[1,9276,"\r"],[1,9277,"\r\n          \r"],[1,9293,"\r"],[1,9303,"\r"],[-1,9309,"\n\n```\n"],[1,9315,"\r"],[-1,9347,"\n\n```"],[1,9352,"\r\n\r"],[1,9437,"\r"],[1,9494,"\r"],[1,9515,"\r"],[1,9516,"\r"],[1,9531,"\r"],[1,9584,"\r"],[1,9608,"\r"],[1,9696,"\r"],[1,9712,"\r"],[1,9816,"\r"],[1,9867,"\r"],[1,9909,"\r"],[1,9959,"\r"],[1,9960,"\r"],[1,9993,"\r"],[1,10045,"\r"],[1,10095,"\r"],[1,10161,"\r"],[1,10205,"\r"],[1,10206,"                \r"],[1,10286,"\r"],[1,10384,"\r"],[1,10472,"\r"],[1,10473,"\r"],[1,10529,"\r"],[1,10577,"\r"],[1,10648,"\r"],[1,10722,"\r"],[1,10877,"\r"],[1,10974,"\r"],[1,11064,"\r"],[1,11245,"\r"],[1,11271,"\r"],[1,11293,"\r"],[1,11329,"\r"],[1,11424,"\r"],[1,11509,"\r"],[1,11597,"\r"],[1,11656,"\r"],[1,11743,"\r"],[1,11832,"\r"],[1,11929,"\r"],[1,12016,"\r"],[1,12051,"\r"],[1,12146,"\r"],[1,12245,"\r"],[1,12333,"\r"],[1,12367,"\r"],[1,12463,"\r"],[1,12481,"\r"],[1,12482,"                \r"],[1,12572,"\r"],[1,12606,"\r"],[1,12645,"\r"],[1,12646,"          \r"],[1,12660,"\r"],[1,12661,"\r"],[1,12683,"\r"],[1,12693,"\r"],[-1,12699,"\n\n```\n"],[1,12705,"\r"],[-1,12793,"`"],[-1,12803,"`"],[-1,12810,"`"],[-1,12832,"`"],[-1,12844,"`"],[-1,12853,"`"],[1,12857,"\r"],[1,12858,"\r"],[-1,12865,"\n\n```"],[1,12870,"\r\n\r"],[1,12955,"\r"],[1,13012,"\r"],[1,13033,"\r"],[1,13034,"\r"],[1,13050,"\r"],[1,13108,"\r"],[1,13131,"\r"],[1,13202,"\r"],[1,13218,"\r"],[1,13326,"\r"],[1,13377,"\r"],[1,13419,"\r"],[1,13473,"\r"],[1,13474,"\r"],[1,13508,"\r"],[1,13571,"\r"],[1,13653,"\r"],[1,13704,"\r"],[1,13722,"\r"],[1,13778,"\r"],[1,13805,"\r"],[1,13876,"\r"],[1,13892,"\r"],[1,14001,"\r"],[1,14056,"\r"],[1,14102,"\r"],[1,14157,"\r"],[1,14158,"\r"],[1,14193,"\r"],[1,14254,"\r"],[1,14285,"\r"],[1,14341,"\r"],[1,14392,"\r"],[1,14435,"\r"],[1,14476,"\r"],[1,14518,"\r"],[1,14642,"\r"],[1,14705,"\r"],[1,14822,"\r"],[1,14928,"\r"],[1,15008,"\r"],[1,15090,"\r"],[1,15284,"\r"],[1,15376,"\r"],[1,15433,"\r"],[1,15490,"\r"],[1,15587,"\r"],[1,15652,"\r"],[1,15719,"\r"],[1,15796,"\r"],[1,15907,"\r"],[1,15989,"\r"],[1,16183,"\r"],[1,16262,"\r"],[1,16319,"\r"],[1,16376,"\r"],[1,16473,"\r"],[1,16538,"\r"],[1,16605,"\r"],[1,16639,"\r"],[1,16680,"\r"],[1,16852,"\r"],[1,16882,"\r"],[1,16917,"\r"],[1,16950,"\r"],[1,16985,"\r"],[1,17007,"\r"],[1,17008,"\r"],[1,17062,"\r"],[1,17134,"\r"],[1,17182,"\r"],[1,17263,"\r"],[1,17322,"\r"],[1,17411,"\r"],[1,17549,"\r"],[1,17575,"\r"],[1,17597,"\r"],[1,17661,"\r"],[1,17662,"                    \r"],[1,17724,"\r"],[1,17764,"\r"],[1,17827,"\r"],[1,18126,"\r"],[1,18175,"\r"],[1,18216,"\r"],[1,18257,"\r"],[1,18338,"\r"],[1,18401,"\r"],[1,18466,"\r"],[1,18484,"\r"],[1,18485,"\r"],[1,18538,"\r"],[1,18590,"\r"],[1,18671,"\r"],[1,18737,"\r"],[1,18796,"\r"],[1,18857,"\r"],[1,18915,"\r"],[1,18999,"\r"],[1,19053,"\r"],[1,19134,"\r"],[1,19175,"\r"],[1,19218,"\r"],[1,19219,"\r"],[1,19293,"\r"],[1,19361,"\r"],[1,19416,"\r"],[1,19430,"\r"],[1,19431,"\r"],[1,19448,"\r"],[1,19458,"\r"],[-1,19464,"\n\n```\n"],[1,19470,"\r"],[1,19483,"\r"],[1,19484,"\r"],[-1,19485,"*   "],[-1,19491,"`"],[-1,19500,"`"],[-1,19526,"`"],[-1,19537,"`"],[-1,19627,"`"],[-1,19635,"`"],[-1,19652,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n"],[1,19779,"\r"],[-1,19786,"\n"],[1,19787,"\r"],[-1,19793,"`"],[-1,19804,"`"],[-1,19817,"`"],[-1,19825,"`"],[-1,19833,"\n\n```"],[1,19838,"\r\n\r"],[1,19897,"\r"],[1,19909,"\r"],[1,19964,"\r"],[1,19993,"\r"],[1,20238,"\r"],[1,20248,"\r"],[1,20276,"\r"],[1,20418,"\r"],[1,20427,"\r"],[1,20431,"\r"],[-1,20433,"\n\n```\n\n*   "],[1,20444,"\r\n"],[-1,20509,"`"],[-1,20520,"`"],[-1,20568,"`"],[-1,20579,"`"],[-1,20606,"\n\n```"],[1,20611,"\r"],[1,20676,"\r"],[1,20688,"\r"],[1,20747,"\r"],[1,20940,"\r"],[1,20973,"\r"],[1,21170,"\r"],[1,21202,"\r"],[1,21394,"\r"],[1,21398,"\r"],[-1,21400,"\n\n```\n\n*   "],[1,21411,"\r\n"],[-1,21493,"\n"],[1,21494,"\r"],[-1,21501,"`"],[-1,21515,"`"],[-1,21561,"`"],[-1,21572,"`"],[-1,21626,"\n\n```"],[1,21631,"\r\n\r"],[1,21716,"\r"],[1,21773,"\r"],[1,21794,"\r"],[1,21858,"\r"],[1,21906,"\r"],[1,22032,"\r"],[1,22109,"\r"],[1,22274,"\r"],[1,22292,"\r"],[1,22306,"\r"],[1,22307,"\r"],[1,22349,"\r"],[1,22433,"\r"],[1,22488,"\r"],[1,22551,"\r"],[1,22605,"\r"],[1,22688,"\r"],[1,22738,"\r"],[1,22818,"\r"],[1,22855,"\r"],[1,22894,"\r"],[1,22895,"\r"],[1,22991,"\r"],[1,22992,"\r"],[1,23030,"\r"],[1,23103,"\r"],[1,23158,"\r"],[1,23214,"\r"],[1,23268,"\r"],[1,23372,"\r"],[1,23422,"\r"],[1,23498,"\r"],[1,23535,"\r"],[1,23574,"\r"],[1,23575,"\r"],[1,23656,"\r"],[1,23666,"\r"],[-1,23672,"\n\n```\n"],[1,23678,"\r"],[-1,23684,"`"],[-1,23695,"`"],[-1,23722,"\n\n```"],[1,23727,"\r\n\r"],[1,23783,"\r"],[1,23795,"\r"],[1,23870,"\r"],[1,23928,"\r"],[1,23980,"\r"],[1,23984,"\r"],[-1,23986,"\n\n```\n\n**"],[1,23995,"\r\n"],[-1,24002,"`"],[-1,24016,"`"],[-1,24026,"**\n"],[1,24029,"\r\n\r"],[-1,24038,"`"],[-1,24051,"`"],[-1,24060,"\n\n```"],[1,24065,"\r\n\r"],[1,24115,"\r"],[1,24150,"\r"],[1,24188,"\r"],[1,24315,"\r"],[1,24397,"\r"],[1,24426,"\r"],[1,24502,"\r"],[1,24557,"\r"],[1,24647,"\r"],[1,24677,"\r"],[1,24746,"\r"],[1,24776,"\r"],[1,24849,"\r"],[1,24910,"\r"],[1,24970,"\r"],[1,25008,"\r"],[1,25034,"\r"],[1,25056,"\r"],[1,25076,"\r"],[1,25121,"\r"],[1,25187,"\r"],[1,25208,"\r"],[1,25251,"\r"],[1,25265,"\r"],[1,25282,"\r"],[1,25384,"\r"],[1,25394,"\r"],[1,25400,"\r"],[1,25401,"\r"],[1,25428,"\r"],[1,25475,"\r"],[1,25513,"\r"],[1,25549,"\r"],[1,25667,"\r"],[1,25693,"\r"],[1,25703,"\r"],[1,25704,"\r"],[1,25769,"\r"],[1,25866,"\r"],[1,25884,"\r"],[1,25963,"\r"],[1,26020,"\r"],[1,26054,"\r"],[1,26072,"\r"],[1,26073,"\r"],[1,26118,"\r"],[1,26147,"\r"],[1,26183,"\r"],[1,26267,"\r"],[1,26297,"\r"],[1,26311,"\r"],[1,26321,"\r"],[1,26322,"\r"],[1,26343,"\r"],[-1,26349,"\n\n```\n"],[1,26355,"\r"],[1,26448,"\r"],[1,26449,"\r"],[-1,26454,"`"],[-1,26461,"`"],[1,26546,"\r"],[1,26547,"\r"],[-1,26548,"###### "],[-1,26569,"\n"],[1,26570,"\r"],[-1,26660,"["],[-1,26672,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `"],[1,26767,"\r\n\r\n"],[-1,26774,"`"],[-1,26776,"`"],[-1,26783,"`"],[-1,26786,"\n\n```"],[1,26791,"\r"],[1,26842,"\r"],[1,26866,"\r"],[1,26904,"\r"],[1,26973,"\r"],[1,27023,"\r"],[1,27024,"\r"],[1,27051,"\r"],[1,27089,"\r"],[1,27103,"\r"],[1,27104,"\r"],[1,27172,"\r"],[1,27182,"\r"],[-1,27188,"\n\n```\n"],[1,27194,"\r"],[-1,27216,"`"],[-1,27225,"`"],[-1,27229,"`"],[-1,27237,"`"],[-1,27257,"`"],[-1,27266,"`"],[1,27273,"\r"],[1,27274,"\r"],[-1,27275,"*   `"],[-1,27288,"`"],[-1,27290,"`"],[-1,27297,"`"],[-1,27300,"\n\n```"],[1,27305,"\r"],[1,27377,"\r"],[1,27409,"\r"],[1,27459,"\r"],[1,27517,"\r"],[1,27541,"\r"],[1,27542,"\r"],[1,27563,"\r"],[-1,27569,"\n\n```\n\n`"],[1,27577,"\r\n"],[-1,27585,"`"],[-1,27591,"`"],[-1,27614,"`"],[-1,27633,"`"],[-1,27642,"`"],[-1,27661,"\n\n```"],[1,27666,"\r\n\r"],[1,27774,"\r"],[1,27802,"\r"],[1,27826,"\r"],[1,27827,"\r"],[1,27841,"\r"],[1,27914,"\r"],[1,27959,"\r"],[1,28068,"\r"],[1,28069,"\r"],[1,28112,"\r"],[1,28166,"\r"],[1,28247,"\r"],[1,28354,"\r"],[1,28464,"\r"],[1,28590,"\r"],[1,28712,"\r"],[1,28805,"\r"],[1,28914,"\r"],[1,29053,"\r"],[1,29172,"\r"],[1,29263,"\r"],[1,29331,"\r"],[1,29464,"\r"],[1,29482,"\r"],[1,29496,"\r"],[1,29497,"\r"],[1,29550,"\r"],[1,29650,"\r"],[1,29664,"\r"],[1,29665,"\r"],[1,29705,"\r"],[1,29975,"\r"],[1,29989,"\r"],[1,30021,"\r"],[1,30136,"\r"],[1,30146,"\r"],[-1,30152,"\n\n```\n\n*   `"],[1,30164,"\r\n"],[-1,30172,"`"],[-1,30174,"`"],[-1,30186,"`"],[-1,30189,"\n\n```"],[1,30194,"\r"],[1,30220,"\r"],[1,30272,"\r"],[1,30396,"\r"],[-1,30402,"\n\n```\n"],[1,30408,"\r"],[-1,30436,"`"],[-1,30471,"`"],[-1,30496,"["],[-1,30508,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)"],[-1,30597,"`"],[-1,30608,"`"],[1,30616,"\r"],[-1,30617,"**"],[-1,30715,"**"],[-1,30741,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n"],[1,30868,"\r\n\r\n\r"],[-1,31000,"`"],[-1,31010,"`"],[1,31054,"\r"],[1,31055,"\r"],[-1,31056,"###### "],[-1,31078,"\n"],[1,31079,"\r"],[1,31089,"\r"],[1,31090,"\r"],[-1,31091,"> "],[1,31153,"\r"],[1,31154,"\r"],[1,31209,"\r"],[1,31210,"\r"],[-1,31211,"> "],[1,31223,"\r"],[-1,31224,"> "],[1,31284,"\r"],[1,31285,"\r"],[-1,31286,"> "],[1,31298,"\r"],[-1,31299,"> "],[1,31353,"\r"],[1,31354,"\r"],[-1,31373,"`"],[-1,31395,"`"],[-1,31433,"`"],[-1,31441,"`"],[-1,31443,"`"],[-1,31456,"`"],[1,31458,"\r"],[1,31459,"\r"],[-1,31460,"**"],[-1,31471,"**"],[1,31473,"\r"],[-1,31482,"`"],[-1,31501,"`"],[-1,31503,"`"],[-1,31510,"`"],[-1,31520,"`"],[-1,31529,"`"],[-1,31531,"`"],[-1,31550,"`"],[-1,31554,"\n\n```"],[1,31559,"\r\n\r"],[1,31601,"\r"],[1,31640,"\r"],[1,31718,"\r"],[1,31735,"\r"],[1,31837,"\r"],[1,31873,"\r"],[1,31922,"\r"],[1,31936,"\r"],[1,31988,"\r"],[1,31998,"\r"],[-1,32004,"\n\n```\n"],[1,32010,"\r"],[-1,32013,"`"],[-1,32039,"`"],[-1,32071,"\n\n```"],[1,32076,"\r\n\r"],[1,32121,"\r"],[1,32185,"\r"],[1,32336,"\r"],[1,32346,"\r"],[1,32347,"\r"],[1,32361,"\r"],[1,32417,"\r"],[1,32492,"\r"],[1,32543,"\r"],[1,32668,"\r"],[1,32689,"\r"],[1,32726,"\r"],[1,32740,"\r"],[1,32772,"\r"],[1,32866,"\r"],[1,32891,"\r"],[1,32901,"\r"],[-1,32907,"\n\n```\n\n`"],[1,32915,"\r\n"],[-1,32933,"`"],[-1,32942,"`"],[-1,32975,"`\n\n```"],[1,32981,"\r\n\r"],[1,33039,"\r"],[1,33106,"\r"],[1,33184,"\r"],[1,33201,"\r"],[1,33303,"\r"],[1,33339,"\r"],[1,33388,"\r"],[1,33402,"\r"],[1,33448,"\r"],[1,33458,"\r"],[-1,33464,"\n\n```\n\n**"],[1,33473,"\r\n"],[-1,33481,"`"],[-1,33540,"`"],[-1,33547,"`"],[-1,33566,"`"],[-1,33652,"**"],[1,33654,"\r"],[-1,33658,"`"],[-1,33677,"`"],[-1,33689,"`"],[-1,33701,"`"],[-1,33703,"`"],[-1,33712,"`"],[-1,33740,"\n\n```"],[1,33745,"\r\n\r"],[1,33801,"\r"],[1,33802,"\r"],[1,33810,"\r"],[1,33834,"\r"],[1,33841,"\r"],[1,33869,"\r"],[1,33877,"\r"],[1,33912,"\r"],[1,33913,"\r"],[1,33921,"\r"],[1,33942,"\r"],[1,33949,"\r"],[1,33975,"\r"],[1,33983,"\r"],[1,34008,"\r"],[-1,34010,"\n\n```\n"],[1,34016,"\r\n\r"],[-1,34023,"`"],[-1,34032,"`"],[-1,34061,"`"],[-1,34069,"`"],[-1,34089,"`"],[-1,34098,"`"],[-1,34151,"\n\n```"],[1,34156,"\r\n\r"],[1,34204,"\r"],[1,34225,"\r"],[1,34300,"\r"],[1,34345,"\r"],[1,34399,"\r"],[1,34476,"\r"],[1,34529,"\r"],[1,34563,"\r"],[1,34627,"\r"],[1,34628,"\r"],[1,34641,"\r"],[1,34718,"\r"],[1,34745,"\r"],[1,34771,"\r"],[1,34772,"\r"],[1,34800,"\r"],[1,34846,"\r"],[1,34883,"\r"],[1,34929,"\r"],[1,34971,"\r"],[1,35013,"\r"],[1,35056,"\r"],[1,35100,"\r"],[1,35169,"\r"],[1,35183,"\r"],[-1,35185,"\n\n```\n\n**"],[1,35194,"\r\n"],[-1,35208,"**"],[1,35210,"\r"],[-1,35218,"`"],[-1,35231,"`"],[-1,35250,"`"],[-1,35259,"`"],[-1,35266,"\n\n```"],[1,35271,"\r\n\r"],[1,35411,"\r"],[1,35425,"\r"],[1,35520,"\r"],[1,35570,"\r"],[1,35615,"\r"],[1,35672,"\r"],[1,35673,"\r"],[1,35737,"\r"],[1,35810,"\r"],[1,35877,"\r"],[1,35970,"\r"],[1,35984,"\r"],[1,36033,"\r"],[1,36099,"\r"],[1,36142,"\r"],[1,36178,"\r"],[1,36221,"\r"],[1,36317,"\r"],[1,36421,"\r"],[1,36467,"\r"],[1,36529,"\r"],[1,36547,"\r"],[1,36561,"\r"],[1,36562,"\r"],[1,36587,"\r"],[1,36597,"\r"],[1,36636,"\r"],[1,36668,"\r"],[1,36708,"\r"],[1,36718,"\r"],[1,36719,"        \r"],[1,36782,"\r"],[1,36827,"\r"],[1,36872,"\r"],[1,36957,"\r"],[1,36977,"\r"],[1,37013,"\r"],[1,37032,"\r"],[1,37078,"\r"],[1,37098,"\r"],[1,37124,"\r"],[1,37184,"\r"],[1,37259,"\r"],[1,37277,"\r"],[1,37278,"\r"],[1,37298,"\r"],[1,37386,"\r"],[1,37405,"\r"],[1,37461,"\r"],[1,37481,"\r"],[1,37507,"\r"],[1,37570,"\r"],[1,37614,"\r"],[1,37670,"\r"],[1,37692,"\r"],[1,37693,"\r"],[1,37815,"\r"],[1,37833,"\r"],[1,37849,"\r"],[1,37866,"\r"],[1,37940,"\r"],[1,37950,"\r"],[1,37951,"\r"],[1,37972,"\r"],[1,37978,"\r"],[-1,37979,"\n```\n\n**"],[-1,38023,"`"],[-1,38038,"`"],[-1,38044,"`"],[-1,38053,"`"],[-1,38099,"**"],[-1,38105,"`"],[-1,38120,"`"],[-1,38124,"\n\n```"],[1,38129,"\r\n\r"],[1,38181,"\r"],[1,38182,"\r"],[1,38190,"\r"],[1,38214,"\r"],[1,38221,"\r"],[1,38249,"\r"],[1,38257,"\r"],[1,38310,"\r"],[-1,38312,"\n\n```\n"],[1,38318,"\r\n\r"],[-1,38349,"`"],[-1,38363,"`"],[-1,38372,"\n\n```"],[1,38377,"\r\n\r"],[1,38512,"\r"],[1,38589,"\r"],[1,38590,"\r"],[1,38628,"\r"],[1,38655,"\r"],[1,38704,"\r"],[1,38732,"\r"],[1,38825,"\r"],[1,38848,"\r"],[1,38904,"\r"],[1,38905,"\r"],[1,38936,"\r"],[1,38985,"\r"],[1,39020,"\r"],[1,39064,"\r"],[1,39172,"\r"],[1,39240,"\r"],[1,39258,"\r"],[1,39259,"\r"],[1,39288,"\r"],[1,39362,"\r"],[1,39392,"\r"],[1,39432,"\r"],[1,39472,"\r"],[1,39545,"\r"],[1,39689,"\r"],[1,39722,"\r"],[1,39833,"\r"],[1,39859,"\r"],[1,39860,"\r"],[1,40010,"\r"],[1,40049,"\r"],[1,40181,"\r"],[1,40207,"\r"],[1,40261,"\r"],[1,40329,"\r"],[1,40387,"\r"],[1,40413,"\r"],[1,40435,"\r"],[1,40455,"\r"],[1,40456,"\r"],[1,40479,"\r"],[1,40506,"\r"],[1,40553,"\r"],[1,40581,"\r"],[1,40616,"\r"],[1,40643,"\r"],[1,40707,"\r"],[1,40729,"\r"],[1,40770,"\r"],[1,40853,"\r"],[1,40909,"\r"],[1,40991,"\r"],[1,41077,"\r"],[1,41182,"\r"],[1,41204,"\r"],[1,41205,"\r"],[1,41242,"\r"],[1,41283,"\r"],[1,41413,"\r"],[1,41431,"\r"],[1,41456,"\r"],[1,41482,"\r"],[1,41503,"\r"],[1,41532,"\r"],[1,41542,"\r"],[1,41543,"\r"],[1,41564,"\r"],[-1,41570,"\n\n```\n"],[1,41576,"\r"],[-1,41664,"`"],[-1,41677,"`"],[-1,41688,"`"],[-1,41704,"`"],[-1,41706,"`"],[-1,41736,"`。\n\n```"],[1,41743,"。\r\n\r"],[1,41811,"\r"],[1,41843,"\r"],[1,41910,"\r"],[1,41920,"\r"],[1,41921,"      \r"],[1,41962,"\r"],[1,42034,"\r"],[1,42070,"\r"],[1,42128,"\r"],[1,42231,"\r"],[1,42254,"\r"],[1,42291,"\r"],[1,42451,"\r"],[1,42472,"\r"],[1,42552,"\r"],[1,42574,"\r"],[1,42622,"\r"],[1,42792,"\r"],[1,42814,"\r"],[1,42895,"\r"],[1,42986,"\r"],[1,43049,"\r"],[1,43095,"\r"],[1,43166,"\r"],[1,43167,"\r"],[1,43215,"\r"],[1,43394,"\r"],[1,43416,"\r"],[1,43456,"\r"],[1,43579,"\r"],[1,43597,"\r"],[1,43656,"\r"],[1,43706,"\r"],[1,43720,"\r"],[1,43737,"\r"],[1,43815,"\r"],[1,43876,"\r"],[1,43941,"\r"],[1,43992,"\r"],[1,44051,"\r"],[1,44104,"\r"],[1,44105,"\r"],[1,44168,"\r"],[1,44212,"\r"],[1,44248,"\r"],[1,44305,"\r"],[1,44393,"\r"],[1,44470,"\r"],[1,44471,"\r"],[1,44526,"\r"],[1,44615,"\r"],[1,44701,"\r"],[1,44744,"\r"],[1,44795,"\r"],[1,44844,"\r"],[1,44909,"\r"],[1,44931,"\r"],[1,44932,"\r"],[1,44995,"\r"],[1,45118,"\r"],[1,45136,"\r"],[1,45137,"\r"],[1,45169,"\r"],[1,45242,"\r"],[1,45256,"\r"],[1,45257,"            \r"],[1,45305,"\r"],[1,45348,"\r"],[1,45381,"\r"],[1,45472,"\r"],[1,45523,"\r"],[1,45642,"\r"],[1,45722,"\r"],[1,45806,"\r"],[1,45850,"\r"],[1,45880,"\r"],[1,45964,"\r"],[1,46017,"\r"],[1,46094,"\r"],[1,46143,"\r"],[1,46191,"\r"],[1,46290,"\r"],[1,46316,"\r"],[1,46338,"\r"],[1,46390,"\r"],[1,46482,"\r"],[1,46509,"\r"],[1,46540,"\r"],[1,46621,"\r"],[1,46646,"\r"],[1,46673,"\r"],[1,46687,"\r"],[1,46697,"\r"],[-1,46703,"\n\n```\n"],[1,46709,"\r"],[-1,46819,"`"],[-1,46828,"`"],[-1,46830,"`"],[-1,46869,"`\n\n```"],[1,46875,"\r\n\r"],[1,46934,"\r"],[1,46948,"\r"],[1,46991,"\r"],[1,47073,"\r"],[1,47074,"\r"],[1,47113,"\r"],[1,47196,"\r"],[1,47279,"\r"],[1,47293,"\r"],[1,47325,"\r"],[1,47375,"\r"],[1,47418,"\r"],[1,47465,"\r"],[1,47510,"\r"],[1,47567,"\r"],[1,47592,"\r"],[1,47602,"\r"],[-1,47608,"\n\n```\n"],[1,47614,"\r\n\r"],[-1,47621,"`"],[-1,47634,"`"],[-1,47651,"`"],[-1,47700,"`"],[-1,47704,"\n\n```"],[1,47709,"\r\n\r"],[1,47770,"\r"],[1,47838,"\r"],[1,47839,"\r"],[1,47867,"\r"],[1,47892,"\r"],[1,47909,"\r"],[1,47975,"\r"],[1,47985,"\r"],[-1,47991,"\n\n```\n"],[1,47997,"\r"],[-1,48114,"**"],[-1,48197,"**"],[1,48200,"\r"],[1,48201,"\r"],[-1,48202,"##### "],[-1,48210,"\n"],[1,48211,"\r"],[1,48255,"\r"],[1,48256,"\r"],[-1,48257,"*   **"],[-1,48268,"**\n\n```"],[1,48275,"\r"],[1,48284,"\r"],[1,48332,"\r"],[1,48382,"\r"],[1,48426,"\r"],[1,48476,"\r"],[1,48523,"\r"],[1,48583,"\r"],[1,48646,"\r"],[1,48698,"\r"],[1,48737,"\r"],[1,48738,"\r"],[1,48753,"\r"],[1,48785,"\r"],[1,48809,"\r"],[1,48845,"\r"],[1,48869,"\r"],[-1,48894,"\n\n```\n"],[1,48900,"\r"],[-1,48913,"`"],[-1,48922,"`"],[-1,48927,"`"],[-1,48935,"`"],[-1,48950,"`"],[-1,48989,"`"],[1,49000,"\r"],[-1,49022,"`"],[-1,49039,"`"],[-1,49057,"`"],[-1,49068,"`"],[-1,49086,"`"],[-1,49099,"`"],[-1,49202,"\n\n```"],[1,49207,"\r\n\r"],[1,49238,"\r"],[1,49301,"\r"],[1,49315,"\r"],[1,49355,"\r"],[1,49356,"\r"],[1,49362,"\r"],[1,49363,"\r"],[1,49377,"\r"],[1,49437,"\r"],[1,49483,"\r"],[1,49489,"\r"],[1,49490,"\r"],[1,49504,"\r"],[1,49553,"\r"],[1,49597,"\r"],[1,49603,"\r"],[-1,49605,"\n\n```\n"],[1,49611,"\r\n\r"],[-1,49626,"`"],[-1,49642,"`"],[-1,49660,"\n\n```"],[1,49665,"\r\n\r"],[1,49771,"\r"],[-1,49864,"\n\n```\n\n*   **"],[1,49877,"\r\n"],[-1,49884,"**\n\n```"],[1,49891,"\r"],[-1,49961,"\n\n```\n"],[1,49967,"\r"],[-1,49980,"`"],[-1,49991,"`"],[1,50016,"\r"],[1,50017,"\r"],[-1,50018,"*   **"],[-1,50037,"**\n"],[1,50040,"\r"],[-1,50053,"\n\n```"],[1,50058,"\r\n\r"],[1,50090,"\r"],[1,50136,"\r"],[1,50165,"\r"],[1,50186,"\r"],[1,50192,"\r"],[1,50193,"\r\n\r"],[1,50207,"\r"],[1,50282,"\r"],[1,50340,"\r"],[1,50397,"\r"],[1,50422,"\r"],[1,50428,"\r"],[1,50429,"\r"],[-1,50431,"\n\n```\n"],[1,50437,"\r"],[-1,50447,"\n\n```"],[1,50452,"\r\n\r"],[-1,50543,"\n\n```\n\n*   **"],[1,50556,"\r\n"],[-1,50563,"**\n\n```"],[1,50570,"\r"],[1,50584,"\r"],[1,50633,"\r"],[1,50720,"\r"],[1,50761,"\r"],[1,50762,"\r"],[1,50778,"\r"],[1,50900,"\r"],[-1,50988,"\n\n```\n\n*   **"],[1,51001,"\r\n"],[-1,51005,"**\n"],[1,51008,"\r"],[1,51037,"\r"],[-1,51066,"\n\n```"],[1,51071,"\r\n\r"],[1,51093,"\r"],[1,51143,"\r"],[1,51177,"\r"],[1,51179,"\r"],[1,51180,"\r"],[1,51188,"\r"],[1,51235,"\r"],[1,51291,"\r"],[1,51292,"\r"],[1,51306,"\r"],[1,51348,"\r"],[1,51377,"\r"],[1,51383,"\r"],[1,51384,"\r"],[1,51398,"\r"],[1,51438,"\r"],[1,51439,"\r"],[1,51445,"\r"],[-1,51447,"\n\n```\n"],[1,51453,"\r"],[-1,51458,"\n\n```"],[1,51463,"\r\n\r"],[1,51472,"\r"],[1,51555,"\r"],[1,51564,"\r"],[-1,51668,"\n\n```\n\n*   **"],[1,51681,"\r\n"],[-1,51686,"**\n\n![](//upload-images.jianshu.io/upload_images/5994347-767a114aa4746c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n"],[1,51815,"\r\n\r"],[1,51968,"\r"],[1,51969,"\r"],[-1,51970,"##### "],[-1,51978,"\n"],[1,51979,"\r"],[1,52078,"\r"],[1,52079,"\r"],[-1,52080,"**"],[-1,52111,"**\n"],[1,52114,"\r\n\r"],[1,52128,"\r"],[1,52129,"\r"],[-1,52134,"\n\n["],[1,52137,"\r\n "],[-1,52148,"](/nb/12473806)\n\n"],[1,52165," "],[-1,52175,"\n\n"],[1,52177," "],[1,52181,"\r"],[-1,52182,"\n[![96](//upload.jianshu.io/users/upload_avatars/5994347/dd34592b-ad62-4e24-bb66-f7c689766b2f.png?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96) ](/u/d65e2e163603) "],[-1,52354," ["],[-1,52364,"](/u/d65e2e163603)\n"],[1,52383,"\r"],[1,52414,"\r"],[1,52415,"\r"],[-1,52418,"\n\n12\n\n[](javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f='http://v.t.sina.com.cn/share/share.php?appkey=1881139527',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function%20a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,'','','', '推荐 @龍儱滝 的文章《阿里ARouter使用及源码解析（一）》（ 分享自 @简书 ）','https://www.jianshu.com/p/46d174f37e82?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo','页面编码gb2312|utf-8默认gb2312'));)[](http://cwb.assets.jianshu.io/notes/images/13526520/weibo/image_bcbd18a5f866.png)["],[1,53265," 12    "],[-1,53269,"](javascript:void(0);)\n\n![](//upload.jianshu.io/users/upload_avatars/1786025/f63ccf82f6f8?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114) \n"],[1,53415,"\r\n\r"],[-1,53426,"关闭评论\n\n"],[-1,53447,"\n\n[![](//cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/ab7bfd384c72)\n\n["],[1,53609,"\r\n "],[-1,53618,"](/u/ab7bfd384c72)\n"],[1,53637,"\r"],[-1,53659,"\n"],[1,53660,"\r"],[1,53668,"\r"],[1,53669,"\r"],[1,53674," "],[-1,53676," 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/426662/e85a4080db83?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/a2a56d463e3d)\n\n[夏鸣浩](/u/a2a56d463e3d)\n"],[1,53844,"\r\n 夏鸣浩\r"],[-1,53866,"\n"],[1,53867,"\r"],[1,53877,"\r"],[1,53878,"\r"],[1,53881," "],[-1,53883," 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/7293029/42130be5-9eb3-4cf2-8874-1f32e70d81e2?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/df76f81fe3ff)\n\n["],[1,54054,"\r\n "],[-1,54060,"](/u/df76f81fe3ff)\n"],[1,54079,"\r"],[-1,54101,"\n"],[1,54102,"\r"],[1,54110,"\r"],[1,54111,"\r"],[1,54114," "],[-1,54116," 举报\n"],[1,54120,"\r\n\r"],[1,54132,"\r"],[1,54174,"\r"],[1,54180,"\r"]],[0,54215],[51842,51842]]],[1519699557959,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,92,"\r"],[-1,94,"\r"],[1,96,"*   "],[-1,132,"\r"],[1,134,"*   "],[-1,169,"\r"],[1,171,"*   "],[-1,211,"\r"],[1,213,"*   "],[-1,264,"\r"],[1,266,"*   "],[1,292,"\n"],[-1,292,"\r"],[1,298,"["],[1,305,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)"],[1,403,"["],[1,432,"](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)"],[-1,433,"\r"],[-1,435,"\r"],[-1,451,"\r"],[-1,453,"\r"],[1,455,"*   ["],[1,474,"](https://www.jianshu.com/p/46d174f37e82)\n*   ["],[-1,474,"\r\n"],[1,498,"](https://www.jianshu.com/p/c8d7b1379c1b)\n*   "],[-1,498,"\r\n"],[1,525,"\n\n##### "],[-1,525,"\r\n"],[1,533,"\n"],[-1,533,"\r"],[1,544,"\n\n```"],[-1,544,"\r\n\r"],[-1,557,"\r"],[-1,578,"\r"],[-1,587,"\r"],[-1,613,"\r"],[-1,651,"\r"],[-1,707,"\r"],[-1,718,"\r"],[-1,725,"\r"],[-1,732,"\r"],[-1,735,"\r"],[-1,737,"\r"],[-1,753,"\r"],[-1,800,"\r"],[-1,864,"\r"],[-1,873,"\r"],[1,876,"\n\n```\n"],[-1,876,"\r"],[1,884,"\n\n```"],[-1,884,"\r\n\r"],[-1,908,"\r"],[-1,938,"\r"],[-1,968,"\r"],[-1,1023,"\r"],[-1,1025,"\r"],[-1,1040,"\r"],[-1,1108,"\r"],[-1,1153,"\r"],[-1,1203,"\r"],[-1,1210,"\r"],[1,1213,"\n\n```\n"],[-1,1213,"\r"],[1,1223,"\n\n```"],[-1,1223,"\r\n\r"],[-1,1312,"\r"],[-1,1343,"\r"],[-1,1358,"\r"],[-1,1416,"\r"],[-1,1461,"\r"],[-1,1510,"\r"],[-1,1560,"\r"],[-1,1610,"\r"],[-1,1612,"\r"],[-1,1652,"\r"],[-1,1692,"\r"],[-1,1699,"\r"],[-1,1701,"\r"],[-1,1716,"\r"],[-1,1751,"\r"],[-1,1790,"\r"],[-1,1866,"\r"],[-1,1923,"\r"],[-1,1957,"\r"],[-1,2029,"\r"],[-1,2040,"\r"],[-1,2047,"\r"],[1,2050,"\n\n```\n"],[-1,2050,"\r"],[1,2060,"\n\n```"],[-1,2060,"\r\n\r"],[-1,2149,"\r"],[-1,2180,"\r"],[-1,2195,"\r"],[-1,2253,"\r"],[-1,2298,"\r"],[-1,2347,"\r"],[-1,2397,"\r"],[-1,2447,"\r"],[-1,2449,"\r"],[-1,2489,"\r"],[-1,2529,"\r"],[-1,2536,"\r"],[-1,2538,"\r"],[-1,2553,"\r"],[-1,2588,"\r"],[-1,2627,"\r"],[-1,2645,"\r"],[-1,2690,"\r"],[-1,2760,"\r"],[-1,2771,"\r"],[-1,2778,"\r"],[1,2781,"\n\n```\n"],[-1,2781,"\r"],[-1,2826,"\r"],[-1,2828,"\r"],[1,2830,"##### "],[1,2834,"\n\n###### "],[-1,2834,"\r\n"],[1,2850,"\n"],[-1,2850,"\r"],[1,2893,"["],[1,2911,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)"],[1,2921,"["],[1,2937,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n"],[-1,2937,"\r\n\r"],[1,2946,"`"],[1,2952,"`"],[1,2958,"\n\n```"],[-1,2958,"\r\n\r"],[-1,2989,"\r"],[-1,3024,"\r"],[-1,3051,"\r"],[-1,3053,"\r"],[-1,3062,"\r"],[-1,3084,"\r"],[-1,3093,"\r"],[-1,3113,"\r"],[-1,3115,"\r"],[-1,3124,"\r"],[-1,3153,"\r"],[-1,3162,"\r"],[-1,3194,"\r"],[-1,3196,"\r"],[-1,3205,"\r"],[-1,3235,"\r"],[-1,3244,"\r"],[-1,3284,"\r"],[-1,3286,"\r"],[-1,3295,"\r"],[-1,3326,"\r"],[-1,3335,"\r"],[-1,3380,"\r"],[-1,3382,"\r"],[-1,3391,"\r"],[-1,3406,"\r"],[-1,3415,"\r"],[-1,3447,"\r"],[1,3450,"\n\n```\n"],[-1,3450,"\r"],[1,3459,"`"],[1,3464,"`"],[1,3618,"`"],[1,3623,"`"],[-1,3648,"\r"],[1,3676,"`"],[1,3684,"`"],[1,3699,"`"],[1,3705,"`"],[-1,3735,"\r"],[-1,3737,"\r"],[1,3768,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n"],[-1,3768,"\r\n\r\n\r"],[1,3789,"`"],[1,3803,"`"],[1,3824,"["],[1,3860,"](https://www.jianshu.com/p/07ef8ba80562)"],[1,3868,"**"],[1,3876,"**"],[1,3887,"`"],[1,3901,"`"],[1,3912,"\n\n```"],[-1,3912,"\r\n\r"],[-1,3929,"\r"],[-1,4026,"\r"],[-1,4053,"\r"],[-1,4109,"\r"],[-1,4162,"\r"],[-1,4262,"\r"],[-1,4281,"\r"],[-1,4345,"\r"],[-1,4383,"\r"],[-1,4433,"\r"],[-1,4435,"\r"],[-1,4472,"\r"],[-1,4506,"\r"],[-1,4521,"\r"],[-1,4547,"\r"],[-1,4558,"\r"],[-1,4560,"\r"],[-1,4583,"\r"],[1,4590,"\n\n```\n\n`"],[-1,4590,"\r\n"],[1,4601,"`"],[1,4613,"`"],[1,4619,"`"],[1,4653,"`"],[1,4667,"`"],[1,4671,"`"],[1,4684,"`"],[1,4692,"`"],[1,4698,"`"],[-1,4737,"\r"],[-1,4739,"\r"],[1,4741,"*   "],[1,4760,"\n\n```"],[-1,4760,"\r"],[-1,4817,"\r"],[-1,4830,"\r"],[-1,4906,"\r"],[-1,4959,"\r"],[-1,4964,"\r"],[1,4967,"\n\n```\n\n*   "],[-1,4967,"\r\n"],[1,4990,"\n\n```"],[-1,4990,"\r"],[-1,5050,"\r"],[-1,5063,"\r"],[-1,5119,"\r"],[-1,5254,"\r"],[-1,5259,"\r"],[1,5262,"\n\n```\n\n*   "],[-1,5262,"\r\n"],[1,5288,"\n\n```"],[-1,5288,"\r"],[-1,5354,"\r"],[-1,5367,"\r"],[-1,5427,"\r"],[-1,5432,"\r"],[1,5435,"\n\n```\n"],[-1,5435,"\r"],[-1,5455,"\r"],[-1,5457,"\r"],[1,5480,"\n\n```"],[-1,5480,"\r\n\r"],[-1,5568,"\r"],[-1,5626,"\r"],[-1,5628,"          \r"],[-1,5726,"\r"],[-1,5728,"\r"],[-1,5758,"\r"],[-1,5798,"\r"],[-1,5876,"\r"],[-1,5905,"\r"],[-1,5984,"\r"],[-1,6060,"\r"],[-1,6089,"\r"],[-1,6166,"\r"],[-1,6243,"\r"],[-1,6324,"\r"],[-1,6413,"\r"],[-1,6506,"\r"],[-1,6508,"\r"],[-1,6625,"\r"],[-1,6658,"\r"],[-1,6744,"\r"],[-1,6862,"\r"],[-1,6898,"\r"],[-1,6990,"\r"],[-1,7029,"\r"],[-1,7098,"\r"],[-1,7167,"\r"],[-1,7169,"\r"],[-1,7216,"\r"],[-1,7232,"\r"],[-1,7323,"\r"],[-1,7340,"\r"],[-1,7423,"\r"],[-1,7470,"\r"],[-1,7520,"\r"],[-1,7568,"\r"],[-1,7625,"\r"],[-1,7714,"\r"],[-1,7737,"\r"],[-1,7753,"\r"],[-1,7755,"\r"],[-1,7771,"\r"],[-1,7867,"\r"],[-1,7884,"\r"],[-1,7968,"\r"],[-1,8015,"\r"],[-1,8065,"\r"],[-1,8117,"\r"],[-1,8133,"\r"],[-1,8135,"\r"],[-1,8151,"\r"],[-1,8173,"\r"],[-1,8190,"\r"],[-1,8282,"\r"],[-1,8386,"\r"],[-1,8458,"\r"],[-1,8563,"\r"],[-1,8644,"\r"],[-1,8758,"\r"],[-1,8760,"\r\n          \r"],[-1,8789,"\r"],[-1,8800,"\r"],[1,8807,"\n\n```\n"],[-1,8807,"\r"],[1,8840,"\n\n```"],[-1,8840,"\r\n\r"],[-1,8928,"\r"],[-1,8986,"\r"],[-1,9008,"\r"],[-1,9010,"\r"],[-1,9026,"\r"],[-1,9080,"\r"],[-1,9105,"\r"],[-1,9194,"\r"],[-1,9211,"\r"],[-1,9316,"\r"],[-1,9368,"\r"],[-1,9411,"\r"],[-1,9462,"\r"],[-1,9464,"\r"],[-1,9498,"\r"],[-1,9551,"\r"],[-1,9602,"\r"],[-1,9669,"\r"],[-1,9714,"\r"],[-1,9716,"                \r"],[-1,9813,"\r"],[-1,9912,"\r"],[-1,10001,"\r"],[-1,10003,"\r"],[-1,10060,"\r"],[-1,10109,"\r"],[-1,10181,"\r"],[-1,10256,"\r"],[-1,10412,"\r"],[-1,10510,"\r"],[-1,10601,"\r"],[-1,10783,"\r"],[-1,10810,"\r"],[-1,10833,"\r"],[-1,10870,"\r"],[-1,10966,"\r"],[-1,11052,"\r"],[-1,11141,"\r"],[-1,11201,"\r"],[-1,11289,"\r"],[-1,11379,"\r"],[-1,11477,"\r"],[-1,11565,"\r"],[-1,11601,"\r"],[-1,11697,"\r"],[-1,11797,"\r"],[-1,11886,"\r"],[-1,11921,"\r"],[-1,12018,"\r"],[-1,12037,"\r"],[-1,12039,"                \r"],[-1,12146,"\r"],[-1,12181,"\r"],[-1,12221,"\r"],[-1,12223,"          \r"],[-1,12248,"\r"],[-1,12250,"\r"],[-1,12273,"\r"],[-1,12284,"\r"],[1,12291,"\n\n```\n"],[-1,12291,"\r"],[1,12380,"`"],[1,12389,"`"],[1,12395,"`"],[1,12416,"`"],[1,12427,"`"],[1,12435,"`"],[-1,12438,"\r"],[-1,12440,"\r"],[1,12448,"\n\n```"],[-1,12448,"\r\n\r"],[-1,12536,"\r"],[-1,12594,"\r"],[-1,12616,"\r"],[-1,12618,"\r"],[-1,12635,"\r"],[-1,12694,"\r"],[-1,12718,"\r"],[-1,12790,"\r"],[-1,12807,"\r"],[-1,12916,"\r"],[-1,12968,"\r"],[-1,13011,"\r"],[-1,13066,"\r"],[-1,13068,"\r"],[-1,13103,"\r"],[-1,13167,"\r"],[-1,13250,"\r"],[-1,13302,"\r"],[-1,13321,"\r"],[-1,13378,"\r"],[-1,13406,"\r"],[-1,13478,"\r"],[-1,13495,"\r"],[-1,13605,"\r"],[-1,13661,"\r"],[-1,13708,"\r"],[-1,13764,"\r"],[-1,13766,"\r"],[-1,13802,"\r"],[-1,13864,"\r"],[-1,13896,"\r"],[-1,13953,"\r"],[-1,14005,"\r"],[-1,14049,"\r"],[-1,14091,"\r"],[-1,14134,"\r"],[-1,14259,"\r"],[-1,14323,"\r"],[-1,14441,"\r"],[-1,14548,"\r"],[-1,14629,"\r"],[-1,14712,"\r"],[-1,14907,"\r"],[-1,15000,"\r"],[-1,15058,"\r"],[-1,15116,"\r"],[-1,15214,"\r"],[-1,15280,"\r"],[-1,15348,"\r"],[-1,15426,"\r"],[-1,15538,"\r"],[-1,15621,"\r"],[-1,15816,"\r"],[-1,15896,"\r"],[-1,15954,"\r"],[-1,16012,"\r"],[-1,16110,"\r"],[-1,16176,"\r"],[-1,16244,"\r"],[-1,16279,"\r"],[-1,16321,"\r"],[-1,16494,"\r"],[-1,16525,"\r"],[-1,16561,"\r"],[-1,16595,"\r"],[-1,16631,"\r"],[-1,16654,"\r"],[-1,16656,"\r"],[-1,16711,"\r"],[-1,16784,"\r"],[-1,16833,"\r"],[-1,16915,"\r"],[-1,16975,"\r"],[-1,17065,"\r"],[-1,17204,"\r"],[-1,17231,"\r"],[-1,17254,"\r"],[-1,17319,"\r"],[-1,17321,"                    \r"],[-1,17404,"\r"],[-1,17445,"\r"],[-1,17509,"\r"],[-1,17809,"\r"],[-1,17859,"\r"],[-1,17901,"\r"],[-1,17943,"\r"],[-1,18025,"\r"],[-1,18089,"\r"],[-1,18155,"\r"],[-1,18174,"\r"],[-1,18176,"\r"],[-1,18230,"\r"],[-1,18283,"\r"],[-1,18365,"\r"],[-1,18432,"\r"],[-1,18492,"\r"],[-1,18554,"\r"],[-1,18613,"\r"],[-1,18698,"\r"],[-1,18753,"\r"],[-1,18835,"\r"],[-1,18877,"\r"],[-1,18921,"\r"],[-1,18923,"\r"],[-1,18998,"\r"],[-1,19067,"\r"],[-1,19123,"\r"],[-1,19138,"\r"],[-1,19140,"\r"],[-1,19158,"\r"],[-1,19169,"\r"],[1,19176,"\n\n```\n"],[-1,19176,"\r"],[-1,19190,"\r"],[-1,19192,"\r"],[1,19194,"*   "],[1,19196,"`"],[1,19204,"`"],[1,19229,"`"],[1,19239,"`"],[1,19328,"`"],[1,19335,"`"],[1,19351,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n"],[-1,19351,"\r"],[1,19359,"\n"],[-1,19359,"\r"],[1,19366,"`"],[1,19376,"`"],[1,19388,"`"],[1,19395,"`"],[1,19402,"\n\n```"],[-1,19402,"\r\n\r"],[-1,19464,"\r"],[-1,19477,"\r"],[-1,19533,"\r"],[-1,19563,"\r"],[-1,19809,"\r"],[-1,19820,"\r"],[-1,19849,"\r"],[-1,19992,"\r"],[-1,20002,"\r"],[-1,20007,"\r"],[1,20010,"\n\n```\n\n*   "],[-1,20010,"\r\n"],[1,20077,"`"],[1,20087,"`"],[1,20134,"`"],[1,20144,"`"],[1,20170,"\n\n```"],[-1,20170,"\r"],[-1,20236,"\r"],[-1,20249,"\r"],[-1,20309,"\r"],[-1,20503,"\r"],[-1,20537,"\r"],[-1,20735,"\r"],[-1,20768,"\r"],[-1,20961,"\r"],[-1,20966,"\r"],[1,20969,"\n\n```\n\n*   "],[-1,20969,"\r\n"],[1,21053,"\n"],[-1,21053,"\r"],[1,21061,"`"],[1,21074,"`"],[1,21119,"`"],[1,21129,"`"],[1,21182,"\n\n```"],[-1,21182,"\r\n\r"],[-1,21270,"\r"],[-1,21328,"\r"],[-1,21350,"\r"],[-1,21415,"\r"],[-1,21464,"\r"],[-1,21591,"\r"],[-1,21669,"\r"],[-1,21835,"\r"],[-1,21854,"\r"],[-1,21869,"\r"],[-1,21871,"\r"],[-1,21914,"\r"],[-1,21999,"\r"],[-1,22055,"\r"],[-1,22119,"\r"],[-1,22174,"\r"],[-1,22258,"\r"],[-1,22309,"\r"],[-1,22390,"\r"],[-1,22428,"\r"],[-1,22468,"\r"],[-1,22470,"\r"],[-1,22567,"\r"],[-1,22569,"\r"],[-1,22608,"\r"],[-1,22682,"\r"],[-1,22738,"\r"],[-1,22795,"\r"],[-1,22850,"\r"],[-1,22955,"\r"],[-1,23006,"\r"],[-1,23083,"\r"],[-1,23121,"\r"],[-1,23161,"\r"],[-1,23163,"\r"],[-1,23245,"\r"],[-1,23256,"\r"],[1,23263,"\n\n```\n"],[-1,23263,"\r"],[1,23270,"`"],[1,23280,"`"],[1,23306,"\n\n```"],[-1,23306,"\r\n\r"],[-1,23365,"\r"],[-1,23378,"\r"],[-1,23454,"\r"],[-1,23513,"\r"],[-1,23566,"\r"],[-1,23571,"\r"],[1,23574,"\n\n```\n\n**"],[-1,23574,"\r\n"],[1,23583,"`"],[1,23596,"`"],[1,23605,"**\n"],[-1,23605,"\r\n\r"],[1,23617,"`"],[1,23629,"`"],[1,23637,"\n\n```"],[-1,23637,"\r\n\r"],[-1,23690,"\r"],[-1,23726,"\r"],[-1,23765,"\r"],[-1,23893,"\r"],[-1,23976,"\r"],[-1,24006,"\r"],[-1,24083,"\r"],[-1,24139,"\r"],[-1,24230,"\r"],[-1,24261,"\r"],[-1,24331,"\r"],[-1,24362,"\r"],[-1,24436,"\r"],[-1,24498,"\r"],[-1,24559,"\r"],[-1,24598,"\r"],[-1,24625,"\r"],[-1,24648,"\r"],[-1,24669,"\r"],[-1,24715,"\r"],[-1,24782,"\r"],[-1,24804,"\r"],[-1,24848,"\r"],[-1,24863,"\r"],[-1,24881,"\r"],[-1,24984,"\r"],[-1,24995,"\r"],[-1,25002,"\r"],[-1,25004,"\r"],[-1,25032,"\r"],[-1,25080,"\r"],[-1,25119,"\r"],[-1,25156,"\r"],[-1,25275,"\r"],[-1,25302,"\r"],[-1,25313,"\r"],[-1,25315,"\r"],[-1,25381,"\r"],[-1,25479,"\r"],[-1,25498,"\r"],[-1,25578,"\r"],[-1,25636,"\r"],[-1,25671,"\r"],[-1,25690,"\r"],[-1,25692,"\r"],[-1,25738,"\r"],[-1,25768,"\r"],[-1,25805,"\r"],[-1,25890,"\r"],[-1,25921,"\r"],[-1,25936,"\r"],[-1,25947,"\r"],[-1,25949,"\r"],[-1,25971,"\r"],[1,25978,"\n\n```\n"],[-1,25978,"\r"],[-1,26072,"\r"],[-1,26074,"\r"],[1,26080,"`"],[1,26086,"`"],[-1,26170,"\r"],[-1,26172,"\r"],[1,26174,"###### "],[1,26188,"\n"],[-1,26188,"\r"],[1,26279,"["],[1,26290,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `"],[-1,26290,"\r\n\r\n"],[1,26301,"`"],[1,26302,"`"],[1,26308,"`"],[1,26310,"\n\n```"],[-1,26310,"\r"],[-1,26362,"\r"],[-1,26387,"\r"],[-1,26426,"\r"],[-1,26496,"\r"],[-1,26547,"\r"],[-1,26549,"\r"],[-1,26577,"\r"],[-1,26616,"\r"],[-1,26631,"\r"],[-1,26633,"\r"],[-1,26702,"\r"],[-1,26713,"\r"],[1,26720,"\n\n```\n"],[-1,26720,"\r"],[1,26743,"`"],[1,26751,"`"],[1,26754,"`"],[1,26761,"`"],[1,26780,"`"],[1,26788,"`"],[-1,26794,"\r"],[-1,26796,"\r"],[1,26798,"*   `"],[1,26806,"`"],[1,26807,"`"],[1,26813,"`"],[1,26815,"\n\n```"],[-1,26815,"\r"],[-1,26888,"\r"],[-1,26921,"\r"],[-1,26972,"\r"],[-1,27031,"\r"],[-1,27056,"\r"],[-1,27058,"\r"],[-1,27080,"\r"],[1,27087,"\n\n```\n\n`"],[-1,27087,"\r\n"],[1,27097,"`"],[1,27102,"`"],[1,27124,"`"],[1,27142,"`"],[1,27150,"`"],[1,27168,"\n\n```"],[-1,27168,"\r\n\r"],[-1,27279,"\r"],[-1,27308,"\r"],[-1,27333,"\r"],[-1,27335,"\r"],[-1,27350,"\r"],[-1,27424,"\r"],[-1,27470,"\r"],[-1,27580,"\r"],[-1,27582,"\r"],[-1,27626,"\r"],[-1,27681,"\r"],[-1,27763,"\r"],[-1,27871,"\r"],[-1,27982,"\r"],[-1,28109,"\r"],[-1,28232,"\r"],[-1,28326,"\r"],[-1,28436,"\r"],[-1,28576,"\r"],[-1,28696,"\r"],[-1,28788,"\r"],[-1,28857,"\r"],[-1,28991,"\r"],[-1,29010,"\r"],[-1,29025,"\r"],[-1,29027,"\r"],[-1,29081,"\r"],[-1,29182,"\r"],[-1,29197,"\r"],[-1,29199,"\r"],[-1,29240,"\r"],[-1,29511,"\r"],[-1,29526,"\r"],[-1,29559,"\r"],[-1,29675,"\r"],[-1,29686,"\r"],[1,29693,"\n\n```\n\n*   `"],[-1,29693,"\r\n"],[1,29703,"`"],[1,29704,"`"],[1,29715,"`"],[1,29717,"\n\n```"],[-1,29717,"\r"],[-1,29744,"\r"],[-1,29797,"\r"],[-1,29922,"\r"],[1,29929,"\n\n```\n"],[-1,29929,"\r"],[1,29958,"`"],[1,29992,"`"],[1,30016,"["],[1,30027,"](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)"],[1,30028,"`"],[1,30038,"`"],[-1,30045,"\r"],[1,30047,"**"],[1,30143,"**"],[1,30167,"\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n"],[-1,30167,"\r\n\r\n\r"],[1,30304,"`"],[1,30313,"`"],[-1,30356,"\r"],[-1,30358,"\r"],[1,30360,"###### "],[1,30375,"\n"],[-1,30375,"\r"],[-1,30386,"\r"],[-1,30388,"\r"],[1,30390,"> "],[-1,30450,"\r"],[-1,30452,"\r"],[-1,30508,"\r"],[-1,30510,"\r"],[1,30512,"> "],[-1,30522,"\r"],[1,30524,"> "],[-1,30582,"\r"],[-1,30584,"\r"],[1,30586,"> "],[-1,30596,"\r"],[1,30598,"> "],[-1,30650,"\r"],[-1,30652,"\r"],[1,30672,"`"],[1,30693,"`"],[1,30730,"`"],[1,30737,"`"],[1,30738,"`"],[1,30750,"`"],[-1,30751,"\r"],[-1,30753,"\r"],[1,30755,"**"],[1,30764,"**"],[-1,30764,"\r"],[1,30774,"`"],[1,30792,"`"],[1,30793,"`"],[1,30799,"`"],[1,30808,"`"],[1,30816,"`"],[1,30817,"`"],[1,30835,"`"],[1,30838,"\n\n```"],[-1,30838,"\r\n\r"],[-1,30883,"\r"],[-1,30923,"\r"],[-1,31002,"\r"],[-1,31020,"\r"],[-1,31123,"\r"],[-1,31160,"\r"],[-1,31210,"\r"],[-1,31225,"\r"],[-1,31278,"\r"],[-1,31289,"\r"],[1,31296,"\n\n```\n"],[-1,31296,"\r"],[1,31300,"`"],[1,31325,"`"],[1,31356,"\n\n```"],[-1,31356,"\r\n\r"],[-1,31404,"\r"],[-1,31469,"\r"],[-1,31621,"\r"],[-1,31632,"\r"],[-1,31634,"\r"],[-1,31649,"\r"],[-1,31706,"\r"],[-1,31782,"\r"],[-1,31834,"\r"],[-1,31960,"\r"],[-1,31982,"\r"],[-1,32020,"\r"],[-1,32035,"\r"],[-1,32068,"\r"],[-1,32163,"\r"],[-1,32189,"\r"],[-1,32200,"\r"],[1,32207,"\n\n```\n\n`"],[-1,32207,"\r\n"],[1,32227,"`"],[1,32235,"`"],[1,32267,"`\n\n```"],[-1,32267,"\r\n\r"],[-1,32328,"\r"],[-1,32396,"\r"],[-1,32475,"\r"],[-1,32493,"\r"],[-1,32596,"\r"],[-1,32633,"\r"],[-1,32683,"\r"],[-1,32698,"\r"],[-1,32745,"\r"],[-1,32756,"\r"],[1,32763,"\n\n```\n\n**"],[-1,32763,"\r\n"],[1,32773,"`"],[1,32831,"`"],[1,32837,"`"],[1,32855,"`"],[1,32940,"**"],[-1,32940,"\r"],[1,32945,"`"],[1,32963,"`"],[1,32974,"`"],[1,32985,"`"],[1,32986,"`"],[1,32994,"`"],[1,33021,"\n\n```"],[-1,33021,"\r\n\r"],[-1,33080,"\r"],[-1,33082,"\r"],[-1,33091,"\r"],[-1,33116,"\r"],[-1,33124,"\r"],[-1,33153,"\r"],[-1,33162,"\r"],[-1,33198,"\r"],[-1,33200,"\r"],[-1,33209,"\r"],[-1,33231,"\r"],[-1,33239,"\r"],[-1,33266,"\r"],[-1,33275,"\r"],[-1,33301,"\r"],[1,33304,"\n\n```\n"],[-1,33304,"\r\n\r"],[1,33314,"`"],[1,33322,"`"],[1,33350,"`"],[1,33357,"`"],[1,33376,"`"],[1,33384,"`"],[1,33436,"\n\n```"],[-1,33436,"\r\n\r"],[-1,33487,"\r"],[-1,33509,"\r"],[-1,33585,"\r"],[-1,33631,"\r"],[-1,33686,"\r"],[-1,33764,"\r"],[-1,33818,"\r"],[-1,33853,"\r"],[-1,33918,"\r"],[-1,33920,"\r"],[-1,33934,"\r"],[-1,34012,"\r"],[-1,34040,"\r"],[-1,34067,"\r"],[-1,34069,"\r"],[-1,34098,"\r"],[-1,34145,"\r"],[-1,34183,"\r"],[-1,34230,"\r"],[-1,34273,"\r"],[-1,34316,"\r"],[-1,34360,"\r"],[-1,34405,"\r"],[-1,34475,"\r"],[-1,34490,"\r"],[1,34493,"\n\n```\n\n**"],[-1,34493,"\r\n"],[1,34509,"**"],[-1,34509,"\r"],[1,34518,"`"],[1,34530,"`"],[1,34548,"`"],[1,34556,"`"],[1,34562,"\n\n```"],[-1,34562,"\r\n\r"],[-1,34705,"\r"],[-1,34720,"\r"],[-1,34816,"\r"],[-1,34867,"\r"],[-1,34913,"\r"],[-1,34971,"\r"],[-1,34973,"\r"],[-1,35038,"\r"],[-1,35112,"\r"],[-1,35180,"\r"],[-1,35274,"\r"],[-1,35289,"\r"],[-1,35339,"\r"],[-1,35406,"\r"],[-1,35450,"\r"],[-1,35487,"\r"],[-1,35531,"\r"],[-1,35628,"\r"],[-1,35733,"\r"],[-1,35780,"\r"],[-1,35843,"\r"],[-1,35862,"\r"],[-1,35877,"\r"],[-1,35879,"\r"],[-1,35905,"\r"],[-1,35916,"\r"],[-1,35956,"\r"],[-1,35989,"\r"],[-1,36030,"\r"],[-1,36041,"\r"],[-1,36043,"        \r"],[-1,36115,"\r"],[-1,36161,"\r"],[-1,36207,"\r"],[-1,36293,"\r"],[-1,36314,"\r"],[-1,36351,"\r"],[-1,36371,"\r"],[-1,36418,"\r"],[-1,36439,"\r"],[-1,36466,"\r"],[-1,36527,"\r"],[-1,36603,"\r"],[-1,36622,"\r"],[-1,36624,"\r"],[-1,36645,"\r"],[-1,36734,"\r"],[-1,36754,"\r"],[-1,36811,"\r"],[-1,36832,"\r"],[-1,36859,"\r"],[-1,36923,"\r"],[-1,36968,"\r"],[-1,37025,"\r"],[-1,37048,"\r"],[-1,37050,"\r"],[-1,37173,"\r"],[-1,37192,"\r"],[-1,37209,"\r"],[-1,37227,"\r"],[-1,37302,"\r"],[-1,37313,"\r"],[-1,37315,"\r"],[-1,37337,"\r"],[-1,37344,"\r"],[1,37346,"\n```\n\n**"],[1,37382,"`"],[1,37396,"`"],[1,37401,"`"],[1,37409,"`"],[1,37454,"**"],[1,37458,"`"],[1,37472,"`"],[1,37475,"\n\n```"],[-1,37475,"\r\n\r"],[-1,37530,"\r"],[-1,37532,"\r"],[-1,37541,"\r"],[-1,37566,"\r"],[-1,37574,"\r"],[-1,37603,"\r"],[-1,37612,"\r"],[-1,37666,"\r"],[1,37669,"\n\n```\n"],[-1,37669,"\r\n\r"],[1,37703,"`"],[1,37716,"`"],[1,37724,"\n\n```"],[-1,37724,"\r\n\r"],[-1,37862,"\r"],[-1,37940,"\r"],[-1,37942,"\r"],[-1,37981,"\r"],[-1,38009,"\r"],[-1,38059,"\r"],[-1,38088,"\r"],[-1,38182,"\r"],[-1,38206,"\r"],[-1,38263,"\r"],[-1,38265,"\r"],[-1,38297,"\r"],[-1,38347,"\r"],[-1,38383,"\r"],[-1,38428,"\r"],[-1,38537,"\r"],[-1,38606,"\r"],[-1,38625,"\r"],[-1,38627,"\r"],[-1,38657,"\r"],[-1,38732,"\r"],[-1,38763,"\r"],[-1,38804,"\r"],[-1,38845,"\r"],[-1,38919,"\r"],[-1,39064,"\r"],[-1,39098,"\r"],[-1,39210,"\r"],[-1,39237,"\r"],[-1,39239,"\r"],[-1,39390,"\r"],[-1,39430,"\r"],[-1,39563,"\r"],[-1,39590,"\r"],[-1,39645,"\r"],[-1,39714,"\r"],[-1,39773,"\r"],[-1,39800,"\r"],[-1,39823,"\r"],[-1,39844,"\r"],[-1,39846,"\r"],[-1,39870,"\r"],[-1,39898,"\r"],[-1,39946,"\r"],[-1,39975,"\r"],[-1,40011,"\r"],[-1,40039,"\r"],[-1,40104,"\r"],[-1,40127,"\r"],[-1,40169,"\r"],[-1,40253,"\r"],[-1,40310,"\r"],[-1,40393,"\r"],[-1,40480,"\r"],[-1,40586,"\r"],[-1,40609,"\r"],[-1,40611,"\r"],[-1,40649,"\r"],[-1,40691,"\r"],[-1,40822,"\r"],[-1,40841,"\r"],[-1,40867,"\r"],[-1,40894,"\r"],[-1,40916,"\r"],[-1,40946,"\r"],[-1,40957,"\r"],[-1,40959,"\r"],[-1,40981,"\r"],[1,40988,"\n\n```\n"],[-1,40988,"\r"],[1,41077,"`"],[1,41089,"`"],[1,41099,"`"],[1,41114,"`"],[1,41115,"`"],[1,41144,"`。\n\n```"],[-1,41144,"。\r\n\r"],[-1,41216,"\r"],[-1,41249,"\r"],[-1,41317,"\r"],[-1,41328,"\r"],[-1,41330,"      \r"],[-1,41378,"\r"],[-1,41451,"\r"],[-1,41488,"\r"],[-1,41547,"\r"],[-1,41651,"\r"],[-1,41675,"\r"],[-1,41713,"\r"],[-1,41874,"\r"],[-1,41896,"\r"],[-1,41977,"\r"],[-1,42000,"\r"],[-1,42049,"\r"],[-1,42220,"\r"],[-1,42243,"\r"],[-1,42325,"\r"],[-1,42417,"\r"],[-1,42481,"\r"],[-1,42528,"\r"],[-1,42600,"\r"],[-1,42602,"\r"],[-1,42651,"\r"],[-1,42831,"\r"],[-1,42854,"\r"],[-1,42895,"\r"],[-1,43019,"\r"],[-1,43038,"\r"],[-1,43098,"\r"],[-1,43149,"\r"],[-1,43164,"\r"],[-1,43182,"\r"],[-1,43261,"\r"],[-1,43323,"\r"],[-1,43389,"\r"],[-1,43441,"\r"],[-1,43501,"\r"],[-1,43555,"\r"],[-1,43557,"\r"],[-1,43621,"\r"],[-1,43666,"\r"],[-1,43703,"\r"],[-1,43761,"\r"],[-1,43850,"\r"],[-1,43928,"\r"],[-1,43930,"\r"],[-1,43986,"\r"],[-1,44076,"\r"],[-1,44163,"\r"],[-1,44207,"\r"],[-1,44259,"\r"],[-1,44309,"\r"],[-1,44375,"\r"],[-1,44398,"\r"],[-1,44400,"\r"],[-1,44464,"\r"],[-1,44588,"\r"],[-1,44607,"\r"],[-1,44609,"\r"],[-1,44642,"\r"],[-1,44716,"\r"],[-1,44731,"\r"],[-1,44733,"            \r"],[-1,44794,"\r"],[-1,44838,"\r"],[-1,44872,"\r"],[-1,44964,"\r"],[-1,45016,"\r"],[-1,45136,"\r"],[-1,45217,"\r"],[-1,45302,"\r"],[-1,45347,"\r"],[-1,45378,"\r"],[-1,45463,"\r"],[-1,45517,"\r"],[-1,45595,"\r"],[-1,45645,"\r"],[-1,45694,"\r"],[-1,45794,"\r"],[-1,45821,"\r"],[-1,45844,"\r"],[-1,45897,"\r"],[-1,45990,"\r"],[-1,46018,"\r"],[-1,46050,"\r"],[-1,46132,"\r"],[-1,46158,"\r"],[-1,46186,"\r"],[-1,46201,"\r"],[-1,46212,"\r"],[1,46219,"\n\n```\n"],[-1,46219,"\r"],[1,46330,"`"],[1,46338,"`"],[1,46339,"`"],[1,46377,"`\n\n```"],[-1,46377,"\r\n\r"],[-1,46439,"\r"],[-1,46454,"\r"],[-1,46498,"\r"],[-1,46581,"\r"],[-1,46583,"\r"],[-1,46623,"\r"],[-1,46707,"\r"],[-1,46791,"\r"],[-1,46806,"\r"],[-1,46839,"\r"],[-1,46890,"\r"],[-1,46934,"\r"],[-1,46982,"\r"],[-1,47028,"\r"],[-1,47086,"\r"],[-1,47112,"\r"],[-1,47123,"\r"],[1,47130,"\n\n```\n"],[-1,47130,"\r\n\r"],[1,47140,"`"],[1,47152,"`"],[1,47168,"`"],[1,47216,"`"],[1,47219,"\n\n```"],[-1,47219,"\r\n\r"],[-1,47283,"\r"],[-1,47352,"\r"],[-1,47354,"\r"],[-1,47383,"\r"],[-1,47409,"\r"],[-1,47427,"\r"],[-1,47494,"\r"],[-1,47505,"\r"],[1,47512,"\n\n```\n"],[-1,47512,"\r"],[1,47630,"**"],[1,47711,"**"],[-1,47712,"\r"],[-1,47714,"\r"],[1,47716,"##### "],[1,47718,"\n"],[-1,47718,"\r"],[-1,47763,"\r"],[-1,47765,"\r"],[1,47767,"*   **"],[1,47772,"**\n\n```"],[-1,47772,"\r"],[-1,47782,"\r"],[-1,47831,"\r"],[-1,47882,"\r"],[-1,47927,"\r"],[-1,47978,"\r"],[-1,48026,"\r"],[-1,48087,"\r"],[-1,48151,"\r"],[-1,48204,"\r"],[-1,48244,"\r"],[-1,48246,"\r"],[-1,48262,"\r"],[-1,48295,"\r"],[-1,48320,"\r"],[-1,48357,"\r"],[-1,48382,"\r"],[1,48408,"\n\n```\n"],[-1,48408,"\r"],[1,48422,"`"],[1,48430,"`"],[1,48434,"`"],[1,48441,"`"],[1,48455,"`"],[1,48493,"`"],[-1,48503,"\r"],[1,48526,"`"],[1,48542,"`"],[1,48559,"`"],[1,48569,"`"],[1,48586,"`"],[1,48598,"`"],[1,48700,"\n\n```"],[-1,48700,"\r\n\r"],[-1,48734,"\r"],[-1,48798,"\r"],[-1,48813,"\r"],[-1,48854,"\r"],[-1,48856,"\r"],[-1,48863,"\r"],[-1,48865,"\r"],[-1,48880,"\r"],[-1,48941,"\r"],[-1,48988,"\r"],[-1,48995,"\r"],[-1,48997,"\r"],[-1,49012,"\r"],[-1,49062,"\r"],[-1,49107,"\r"],[-1,49114,"\r"],[1,49117,"\n\n```\n"],[-1,49117,"\r\n\r"],[1,49135,"`"],[1,49150,"`"],[1,49167,"\n\n```"],[-1,49167,"\r\n\r"],[-1,49276,"\r"],[1,49370,"\n\n```\n\n*   **"],[-1,49370,"\r\n"],[1,49379,"**\n\n```"],[-1,49379,"\r"],[1,49450,"\n\n```\n"],[-1,49450,"\r"],[1,49464,"`"],[1,49474,"`"],[-1,49498,"\r"],[-1,49500,"\r"],[1,49502,"*   **"],[1,49515,"**\n"],[-1,49515,"\r"],[1,49529,"\n\n```"],[-1,49529,"\r\n\r"],[-1,49564,"\r"],[-1,49611,"\r"],[-1,49641,"\r"],[-1,49663,"\r"],[-1,49670,"\r"],[-1,49672,"\r\n\r"],[-1,49689,"\r"],[-1,49765,"\r"],[-1,49824,"\r"],[-1,49882,"\r"],[-1,49908,"\r"],[-1,49915,"\r"],[-1,49917,"\r"],[1,49920,"\n\n```\n"],[-1,49920,"\r"],[1,49931,"\n\n```"],[-1,49931,"\r\n\r"],[1,50025,"\n\n```\n\n*   **"],[-1,50025,"\r\n"],[1,50034,"**\n\n```"],[-1,50034,"\r"],[-1,50049,"\r"],[-1,50099,"\r"],[-1,50187,"\r"],[-1,50229,"\r"],[-1,50231,"\r"],[-1,50248,"\r"],[-1,50371,"\r"],[1,50460,"\n\n```\n\n*   **"],[-1,50460,"\r\n"],[1,50466,"**\n"],[-1,50466,"\r"],[-1,50496,"\r"],[1,50526,"\n\n```"],[-1,50526,"\r\n\r"],[-1,50551,"\r"],[-1,50602,"\r"],[-1,50637,"\r"],[-1,50640,"\r"],[-1,50642,"\r"],[-1,50651,"\r"],[-1,50699,"\r"],[-1,50756,"\r"],[-1,50758,"\r"],[-1,50773,"\r"],[-1,50816,"\r"],[-1,50846,"\r"],[-1,50853,"\r"],[-1,50855,"\r"],[-1,50870,"\r"],[-1,50911,"\r"],[-1,50913,"\r"],[-1,50920,"\r"],[1,50923,"\n\n```\n"],[-1,50923,"\r"],[1,50929,"\n\n```"],[-1,50929,"\r\n\r"],[-1,50941,"\r"],[-1,51025,"\r"],[-1,51035,"\r"],[1,51140,"\n\n```\n\n*   **"],[-1,51140,"\r\n"],[1,51147,"**\n\n![](//upload-images.jianshu.io/upload_images/5994347-767a114aa4746c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n"],[-1,51147,"\r\n\r"],[-1,51303,"\r"],[-1,51305,"\r"],[1,51307,"##### "],[1,51309,"\n"],[-1,51309,"\r"],[-1,51409,"\r"],[-1,51411,"\r"],[1,51413,"**"],[1,51442,"**\n"],[-1,51442,"\r\n\r"],[-1,51459,"\r"],[-1,51461,"\r"],[1,51467,"\n\n["],[-1,51467,"\r\n "],[1,51481,"](/nb/12473806)\n\n"],[-1,51481," "],[1,51492,"\n\n"],[-1,51492," "],[-1,51497,"\r"],[1,51499,"\n[![96](//upload.jianshu.io/users/upload_avatars/5994347/dd34592b-ad62-4e24-bb66-f7c689766b2f.png?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96) ](/u/d65e2e163603) "],[1,51501," ["],[1,51509,"](/u/d65e2e163603)\n"],[-1,51509,"\r"],[-1,51541,"\r"],[-1,51543,"\r"],[1,51547,"\n\n12\n\n[](javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f='http://v.t.sina.com.cn/share/share.php?appkey=1881139527',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function%20a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,'','','', '推荐 @龍儱滝 的文章《阿里ARouter使用及源码解析（一）》（ 分享自 @简书 ）','https://www.jianshu.com/p/46d174f37e82?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo','页面编码gb2312|utf-8默认gb2312'));)[](http://cwb.assets.jianshu.io/notes/images/13526520/weibo/image_bcbd18a5f866.png)["],[-1,51547," 12    "],[1,51558,"](javascript:void(0);)\n\n![](//upload.jianshu.io/users/upload_avatars/1786025/f63ccf82f6f8?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114) \n"],[-1,51558,"\r\n\r"],[1,51572,"关闭评论\n\n"],[1,51587,"\n\n[![](//cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/ab7bfd384c72)\n\n["],[-1,51587,"\r\n "],[1,51599,"](/u/ab7bfd384c72)\n"],[-1,51599,"\r"],[1,51622,"\n"],[-1,51622,"\r"],[-1,51631,"\r"],[-1,51633,"\r"],[-1,51639," "],[1,51642," 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/426662/e85a4080db83?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/a2a56d463e3d)\n\n[夏鸣浩](/u/a2a56d463e3d)\n"],[-1,51642,"\r\n 夏鸣浩\r"],[1,51671,"\n"],[-1,51671,"\r"],[-1,51682,"\r"],[-1,51684,"\r"],[-1,51688," "],[1,51691," 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/7293029/42130be5-9eb3-4cf2-8874-1f32e70d81e2?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/df76f81fe3ff)\n\n["],[-1,51691,"\r\n "],[1,51700,"](/u/df76f81fe3ff)\n"],[-1,51700,"\r"],[1,51723,"\n"],[-1,51723,"\r"],[-1,51732,"\r"],[-1,51734,"\r"],[-1,51738," "],[1,51741," 举报\n"],[-1,51741,"\r\n\r"],[-1,51756,"\r"],[-1,51799,"\r"],[-1,51806,"\r"]],[51842,51842],[0,54215]]],[1519699596985,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,4166,"https:"]],[4166,4285],[4291,4291]]],[1519699599018,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,4166,"https:"]],[4291,4291],[4166,4285]]],[1519699599890,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,4166,"https:"]],[4166,4285],[4291,4291]]],[1519699601752,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,4166,"https:"]],[4291,4291],[4166,4285]]],[1519699602617,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,4166,"https:"]],[4166,4285],[4291,4291]]],[1519699649387,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,19664,"https:"]],[19660,19672],[19660,19678]]],[1519699650508,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,30759,"https:"]],[30755,30767],[30755,30773]]],[1519699651316,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,51712,"https:"]],[51708,51720],[51708,51726]]],[1519699652093,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,53321,"https:"]],[53317,53329],[53317,53335]]],[1519699653309,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,53716,"https:"]],[53712,53724],[53712,53730]]],[1519699654052,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,53929,"https:"]],[53925,53937],[53925,53943]]],[1519699662595,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,53924,"["]],[53924,53925],[53924,53924]]],[1519699664853,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,53924,"["]],[53924,53924],[53924,53925]]],[1519699666214,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,53924,"["]],[53924,53925],[53924,53924]]],[1519699667407,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,53924,"["]],[53924,53924],[53924,53925]]],[1519699677572,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,53929,"https:"]],[53925,53943],[53925,53937]]],[1519699678352,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,53716,"https:"]],[53712,53730],[53712,53724]]],[1519699679021,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,53321,"https:"]],[53317,53335],[53317,53329]]],[1519699679324,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,51712,"https:"]],[51708,51726],[51708,51720]]],[1519699679516,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,30759,"https:"]],[30755,30773],[30755,30767]]],[1519699679708,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,19664,"https:"]],[19660,19678],[19660,19672]]],[1519699679900,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,4166,"https:"]],[4291,4291],[4166,4285]]],[1519699680091,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,0,"在app的开发中，页面之间的相互跳转是最基本常用的功能。在Android中的跳转一般通过显式intent和隐式intent两种方式实现的，而Android的原生跳转方式会存在一些缺点：\n\n*   显式intent的实现方式，因为会存在直接的类依赖的问题，导致耦合严重；\n*   隐式intent的实现方式，则会出现规则集中式管理，导致协作变得困难；\n*   可配置性较差，一般而言配置规则都是在Manifest中的，这就导致了扩展性较差；\n*   跳转过程无法控制，一旦使用了StartActivity()就无法插手其中任何环节了，只能交给系统管理；\n*   当多组件化开发，使用原生的路由方式很难实现完全解耦；\n\n而阿里的[ARouter](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)路由框架具有解耦、简单易用、支持多模块项目、定制性较强、支持拦截逻辑等诸多优点，很好的解决了上述的问题。关于ARouter具体实现功能，典型应用以及相应技术方案实现的介绍不在这详细介绍，具体可参见[开源最佳实践：Android平台页面路由框架ARouter](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)。\n\n阿里ARouter的分析计划\n\n*   [阿里ARouter使用及源码解析（一）](https://www.jianshu.com/p/46d174f37e82)\n*   [阿里ARouter拦截器使用及源码解析（二）](https://www.jianshu.com/p/c8d7b1379c1b)\n*   阿里ARouter参数自动装载使用及源码解析（三）\n\n##### 基本功能使用\n\n1.添加依赖和配置\n\n```\nandroid {\n    defaultConfig {\n    ...\n    javaCompileOptions {\n        annotationProcessorOptions {\n        arguments = [ moduleName : project.getName() ]\n        }\n    }\n    }\n}\n\ndependencies {\n    compile 'com.alibaba:arouter-api:1.2.1.1'\n    annotationProcessor 'com.alibaba:arouter-compiler:1.1.2.1'\n    ...\n}\n\n```\n\n2.添加注解\n\n```\n// 在支持路由的页面上添加注解(必选)\n// 这里的路径需要注意的是至少需要有两级，/xx/xx\n@Route(path = \"/test/test1\")\npublic class Test1Activity extends AppCompatActivity{\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_test1);\n    }\n}\n\n```\n\n3.初始化SDK\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            // 如果使用了InstantRun，必须在初始化之前开启调试模式，但是上线前需要关闭，InstantRun仅用于开发阶段，\n            // 线上开启调试模式有安全风险，可以使用BuildConfig.DEBUG来区分环境\n            ARouter.openDebug();\n            ARouter.init(getApplication()); // 尽可能早，推荐在Application中初始化\n        }\n    }\n}\n\n```\n\n4.发起跳转操作\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            ....\n        } else if (v.getId() == R.id.btn2){\n            ARouter.getInstance().build(\"/test/test1\").navigation();\n        }\n    }\n}\n\n```\n\n以上相关代码就是ARouter的最基本功能使用的步骤，下面来分析跳转功能是如何实现的。\n\n##### 原理分析\n\n###### 1.ARouter编译的过程\n\nARouter在编译期的时候，利用自定义注解完成了页面的自动注册。相关注解源码参见[arouter-annotation](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)，编译处理器源码参见[arouter-compiler](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n\n下面是注解`@Route`的源码介绍：\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.CLASS)\npublic @interface Route {\n\n    /**\n     *路由的路径，标识一个路由节点\n     */\n    String path();\n\n    /**\n     * 将路由节点进行分组，可以实现按组动态加载\n     */\n    String group() default \"\";\n\n    /**\n     * 路由节点名称，可用于生成javadoc文档\n     */\n    String name() default \"undefined\";\n\n    /**\n     * 用32位int类型标示，可用于页面的一些配置\n     */\n    int extras() default Integer.MIN_VALUE;\n\n    /**\n     * 路由的优先级\n     */\n    int priority() default -1;\n}\n\n```\n\nRoute中的`extra`值是个int值，由32位表示，即转换成二进制后，一个int中可以配置31个1或者0，而每一个0或者1都可以表示一项配置（排除符号位），如果从这31个位置中随便挑选出一个表示是否需要登录就可以了，只要将标志位置为1，就可以在声明的拦截器中获取到这个标志位，通过位运算的方式判断目标页面是否需要登录。所以可以通过`extra`给页面配置30多个属性，然后在拦截器中去进行处理。\nARouter在拦截器中会把目标页面的信息封装一个类`Postcard`，这个类就包含了目标页面注解上`@Route`标识的各种信息。关于拦截器的使用以及源码分析，后续会有介绍。\n\n将代码编译一遍，可以看到ARouter生成下面几个源文件：\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n\n上面三个文件均是通过注解处理器`RouteProcessor`生成的，关于如何自定义注解处理器，可以阅读[Android编译时注解APT实战（AbstractProcessor）](https://www.jianshu.com/p/07ef8ba80562)，同时也需要学习**JavaPoet**的基本使用。下面我们看`RouteProcessor`是如何生成相关文件的。\n\n```\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //判断被注解了的元素集合是否为空\n        if (CollectionUtils.isNotEmpty(annotations)) {\n            //获取所有被@Route注解的元素集合，Element可以是类、方法、变量等\n            Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);\n            try {\n                logger.info(\">>> Found routes, start... <<<\");\n                //具体处理注解，生成java文件的方法\n                this.parseRoutes(routeElements);\n\n            } catch (Exception e) {\n                logger.error(e);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n```\n\n`process()`方法相当于处理器的主函数`main()`，可以在这个方法中扫描、评估和处理注解的代码，以及生成Java文件。`RouteProcessor`中调用了`parseRoutes()`，用来处理所有被`@Route`注解的元素。在分析上述三个java文件如何生成之前，先看看生成文件的具体代码。\n\n*   ARouter$$Root$$app类\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n*   ARouter$$Group$$test类\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/test/test1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/test1\", \"test\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   ARouter$$Providers$$app类\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n  }\n}\n\n```\n\n我们接着分析上述三个文件是如何生成的\n\n1.首先获取生成方法的参数的类型和参数名称\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n\n            logger.info(\">>> Found routes, size is \" + routeElements.size() + \" <<<\");\n\n            rootMap.clear();\n             // TypeElement 表示一个类或接口元素\n            // public static final String ACTIVITY = \"android.app.Activity\";\n            //得到类activity元素\n            TypeElement type_Activity = elementUtil.getTypeElement(ACTIVITY);\n            // public static final String SERVICE = \"android.app.Service\";\n            //得到类service的元素\n            TypeElement type_Service = elementUtil.getTypeElement(SERVICE);\n            // public static final String SERVICE = \"android.app.Fragment\";\n            TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();\n             // public static final String SERVICE = \"android.support.v4.app.Fragment\";\n            TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();\n\n            // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IRouteGroup\";\n            //得到接口IRouteGroup元素\n            TypeElement type_IRouteGroup = elementUtil.getTypeElement(IROUTE_GROUP);\n          // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IProviderGroup\";\n            //得到接口IProviderGroup元素\n            TypeElement type_IProviderGroup = elementUtil.getTypeElement(IPROVIDER_GROUP);\n            //获取RouteMeta，RouteType类名\n            ClassName routeMetaCn = ClassName.get(RouteMeta.class);\n            ClassName routeTypeCn = ClassName.get(RouteType.class);\n\n            //下面代码是获取生成java文件中方法的参数类型名称和参数名称。\n            /*\n              获取获取ARouter$$Root$$app 类中方法参数Map<String, Class<? extends IRouteGroup>>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ParameterizedTypeName.get(\n                            ClassName.get(Class.class),\n                            WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))\n                    )\n            );\n\n            /*\n              获取ARouter$$Group$$test，ARouter$$Providers$$app类中方法参数 Map<String, RouteMeta>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ClassName.get(RouteMeta.class)\n            );\n\n            /*\n             获取相关的参数\n             */\n            //获取ARouter$$Root$$app 类中方法的参数Map<String, Class<? extends IRouteGroup>> routes\n            ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, \"routes\").build();\n           //获取ARouter$$Group$$test类中方法的参数Map<String, RouteMeta> atlas\n            ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"atlas\").build();\n             //获取ARouter$$Providers$$app类中方法的参数Map<String, RouteMeta> providers\n            ParameterSpec providerParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"providers\").build();  \n\n          .....\n        }\n    }\n\n```\n\n2.获取了方法的参数的类型和参数名称后，下面便是生成相应的方法\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n            /*\n              首先创建ARouter$$Root$$xxx 类中的loadInto()方法\n              @Override\n              public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(rootParamSpec);\n\n            //  遍历所有被@Route注解的元素\n            for (Element element : routeElements) {\n                TypeMirror tm = element.asType();\n                Route route = element.getAnnotation(Route.class);\n                RouteMeta routeMete = null;\n\n                //判断该元素否为 Activity 、IProvider 、 Service 的子类，然后创建相应的RouteMeta 对象\n                if (typeUtil.isSubtype(tm, type_Activity.asType())) {                 // Activity\n                    logger.info(\">>> Found activity route: \" + tm.toString() + \" <<<\");\n\n                    // 如果是acitiviy类型，获取所有被@Autowired的属性\n                    //关于@Autowired的注解，我们之后再进行分析\n                    Map<String, Integer> paramsType = new HashMap<>();\n                    for (Element field : element.getEnclosedElements()) {\n                        if (field.getKind().isField() && field.getAnnotation(Autowired.class) != null && !typeUtil.isSubtype(field.asType(), iProvider)) {\n                            // It must be field, then it has annotation, but it not be provider.\n                            Autowired paramConfig = field.getAnnotation(Autowired.class);\n                            paramsType.put(StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name(), TypeUtils.typeExchange(field.asType()));\n                        }\n                    }\n                    // ACTIVITY类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.ACTIVITY, paramsType);\n                } else if (typeUtil.isSubtype(tm, iProvider)) {         // IProvider\n                    logger.info(\">>> Found provider route: \" + tm.toString() + \" <<<\");\n                    //从该判断可看出，如果要想成功注册一个 PROVIDER 类型的路由节点，\n                    //一定要实现 com.alibaba.android.arouter.facade.template.IProvider 这个接口\n                    routeMete = new RouteMeta(route, element, RouteType.PROVIDER, null);\n                } else if (typeUtil.isSubtype(tm, type_Service.asType())) {           // Service\n                    logger.info(\">>> Found service route: \" + tm.toString() + \" <<<\");\n                     //SERVICE类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(SERVICE), null);\n                } else if (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) {\n                    logger.info(\">>> Found fragment route: \" + tm.toString() + \" <<<\");\n                   //FRAGMENT类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(FRAGMENT), null);\n                }\n\n                //routeMete包含了每个路由节点的各种信息，下面的方法的主要功能就是根据@Route注解信息对节点进行分组，保存在groupMap集合中。\n               //关于方法的具体实现，后面会有解析\n                categories(routeMete);\n\n            }\n\n            .........\n        }\n    }\n\n```\n\n以上代码主要功能就是遍历所有被@Route注解的元素，然后将每个路由节点的信息按照类型（ACTIVITY类型，实现了IProvider 接口类型以及SERVICE类型）封装到`RouteMeta`中，最后调用`categories(routeMete)`方法将节点分组，保存在`groupMap`集合。\n\n继续往下分析\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n             /*\n              然后创建ARouter$$Providers$$xxx 类中的loadInto()方法\n             @Override\n             public void loadInto(Map<String, RouteMeta> providers) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfProviderBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(providerParamSpec);\n\n            //遍历分组的集合，生成相应的java文件\n           //因为本文使用的例子没有对页面进行分组，所以只生成了一个组文件ARouter$$Group$$xxx\n            for (Map.Entry<String, Set<RouteMeta>> entry : groupMap.entrySet()) {\n                String groupName = entry.getKey();\n               /*\n                  创建ARouter$$Group$$xxx 类中的loadInto()方法\n                 @Override\n                 public void loadInto(Map<String, RouteMeta> atlas) {}\n             */\n                MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                        .addAnnotation(Override.class)\n                        .addModifiers(PUBLIC)\n                        .addParameter(groupParamSpec);\n\n                // 生成loadInto()方法体\n                Set<RouteMeta> groupData = entry.getValue();\n                //遍历每个组里面的路由节点\n                for (RouteMeta routeMeta : groupData) {\n                    switch (routeMeta.getType()) {\n                        //如果节点类型是PROVIDER，\n                        case PROVIDER:  \n                          //获取路由节点元素的接口集合\n                            List<? extends TypeMirror> interfaces = ((TypeElement) routeMeta.getRawType()).getInterfaces();\n                            for (TypeMirror tm : interfaces) {\n                             if (types.isSameType(tm, iProvider)) {   // Its implements iProvider interface himself.\n                                   //路由节点元素其中一个接口是 com.alibaba.android.arouter.facade.template.IProvider \n                                  //给ARouter$$Providers$$xxx 类中的loadInto()添加方法体\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            (routeMeta.getRawType()).toString(),//路由节点元素的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                } else if (types.isSubtype(tm, iProvider)) {\n                                   //路由节点元素其中一个接口是com.alibaba.android.arouter.facade.template.IProvider 接口的子类型\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            tm.toString(),   //IProvider子类型的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                }\n                            //上面方法体的代码为：\n                          //providers.put(\"实现接口的名称\", RouteMeta.build(RouteType.PROVIDER, 类名.class,   \"@Route.path\", \"@Route.group\", null, @Route.priority, @Route.extras));\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n\n                    // 将路由节点中被@Autowired注解的属性集合转换成字符串\n                    StringBuilder mapBodyBuilder = new StringBuilder();\n                    //获取路由节点中被@Autowired注解的属性集合\n                    Map<String, Integer> paramsType = routeMeta.getParamsType();\n                    if (MapUtils.isNotEmpty(paramsType)) {\n                        for (Map.Entry<String, Integer> types : paramsType.entrySet()) {\n                            mapBodyBuilder.append(\"put(\\\"\").append(types.getKey()).append(\"\\\", \").append(types.getValue()).append(\"); \");\n                        }\n                    }\n                    String mapBody = mapBodyBuilder.toString();\n\n                    //给ARouter$$Group$$xxx 类中的loadInto()添加方法体\n                    //注意：有多个分组就会创建多个组文件\n                    loadIntoMethodOfGroupBuilder.addStatement(\n                            \"atlas.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, \" + (StringUtils.isEmpty(mapBody) ? null : (\"new java.util.HashMap<String, Integer>(){{\" + mapBodyBuilder.toString() + \"}}\")) + \", \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                            routeMeta.getPath(),\n                            routeMetaCn,\n                            routeTypeCn,\n                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                            routeMeta.getPath().toLowerCase(),\n                            routeMeta.getGroup().toLowerCase());\n                }\n\n                  // 真正生成ARouter$$Group$$test JAVA文件\n                 //NAME_OF_GROUP = ARouter$$Group$$\n                //  groupName = test; 关于groupname的值在方法categories(routeMete)中会有讲解\n                String groupFileName = NAME_OF_GROUP + groupName;\n                JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                        TypeSpec.classBuilder(groupFileName)\n                                .addJavadoc(WARNING_TIPS)\n                                .addSuperinterface(ClassName.get(type_IRouteGroup))\n                                .addModifiers(PUBLIC)\n                                .addMethod(loadIntoMethodOfGroupBuilder.build())\n                                .build()\n                ).build().writeTo(mFiler);\n\n                logger.info(\">>> Generated group: \" + groupName + \"<<<\");\n                //将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备\n                rootMap.put(groupName, groupFileName);\n            }\n\n         .......\n        }\n    }\n\n```\n\n以上代码主要功能由几点：\n\n*   遍历`groupmap`集合给ARouter$$Group$$xxx类中的`loadInto()`添加方法体，并且生成ARouter$$Group$$xxx JAVA文件，而文件命名为ARouter$$Group$$+groupname，其中有多个分组就会创建多个组文件。比如`AROUTER`源码中的样例就生成了多个分组文件\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n\n两个分组文件\n\n关于生成的`loadInto()`中的方法体的例子，来自 `AROUTER`源码中的样例：\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    //存在被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/activity1\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"name\", 18); put(\"boy\", 0); put(\"age\", 3); put(\"url\", 18); }}, -1, -2147483648));\n    .....\n   //没有被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity4\", RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, \"/test/activity4\", \"test\", null, -1, -2147483648));\n    ....\n  }\n}\n\n```\n\n*   遍历每个组里面的路由节点，查找节点类型是否为PROVIDER类型，如果是就向给ARouter$$Providers$$xxx类中的`loadInto()`添加方法，其文件命名ARouter$$Providers$$+modulename。关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.HelloService\", RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, \"/service/hello\", \"service\", null, -1, -2147483648));\n    //路由节点元素其中一个接口是IProvider的子类型\n    providers.put(\"com.alibaba.android.arouter.facade.service.SerializationService\", RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, \"/service/json\", \"service\", null, -1, -2147483648));\n     //路由节点元素其中一个接口是IProvider接口\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.SingleService\", RouteMeta.build(RouteType.PROVIDER, SingleService.class, \"/service/single\", \"service\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备，其文件命名ARouter$$Root$$+modulename。\n\n我们接着分析`parseRoutes()`方法最后一段代码，这段代码其实很简单，主要目的就是给ARouter$$Root$$xxx的`loadInto()`添加方法体，最后生成Router$$Providers$$xxx，ARouter$$Root$$xxx文件\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n            //遍历rootMap集合，给ARouter$$Root$$xxx的`loadInto()`添加方法体\n            if (MapUtils.isNotEmpty(rootMap)) {\n                // Generate root meta by group name, it must be generated before root, then I can findout the class of group.\n                for (Map.Entry<String, String> entry : rootMap.entrySet()) {\n                    loadIntoMethodOfRootBuilder.addStatement(\"routes.put($S, $T.class)\", entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));\n                }\n            }\n\n            // 生成Router$$Providers$$xxx文件\n            String providerMapFileName = NAME_OF_PROVIDER + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(providerMapFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(type_IProviderGroup))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfProviderBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated provider map, name is \" + providerMapFileName + \" <<<\");\n\n            // 生成ARouter$$Root$$xxx文件\n            String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(rootFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(elementUtil.getTypeElement(ITROUTE_ROOT)))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfRootBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated root, name is \" + rootFileName + \" <<<\");\n        }\n    }\n\n```\n\n关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"service\", ARouter$$Group$$service.class);\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n**上面分析的便是`parseRoutes()`方法所有代码的解析**\n\n3.最后我们看下`categories()`方法是如何分组的\n\n```\n   private void categories(RouteMeta routeMete) {\n        //如果路由路径合法，且有groupname进行执行\n        if (routeVerify(routeMete)) {\n            logger.info(\">>> Start categories, group = \" + routeMete.getGroup() + \", path = \" + routeMete.getPath() + \" <<<\");\n             //根据groupname获取该组的路由节点集合，如果集合为空，则创建一个新的组，将该节点添加进去，并将组集合保存在groupmap中；\n          //不为空，则添加到所属的组集合中去\n            Set<RouteMeta> routeMetas = groupMap.get(routeMete.getGroup());\n            if (CollectionUtils.isEmpty(routeMetas)) {\n                Set<RouteMeta> routeMetaSet = new TreeSet<>(new Comparator<RouteMeta>() {\n                    @Override\n                    public int compare(RouteMeta r1, RouteMeta r2) {\n                        try {\n                            return r1.getPath().compareTo(r2.getPath());\n                        } catch (NullPointerException npe) {\n                            logger.error(npe.getMessage());\n                            return 0;\n                        }\n                    }\n                });\n                routeMetaSet.add(routeMete);\n                groupMap.put(routeMete.getGroup(), routeMetaSet);\n            } else {\n                routeMetas.add(routeMete);\n            }\n        } else {\n            logger.warning(\">>> Route meta verify error, group is \" + routeMete.getGroup() + \" <<<\");\n        }\n    }\n\n//判断路由路径是否合法，并且设置groupname\n private boolean routeVerify(RouteMeta meta) {\n        String path = meta.getPath();\n        //如果路径为空，或者不是由'/'开头，返回false\n        if (StringUtils.isEmpty(path) || !path.startsWith(\"/\")) {   // The path must be start with '/' and not empty!\n            return false;\n        }\n\n         //如果在@Route注解中没有设置group标识，那么就默认取path路径第一段路径名作为groupname\n        if (StringUtils.isEmpty(meta.getGroup())) { // Use default group(the first word in path)\n            try {\n                String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n                if (StringUtils.isEmpty(defaultGroup)) {\n                    return false;\n                }\n\n                meta.setGroup(defaultGroup);\n                return true;\n            } catch (Exception e) {\n                logger.error(\"Failed to extract default group! \" + e.getMessage());\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n```\n\n通过分析，如果@Route注解中有设置group标识，作为groupname，如果没有就取/xxx1/xxx2，xxx1作为groupname，并将同一组的路由节点放到同一个集合中去。\n\n至此关于`@Route`注解在编译期时生成ARouter$$Root$$xxx，Router$$Providers$$xxx，ARouter$$Group$$xxx三种映射文件的源码分析完毕。\n\n###### 2.ARouter初始化过程\n\nARouter经过代码编译后，生成了相应的映射文件，我们可以断定，ARouter 的初始化会将这些文件加载到内存中去，形成一个路由表，以供后面路由查找跳转之用。其相关源码可参见 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `ARouter`的`init()`方法\n\n```\npublic static void init(Application application) {\n        if (!hasInit) {\n            logger = _ARouter.logger;\n            _ARouter.logger.info(Consts.TAG, \"ARouter init start.\");\n            hasInit = _ARouter.init(application);\n\n            if (hasInit) {\n                _ARouter.afterInit();\n            }\n\n            _ARouter.logger.info(Consts.TAG, \"ARouter init over.\");\n        }\n    }\n\n```\n\n由上面代码可以看出，其初始化实际上是调用了`_ARouter` 的 `init ()`方法，而且其他的跳转方法最终调用的也是`_ARouter` 种的方法。\n\n*   `_ARouter`的`init()`方法\n\n```\n  protected static synchronized boolean init(Application application) {\n        mContext = application;\n        LogisticsCenter.init(mContext, executor);\n        logger.info(Consts.TAG, \"ARouter init success!\");\n        hasInit = true;\n\n        return true;\n    }\n\n```\n\n`_ARouter`中又调用了`LogisticsCenter.init()`，继续追踪下去，其中传入了一个线程池`executor`，这个线程池在拦截器的时候会使用到。\n\n```\n    public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n        mContext = context;\n        executor = tpe;\n\n        try {\n             //ROUTE_ROOT_PAKCAGE = \"com.alibaba.android.arouter.routes\"\n            // 获取ROUTE_ROOT_PAKCAGE 包里面的所有文件\n            List<String> classFileNames = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n\n            //遍历所有ROUTE_ROOT_PAKCAGE 包里的文件\n            for (String className : classFileNames) {\n                //文件名以“com.alibaba.android.arouter.routes.ARouter$$Root”开头执行下面代码\n                if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                    // 通过反射实例化，并且调用loadInto()，目的即是将编译生成的ARouter$$Group$$xxx文件加载到内存中，保存在Warehouse.groupsIndex；\n                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n                    //文件名以“com.alibaba.android.arouter.routes.ARouter$$Interceptors”开头执行下面代码\n                    //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()，将自定义拦截器类存放在Warehouse.interceptorsIndex中\n                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n                     //文件名以“com.alibaba.android.arouter.routes.ARouter$$Providers”开头执行下面代码\n                   //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()\n                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n                }\n            }\n\n            if (Warehouse.groupsIndex.size() == 0) {\n                logger.error(TAG, \"No mapping files were found, check your configuration please!\");\n            }\n\n            if (ARouter.debuggable()) {\n                logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));\n            }\n        } catch (Exception e) {\n            throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n        }\n    }\n\n```\n\n*   `_ARouter`的`afterInit()`方法\n\n```\nstatic void afterInit() {\n        // 通过路由机制，初始化路由拦截机制。关于路由拦截机制的使用和原理，后续文章会有分析\n        interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation();\n    }\n\n```\n\n以上就是ARouter初始化的所有代码，关于如何查找到`com.alibaba.android.arouter.routes`包内所有文件这里便不做过多分析，大家可以去阅读 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)中`ClassUtils`这个类的源码。\n**总结下来，其实ARouter 的初始化只做了一件事，找到自己编译期产生的清单文件，把 Group 、Interceptor 、Provider 三种清单加载到 Warehouse 内存仓库中。**即下面这些文件，来源自AROUTER源码中的样例\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n\n值得注意的是，在初始化阶段，ARouter 仅载入了 Group 清单，并没有具体载入每个 Group 中包含的具体的路由节点清单，只有当使用到具体的 Group 时，才会加载对应的 Group 列表。这种分组管理，按需加载，大大的降低了初始化时的内存压力。并且`Warehouse`类中保存了路由清单，并且将使用过的路由对象缓存起来，之后查找都是直接使用缓存的对象 。\n\n###### 3.ARouter调用过程分析\n\n页面跳转最基本方法\n\n> ARouter.getInstance().build(\"/test/activity2\").navigation();\n\n获取Provider服务（实现了IProvider接口以及IProvider子类接口的服务类）的方法有两种：\n\n> 1.byName方式\n> ARouter.getInstance().build(\"/service/hello\").navigation()\n\n> 2.byType方式\n> ARouter.getInstance().navigation(HelloService.class)\n\nARouter路由跳转采用链式调用，`ARouter.getInstance()`其中采用的单例模式，获取ARouter的实例，这个就不作过多分析，主要分析`build()`和`navigation()`。\n\n**build()方法**\nARouter的`build(String path)`和`init()`方法一样，调用的是`_ARouter`的`build(String path)`方法。\n\n```\n  protected Postcard build(String path) {\n        if (TextUtils.isEmpty(path)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return build(path, extractGroup(path));\n        }\n    }\n\n```\n\n其中`extractGroup(String path)`就是根据path获取分组名，即path第一段“/”符号之间的值\n\n```\n  private String extractGroup(String path) {\n        if (TextUtils.isEmpty(path) || !path.startsWith(\"/\")) {\n            throw new HandlerException(Consts.TAG + \"Extract the default group failed, the path must be start with '/' and contain more than 2 '/'!\");\n        }\n\n        try {\n            //    /xxx1/xxx2   ===>  defaulGroup = xxx1\n            String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n            if (TextUtils.isEmpty(defaultGroup)) {\n                throw new HandlerException(Consts.TAG + \"Extract the default group failed! There's nothing between 2 '/'!\");\n            } else {\n                return defaultGroup;\n            }\n        } catch (Exception e) {\n            logger.warning(Consts.TAG, \"Failed to extract default group! \" + e.getMessage());\n            return null;\n        }\n    }\n\n```\n\n`build(String path)`方法最终调用的是`build(String path, String group)`\n\n```\n    protected Postcard build(String path, String group) {\n        if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return new Postcard(path, group);\n        }\n    }\n\n```\n\n**值得注意的是其中`ARouter.getInstance().navigation(PathReplaceService.class)`就是得到实现`PathReplaceService`接口的一个服务对象，对原始path进行处理后，生成新的path路径。而这个类需要我们自己自定义去实现，如果没有实现，pService=null，原始path不做任何处理。**\n下面是`PathReplaceService`接口，我们可以通过实现`forString()`和`forUri()`方法，对某些url进行替换处理，跳转到其他的目标页面。\n\n```\npublic interface PathReplaceService extends IProvider {\n\n    /**\n     * For normal path.\n     *\n     * @param path raw path\n     */\n    String forString(String path);\n\n    /**\n     * For uri type.\n     *\n     * @param uri raw uri\n     */\n    Uri forUri(Uri uri);\n}\n\n```\n\n最后返回一个`Postcard`实例对象，里面封装了路由节点的路径，分组等节点信息。其实`build()`方法的目的只有一个就是根据路由，封装成`Postcard`对象，其对象贯穿之后整个路由过程。Postcard 包含了众多的属性值，提供了路由过程中所有的控制变量。\n\n```\npublic final class Postcard extends RouteMeta {\n    private Uri uri;\n    private Object tag;             // A tag prepare for some thing wrong.\n    private Bundle mBundle;         // 传递的参数\n    private int flags = -1;         // intent 的flag标志\n    private int timeout = 300;      // Navigation timeout, TimeUnit.Second !\n    private IProvider provider;     // IProvider服务对象\n    private boolean greenChannal;\n    private SerializationService serializationService;//序列化服务对象\n\n     // 跳转动画\n    private Bundle optionsCompat;    // The transition animation of activity\n    private int enterAnim;\n    private int exitAnim;\n\n    // copy from RouteMeta \n    private RouteType type;         // 路由节点类型\n    private Element rawType;        \n    private Class<?> destination;  //需要跳转到的页面\n    private String path;            // 路径\n    private String group;           // 分组\n    private int priority = -1;      // 优先级\n    private int extra;              // 配置标识\n    private Map<String, Integer> paramsType;  // 路由页面被@Autowired注解属性\n    // ......\n}\n\n```\n\n**navigation()方法**\n关于页面跳转的`navigation()`方法有多个重载的方法，但最终都会调用`_ARouter`下面这个方法\n\n```\n    protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        try {\n            //首先对postcard进行一些处理，设置postcard的destination，type，priority 等一些属性值，completion()后面会有分析\n            LogisticsCenter.completion(postcard);\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n\n            if (debuggable()) { // Show friendly tips for user.\n                Toast.makeText(mContext, \"There's no route matched!\\n\" +\n                        \" Path = [\" + postcard.getPath() + \"]\\n\" +\n                        \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show();\n            }\n            // 如果处理postcard失败，通过 callback 回调失败结果\n           // callback为空的情况下，如果有定义全局的降级处理（DegradeService），则使用全局处理\n           //降级处理也需要我们自己实现DegradeService接口\n            if (null != callback) {\n                callback.onLost(postcard);\n            } else {    // No callback for this invoke, then we use the global degrade service.\n                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);\n                if (null != degradeService) {\n                    degradeService.onLost(context, postcard);\n                }\n            }\n\n            return null;\n        }\n         //路由处理成功，回调callback.onFound()\n        if (null != callback) {\n            callback.onFound(postcard);\n        }\n\n        //目前来说，PROVIDER服务类型，以及FRAGMENT类型不需要通过拦截器外，其他类型均需要通过拦截器\n        //关于拦截器相关用法及原理分析在后续的文章中会讲解到，大家去可以关注下\n        if (!postcard.isGreenChannel()) {   \n            interceptorService.doInterceptions(postcard, new InterceptorCallback() {\n                /**\n                 * Continue process\n                 *\n                 * @param postcard route meta\n                 */\n                @Override\n                public void onContinue(Postcard postcard) {\n                    _navigation(context, postcard, requestCode, callback);\n                }\n\n                /**\n                 * Interrupt process, pipeline will be destory when this method called.\n                 *\n                 * @param exception Reson of interrupt.\n                 */\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    if (null != callback) {\n                        callback.onInterrupt(postcard);\n                    }\n\n                    logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage());\n                }\n            });\n        } else {\n            return _navigation(context, postcard, requestCode, callback);\n        }\n\n        return null;\n    }\n\n```\n\n**值得注意的是，当跳转路由处理失败的时候，会获取一个降级服务，我们可以实现`DegradeService`接口，实现`onLost()`方法，对路由处理失败的情况进行处理，比如跳转到一个信息提示页面，让用户去更新版本等操作等。** 下面是`DegradeService`接口：\n\n```\npublic interface DegradeService extends IProvider {\n\n    /**\n     * Router has lost.\n     *\n     * @param postcard meta\n     */\n    void onLost(Context context, Postcard postcard);\n}\n\n```\n\n通过上面代码的分析，不管是否通过拦截器进行处理，最后都会调用`_navigation()`达到路由的目的：\n\n```\nprivate Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                //下面就是最基本的使用intent进行activity进行跳转\n                // 创建intent\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                //设置传参\n                intent.putExtras(postcard.getExtras());\n\n                //activity启动标志\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n\n                // 在主线程中进行跳转\n                new Handler(Looper.getMainLooper()).post(new Runnable() {\n                    @Override\n                    public void run() {\n                        //新版本带转场动画的启动方式\n                        if (requestCode > 0) {  // Need start for result\n                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());\n                        } else {\n                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());\n                        }\n\n                        if ((0 != postcard.getEnterAnim() || 0 != postcard.getExitAnim()) && currentContext instanceof Activity) {    // Old version.\n                            //老版本的跳转动画\n                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());\n                        }\n                        //跳转成功，回调callback.onArrival()\n                        if (null != callback) { // Navigation over.\n                            callback.onArrival(postcard);\n                        }\n                    }\n                });\n\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                     //实例化fragment，并传递参数\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n\n```\n\n目前仅ARouter实现了 ACTIVITY ， PROVIDER ，FRAGMENT三种种类型。上面关于postcard的provider，destination的值都是在`completion()`中设置的。我们接着看`LogisticsCenter`的`completion(Postcard postcard)`。\n\n```\n    public synchronized static void completion(Postcard postcard) {\n        if (null == postcard) {\n            throw new NoRouteFoundException(TAG + \"No postcard!\");\n        }\n\n        // 查找Warehouse仓库的路由节点缓存，看是否已在缓存中\n        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n        if (null == routeMeta) {   \n          // 如果没有，查找仓库的组别清单中是否存在该组别，组别清单已经在初始化的时候加载到仓库中去了\n            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  \n            //如果没有抛出异常\n            if (null == groupMeta) {\n                throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n            } else {\n                // Load route and cache it into memory, then delete from metas.\n                try {\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                    // 实例化个组别的类，调用loadInto()，将组别中所有的路由节点加载进仓库Warehouse.routes，缓存\n                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n                    iGroupInstance.loadInto(Warehouse.routes);\n                     // 从组别清单中删除已加载的组别，防止重复加载\n                    Warehouse.groupsIndex.remove(postcard.getGroup());\n\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                } catch (Exception e) {\n                    throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\");\n                }\n                //当路由节点加载到缓存中去后，重新查找执行else代码，对postcard进行处理\n                completion(postcard);   // Reload\n            }\n        } else {\n            //给postcard设置destination,type,priority等值，供上面讲解到的_navigation()进行使用\n            // 其中routeMeta是在ARouter$$Group$$xxx的loadInto中创建的\n            postcard.setDestination(routeMeta.getDestination());\n            postcard.setType(routeMeta.getType());\n            postcard.setPriority(routeMeta.getPriority());\n            postcard.setExtra(routeMeta.getExtra());\n\n            //如果通过build(Uri url) 进行跳转的话 通过解析url ，将传参保存进bundle中\n            Uri rawUri = postcard.getUri();\n            if (null != rawUri) {  \n                //splitQueryParameters()就是在uri中携带的参数进行解析\n                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);\n                Map<String, Integer> paramsType = routeMeta.getParamsType();\n\n                if (MapUtils.isNotEmpty(paramsType)) {\n                    // Set value by its type, just for params which annotation by @Param\n                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {\n                        setValue(postcard,\n                                params.getValue(),\n                                params.getKey(),\n                                resultMap.get(params.getKey()));\n                    }\n\n                    // Save params name which need autoinject.\n                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));\n                }\n\n                // Save raw uri\n                postcard.withString(ARouter.RAW_URI, rawUri.toString());\n            }\n\n            //从这里也可以看出PROVIDER，FRAGMENT不需要通过拦截器\n            switch (routeMeta.getType()) {\n                case PROVIDER:  \n                    // 如果是PROVIDER节点类型，从服务节点列表中获取，如果没有，则实例化，并保存在服务节点列表Warehouse.providers中\n                  //并将实例化的对象设置给postcard的provider属性\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    if (null == instance) { // There's no instance of this provider\n                        IProvider provider;\n                        try {\n                            provider = providerMeta.getConstructor().newInstance();\n                            provider.init(mContext);\n                            Warehouse.providers.put(providerMeta, provider);\n                            instance = provider;\n                        } catch (Exception e) {\n                            throw new HandlerException(\"Init provider failed! \" + e.getMessage());\n                        }\n                    }\n                    postcard.setProvider(instance);\n                    postcard.greenChannel();    // Provider should skip all of interceptors\n                    break;\n                case FRAGMENT:\n                    postcard.greenChannel();    // Fragment needn't interceptors\n                default:\n                    break;\n            }\n        }\n    }\n\n```\n\n分析到这里，关于页面基本跳转的原理分析就已经结束了。最后就是关于获取Provider服务两种方法的源码分析。其中byName方式，和页面跳转是一模一样的。我们只需要看看byType方式即可。byType方式最后调用的是`_ARouter`的`navigation(Class<? extends T> service)`\n\n```\n  protected <T> T navigation(Class<? extends T> service) {\n        try {\n            // 通过 className 获取 Postcard 对象\n            Postcard postcard = LogisticsCenter.buildProvider(service.getName());\n\n            // 兼容1.0.5 compiler sdk版本.\n            if (null == postcard) { // No service, or this service in old version.\n                postcard = LogisticsCenter.buildProvider(service.getSimpleName());\n            }\n           // 对 Postcard 对象进行处理\n            LogisticsCenter.completion(postcard);\n             //返回 Postcard 中的 provider 属性值\n            return (T) postcard.getProvider();\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n            return null;\n        }\n    }\n\n```\n\n上面代码中的`completion()`方法之前已经分析过了，只需要看下`LogisticsCenter.buildProvider(service.getName())`即可。\n\n```\n  public static Postcard buildProvider(String serviceName) {\n        RouteMeta meta = Warehouse.providersIndex.get(serviceName);\n\n        if (null == meta) {\n            return null;\n        } else {\n            return new Postcard(meta.getPath(), meta.getGroup());\n        }\n    }\n\n```\n\n这个方法非常的简单，就是根据服务类名去仓库Warehouse.providersIndex中获去路由节点元素，然后封装在Postcard对象中。服务类清单列表Warehouse.providersIndex中的值是在初始化时缓存的。**值得注意的是，PROVIDER 类型的路由节点既存在于对应的分组中，也存在于服务类清单列表中。所以，ARouter 可通过byType，byName两种方式来获取**。\n\n##### 补充\n\n关于ARouter的基本用法上面只有最基本跳转的介绍，下面对其他一些基本使用进行下补充\n\n*   **带参数跳转**\n\n```\n//1.传递参数\n ARouter.getInstance().build(\"/test/activity1\")\n                        .withString(\"name\", \"老王\")\n                        .withInt(\"age\", 18)\n                        .withBoolean(\"boy\", true)\n                        .withLong(\"high\", 180)\n                        .withString(\"url\", \"https://a.b.c\")\n                        .withParcelable(\"pac\", testParcelable)\n                        .withObject(\"obj\", testObj)\n                        .navigation();\n\n//2.直接传递Bundle\n  Bundle params = new Bundle();\n  ARouter.getInstance()\n          .build(\"/test/activity1\")\n          .with(params)\n          .navigation();\n\n```\n\n这些传参都是保存在生成的`postcard`对象中的`mBundle`属性里，然后在跳转的时候通过`intent.putExtras(postcard.getExtras())`达到传送参数的目的。\n值得注意的是，关于对象的传递有两种，一种是`withParcelable()`方法，不过此方法需要传递的对象实现`Parcelable`接口，达到序列化的目的；另外一种是`withObject()`方法，此方法的原理是将实体类转换成json字符串，通过String的方式进行传递，而且使用这种方式需要实现 SerializationService，并使用@Route注解标注，下面是ARouter样例：\n\n```\n@Route(path = \"/service/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n\n```\n\n而且，需要在跳转到的页面获取`JsonServiceImpl`服务，将json字符串转换成对象。\n\n```\nSerializationService serializationService = ARouter.getInstance().navigation(SerializationService.class);\nTestObj obj = serializationService.json2Object(getIntent().getString(\"obj\"), TestObj.class);\n\n```\n\n*   **带返回结果跳转**\n\n```\nARouter.getInstance().build(\"/test/activity2\").navigation(this, 666);\n\n```\n\n值得注意的是，这时候的 `navigation`需要传递activit和requestCode。\n\n*   **获取Fragment的实例**\n\n定义一个fragment\n\n```\n@Route(path = \"/test/fragment\")\npublic class BlankFragment extends Fragment {\n    public BlankFragment() {\n        //必须要一个空的构造器\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        TextView textView = new TextView(getActivity());\n        return textView;\n    }\n\n}\n\n```\n\n获取frament\n\n```\nFragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation();\n\n```\n\n*   **带转场动画跳转**\n\n```\n// 转场动画(常规方式)\n ARouter.getInstance() .build(\"/test/activity2\")\n                      .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)\n                      .navigation(this);\n\n// 转场动画(API16+)\n ActivityOptionsCompat compat = ActivityOptionsCompat.makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);\nARouter.getInstance().build(\"/test/activity2\").withOptionsCompat(compat) .navigation();\n\n```\n\n*   **获取服务**\n\n服务是全局单例的，只有在第一次使用到的时候才会被初始化。\n暴露服务，必须实现IProvider 接口 或者其子类型\n\n```\n// 声明接口,其他组件通过接口来调用服务\npublic interface HelloService extends IProvider {\n    String sayHello(String name);\n}\n\n// 实现接口\n@Route(path = \"/service/hello\", name = \"测试服务\")\npublic class HelloServiceImpl implements HelloService {\n\n    @Override\n    public String sayHello(String name) {\n    return \"hello, \" + name;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n}\n\n```\n\n获取服务\n\n```\n//bytype\nHelloService helloService1 = ARouter.getInstance().navigation(HelloService.class);\n//byname\nHelloService helloService2 = (HelloService) ARouter.getInstance().build(\"/service/hello\").navigation();\n\n```\n\n*   **多模块结构**\n\n"],[-1,52078,"\n\n**如果各位同学认为本文对你有一些帮助，希望能点个喜欢，谢谢！**\n\n小礼物走一走，来简书关注我\n\n赞赏支持\n\n[android开发问题](/nb/12473806)\n\n© 著作权归作者所有\n\n举报文章\n\n[![96](//upload.jianshu.io/users/upload_avatars/5994347/dd34592b-ad62-4e24-bb66-f7c689766b2f.png?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96) ](/u/d65e2e163603) 关注 [time_fly](/u/d65e2e163603)\n\n写了 24037 字，被 37 人关注，获得了 92 个喜欢\n\n喜欢\n\n12\n\n[](javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f='http://v.t.sina.com.cn/share/share.php?appkey=1881139527',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function%20a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,'','','', '推荐 @龍儱滝 的文章《阿里ARouter使用及源码解析（一）》（ 分享自 @简书 ）','https://www.jianshu.com/p/46d174f37e82?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo','页面编码gb2312|utf-8默认gb2312'));)[](http://cwb.assets.jianshu.io/notes/images/13526520/weibo/image_bcbd18a5f866.png)[更多分享](javascript:void(0);)\n\n![](//upload.jianshu.io/users/upload_avatars/1786025/f63ccf82f6f8?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114) \n\n3条评论 只看作者 关闭评论\n\n按喜欢排序按时间正序按时间倒序\n\n[![](//cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/ab7bfd384c72)\n\n[winter818](/u/ab7bfd384c72)\n\n2楼 · 2017.08.23 17:56\n\n666 学习了\n\n1人赞 回复 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/426662/e85a4080db83?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/a2a56d463e3d)\n\n[夏鸣浩](/u/a2a56d463e3d)\n\n3楼 · 2017.09.04 17:40\n\n正在拜读，博主辛苦\n\n赞 回复 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/7293029/42130be5-9eb3-4cf2-8874-1f32e70d81e2?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/df76f81fe3ff)\n\n[却把清梅嗅2](/u/df76f81fe3ff)\n\n4楼 · 2017.12.13 16:23\n\n好文，楼主辛苦\n\n赞 回复 举报"]],[54215,54215],[0,484]]],[1519699683840,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,0,"在app的开发中，页面之间的相互跳转是最基本常用的功能。在Android中的跳转一般通过显式intent和隐式intent两种方式实现的，而Android的原生跳转方式会存在一些缺点：\n\n*   显式intent的实现方式，因为会存在直接的类依赖的问题，导致耦合严重；\n*   隐式intent的实现方式，则会出现规则集中式管理，导致协作变得困难；\n*   可配置性较差，一般而言配置规则都是在Manifest中的，这就导致了扩展性较差；\n*   跳转过程无法控制，一旦使用了StartActivity()就无法插手其中任何环节了，只能交给系统管理；\n*   当多组件化开发，使用原生的路由方式很难实现完全解耦；\n\n而阿里的[ARouter](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)路由框架具有解耦、简单易用、支持多模块项目、定制性较强、支持拦截逻辑等诸多优点，很好的解决了上述的问题。关于ARouter具体实现功能，典型应用以及相应技术方案实现的介绍不在这详细介绍，具体可参见[开源最佳实践：Android平台页面路由框架ARouter](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)。\n\n阿里ARouter的分析计划\n\n*   [阿里ARouter使用及源码解析（一）](https://www.jianshu.com/p/46d174f37e82)\n*   [阿里ARouter拦截器使用及源码解析（二）](https://www.jianshu.com/p/c8d7b1379c1b)\n*   阿里ARouter参数自动装载使用及源码解析（三）\n\n##### 基本功能使用\n\n1.添加依赖和配置\n\n```\nandroid {\n    defaultConfig {\n    ...\n    javaCompileOptions {\n        annotationProcessorOptions {\n        arguments = [ moduleName : project.getName() ]\n        }\n    }\n    }\n}\n\ndependencies {\n    compile 'com.alibaba:arouter-api:1.2.1.1'\n    annotationProcessor 'com.alibaba:arouter-compiler:1.1.2.1'\n    ...\n}\n\n```\n\n2.添加注解\n\n```\n// 在支持路由的页面上添加注解(必选)\n// 这里的路径需要注意的是至少需要有两级，/xx/xx\n@Route(path = \"/test/test1\")\npublic class Test1Activity extends AppCompatActivity{\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_test1);\n    }\n}\n\n```\n\n3.初始化SDK\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            // 如果使用了InstantRun，必须在初始化之前开启调试模式，但是上线前需要关闭，InstantRun仅用于开发阶段，\n            // 线上开启调试模式有安全风险，可以使用BuildConfig.DEBUG来区分环境\n            ARouter.openDebug();\n            ARouter.init(getApplication()); // 尽可能早，推荐在Application中初始化\n        }\n    }\n}\n\n```\n\n4.发起跳转操作\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            ....\n        } else if (v.getId() == R.id.btn2){\n            ARouter.getInstance().build(\"/test/test1\").navigation();\n        }\n    }\n}\n\n```\n\n以上相关代码就是ARouter的最基本功能使用的步骤，下面来分析跳转功能是如何实现的。\n\n##### 原理分析\n\n###### 1.ARouter编译的过程\n\nARouter在编译期的时候，利用自定义注解完成了页面的自动注册。相关注解源码参见[arouter-annotation](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)，编译处理器源码参见[arouter-compiler](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n\n下面是注解`@Route`的源码介绍：\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.CLASS)\npublic @interface Route {\n\n    /**\n     *路由的路径，标识一个路由节点\n     */\n    String path();\n\n    /**\n     * 将路由节点进行分组，可以实现按组动态加载\n     */\n    String group() default \"\";\n\n    /**\n     * 路由节点名称，可用于生成javadoc文档\n     */\n    String name() default \"undefined\";\n\n    /**\n     * 用32位int类型标示，可用于页面的一些配置\n     */\n    int extras() default Integer.MIN_VALUE;\n\n    /**\n     * 路由的优先级\n     */\n    int priority() default -1;\n}\n\n```\n\nRoute中的`extra`值是个int值，由32位表示，即转换成二进制后，一个int中可以配置31个1或者0，而每一个0或者1都可以表示一项配置（排除符号位），如果从这31个位置中随便挑选出一个表示是否需要登录就可以了，只要将标志位置为1，就可以在声明的拦截器中获取到这个标志位，通过位运算的方式判断目标页面是否需要登录。所以可以通过`extra`给页面配置30多个属性，然后在拦截器中去进行处理。\nARouter在拦截器中会把目标页面的信息封装一个类`Postcard`，这个类就包含了目标页面注解上`@Route`标识的各种信息。关于拦截器的使用以及源码分析，后续会有介绍。\n\n将代码编译一遍，可以看到ARouter生成下面几个源文件：\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n\n上面三个文件均是通过注解处理器`RouteProcessor`生成的，关于如何自定义注解处理器，可以阅读[Android编译时注解APT实战（AbstractProcessor）](https://www.jianshu.com/p/07ef8ba80562)，同时也需要学习**JavaPoet**的基本使用。下面我们看`RouteProcessor`是如何生成相关文件的。\n\n```\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //判断被注解了的元素集合是否为空\n        if (CollectionUtils.isNotEmpty(annotations)) {\n            //获取所有被@Route注解的元素集合，Element可以是类、方法、变量等\n            Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);\n            try {\n                logger.info(\">>> Found routes, start... <<<\");\n                //具体处理注解，生成java文件的方法\n                this.parseRoutes(routeElements);\n\n            } catch (Exception e) {\n                logger.error(e);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n```\n\n`process()`方法相当于处理器的主函数`main()`，可以在这个方法中扫描、评估和处理注解的代码，以及生成Java文件。`RouteProcessor`中调用了`parseRoutes()`，用来处理所有被`@Route`注解的元素。在分析上述三个java文件如何生成之前，先看看生成文件的具体代码。\n\n*   ARouter$$Root$$app类\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n*   ARouter$$Group$$test类\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/test/test1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/test1\", \"test\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   ARouter$$Providers$$app类\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n  }\n}\n\n```\n\n我们接着分析上述三个文件是如何生成的\n\n1.首先获取生成方法的参数的类型和参数名称\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n\n            logger.info(\">>> Found routes, size is \" + routeElements.size() + \" <<<\");\n\n            rootMap.clear();\n             // TypeElement 表示一个类或接口元素\n            // public static final String ACTIVITY = \"android.app.Activity\";\n            //得到类activity元素\n            TypeElement type_Activity = elementUtil.getTypeElement(ACTIVITY);\n            // public static final String SERVICE = \"android.app.Service\";\n            //得到类service的元素\n            TypeElement type_Service = elementUtil.getTypeElement(SERVICE);\n            // public static final String SERVICE = \"android.app.Fragment\";\n            TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();\n             // public static final String SERVICE = \"android.support.v4.app.Fragment\";\n            TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();\n\n            // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IRouteGroup\";\n            //得到接口IRouteGroup元素\n            TypeElement type_IRouteGroup = elementUtil.getTypeElement(IROUTE_GROUP);\n          // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IProviderGroup\";\n            //得到接口IProviderGroup元素\n            TypeElement type_IProviderGroup = elementUtil.getTypeElement(IPROVIDER_GROUP);\n            //获取RouteMeta，RouteType类名\n            ClassName routeMetaCn = ClassName.get(RouteMeta.class);\n            ClassName routeTypeCn = ClassName.get(RouteType.class);\n\n            //下面代码是获取生成java文件中方法的参数类型名称和参数名称。\n            /*\n              获取获取ARouter$$Root$$app 类中方法参数Map<String, Class<? extends IRouteGroup>>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ParameterizedTypeName.get(\n                            ClassName.get(Class.class),\n                            WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))\n                    )\n            );\n\n            /*\n              获取ARouter$$Group$$test，ARouter$$Providers$$app类中方法参数 Map<String, RouteMeta>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ClassName.get(RouteMeta.class)\n            );\n\n            /*\n             获取相关的参数\n             */\n            //获取ARouter$$Root$$app 类中方法的参数Map<String, Class<? extends IRouteGroup>> routes\n            ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, \"routes\").build();\n           //获取ARouter$$Group$$test类中方法的参数Map<String, RouteMeta> atlas\n            ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"atlas\").build();\n             //获取ARouter$$Providers$$app类中方法的参数Map<String, RouteMeta> providers\n            ParameterSpec providerParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"providers\").build();  \n\n          .....\n        }\n    }\n\n```\n\n2.获取了方法的参数的类型和参数名称后，下面便是生成相应的方法\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n            /*\n              首先创建ARouter$$Root$$xxx 类中的loadInto()方法\n              @Override\n              public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(rootParamSpec);\n\n            //  遍历所有被@Route注解的元素\n            for (Element element : routeElements) {\n                TypeMirror tm = element.asType();\n                Route route = element.getAnnotation(Route.class);\n                RouteMeta routeMete = null;\n\n                //判断该元素否为 Activity 、IProvider 、 Service 的子类，然后创建相应的RouteMeta 对象\n                if (typeUtil.isSubtype(tm, type_Activity.asType())) {                 // Activity\n                    logger.info(\">>> Found activity route: \" + tm.toString() + \" <<<\");\n\n                    // 如果是acitiviy类型，获取所有被@Autowired的属性\n                    //关于@Autowired的注解，我们之后再进行分析\n                    Map<String, Integer> paramsType = new HashMap<>();\n                    for (Element field : element.getEnclosedElements()) {\n                        if (field.getKind().isField() && field.getAnnotation(Autowired.class) != null && !typeUtil.isSubtype(field.asType(), iProvider)) {\n                            // It must be field, then it has annotation, but it not be provider.\n                            Autowired paramConfig = field.getAnnotation(Autowired.class);\n                            paramsType.put(StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name(), TypeUtils.typeExchange(field.asType()));\n                        }\n                    }\n                    // ACTIVITY类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.ACTIVITY, paramsType);\n                } else if (typeUtil.isSubtype(tm, iProvider)) {         // IProvider\n                    logger.info(\">>> Found provider route: \" + tm.toString() + \" <<<\");\n                    //从该判断可看出，如果要想成功注册一个 PROVIDER 类型的路由节点，\n                    //一定要实现 com.alibaba.android.arouter.facade.template.IProvider 这个接口\n                    routeMete = new RouteMeta(route, element, RouteType.PROVIDER, null);\n                } else if (typeUtil.isSubtype(tm, type_Service.asType())) {           // Service\n                    logger.info(\">>> Found service route: \" + tm.toString() + \" <<<\");\n                     //SERVICE类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(SERVICE), null);\n                } else if (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) {\n                    logger.info(\">>> Found fragment route: \" + tm.toString() + \" <<<\");\n                   //FRAGMENT类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(FRAGMENT), null);\n                }\n\n                //routeMete包含了每个路由节点的各种信息，下面的方法的主要功能就是根据@Route注解信息对节点进行分组，保存在groupMap集合中。\n               //关于方法的具体实现，后面会有解析\n                categories(routeMete);\n\n            }\n\n            .........\n        }\n    }\n\n```\n\n以上代码主要功能就是遍历所有被@Route注解的元素，然后将每个路由节点的信息按照类型（ACTIVITY类型，实现了IProvider 接口类型以及SERVICE类型）封装到`RouteMeta`中，最后调用`categories(routeMete)`方法将节点分组，保存在`groupMap`集合。\n\n继续往下分析\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n             /*\n              然后创建ARouter$$Providers$$xxx 类中的loadInto()方法\n             @Override\n             public void loadInto(Map<String, RouteMeta> providers) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfProviderBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(providerParamSpec);\n\n            //遍历分组的集合，生成相应的java文件\n           //因为本文使用的例子没有对页面进行分组，所以只生成了一个组文件ARouter$$Group$$xxx\n            for (Map.Entry<String, Set<RouteMeta>> entry : groupMap.entrySet()) {\n                String groupName = entry.getKey();\n               /*\n                  创建ARouter$$Group$$xxx 类中的loadInto()方法\n                 @Override\n                 public void loadInto(Map<String, RouteMeta> atlas) {}\n             */\n                MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                        .addAnnotation(Override.class)\n                        .addModifiers(PUBLIC)\n                        .addParameter(groupParamSpec);\n\n                // 生成loadInto()方法体\n                Set<RouteMeta> groupData = entry.getValue();\n                //遍历每个组里面的路由节点\n                for (RouteMeta routeMeta : groupData) {\n                    switch (routeMeta.getType()) {\n                        //如果节点类型是PROVIDER，\n                        case PROVIDER:  \n                          //获取路由节点元素的接口集合\n                            List<? extends TypeMirror> interfaces = ((TypeElement) routeMeta.getRawType()).getInterfaces();\n                            for (TypeMirror tm : interfaces) {\n                             if (types.isSameType(tm, iProvider)) {   // Its implements iProvider interface himself.\n                                   //路由节点元素其中一个接口是 com.alibaba.android.arouter.facade.template.IProvider \n                                  //给ARouter$$Providers$$xxx 类中的loadInto()添加方法体\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            (routeMeta.getRawType()).toString(),//路由节点元素的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                } else if (types.isSubtype(tm, iProvider)) {\n                                   //路由节点元素其中一个接口是com.alibaba.android.arouter.facade.template.IProvider 接口的子类型\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            tm.toString(),   //IProvider子类型的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                }\n                            //上面方法体的代码为：\n                          //providers.put(\"实现接口的名称\", RouteMeta.build(RouteType.PROVIDER, 类名.class,   \"@Route.path\", \"@Route.group\", null, @Route.priority, @Route.extras));\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n\n                    // 将路由节点中被@Autowired注解的属性集合转换成字符串\n                    StringBuilder mapBodyBuilder = new StringBuilder();\n                    //获取路由节点中被@Autowired注解的属性集合\n                    Map<String, Integer> paramsType = routeMeta.getParamsType();\n                    if (MapUtils.isNotEmpty(paramsType)) {\n                        for (Map.Entry<String, Integer> types : paramsType.entrySet()) {\n                            mapBodyBuilder.append(\"put(\\\"\").append(types.getKey()).append(\"\\\", \").append(types.getValue()).append(\"); \");\n                        }\n                    }\n                    String mapBody = mapBodyBuilder.toString();\n\n                    //给ARouter$$Group$$xxx 类中的loadInto()添加方法体\n                    //注意：有多个分组就会创建多个组文件\n                    loadIntoMethodOfGroupBuilder.addStatement(\n                            \"atlas.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, \" + (StringUtils.isEmpty(mapBody) ? null : (\"new java.util.HashMap<String, Integer>(){{\" + mapBodyBuilder.toString() + \"}}\")) + \", \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                            routeMeta.getPath(),\n                            routeMetaCn,\n                            routeTypeCn,\n                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                            routeMeta.getPath().toLowerCase(),\n                            routeMeta.getGroup().toLowerCase());\n                }\n\n                  // 真正生成ARouter$$Group$$test JAVA文件\n                 //NAME_OF_GROUP = ARouter$$Group$$\n                //  groupName = test; 关于groupname的值在方法categories(routeMete)中会有讲解\n                String groupFileName = NAME_OF_GROUP + groupName;\n                JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                        TypeSpec.classBuilder(groupFileName)\n                                .addJavadoc(WARNING_TIPS)\n                                .addSuperinterface(ClassName.get(type_IRouteGroup))\n                                .addModifiers(PUBLIC)\n                                .addMethod(loadIntoMethodOfGroupBuilder.build())\n                                .build()\n                ).build().writeTo(mFiler);\n\n                logger.info(\">>> Generated group: \" + groupName + \"<<<\");\n                //将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备\n                rootMap.put(groupName, groupFileName);\n            }\n\n         .......\n        }\n    }\n\n```\n\n以上代码主要功能由几点：\n\n*   遍历`groupmap`集合给ARouter$$Group$$xxx类中的`loadInto()`添加方法体，并且生成ARouter$$Group$$xxx JAVA文件，而文件命名为ARouter$$Group$$+groupname，其中有多个分组就会创建多个组文件。比如`AROUTER`源码中的样例就生成了多个分组文件\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n\n两个分组文件\n\n关于生成的`loadInto()`中的方法体的例子，来自 `AROUTER`源码中的样例：\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    //存在被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/activity1\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"name\", 18); put(\"boy\", 0); put(\"age\", 3); put(\"url\", 18); }}, -1, -2147483648));\n    .....\n   //没有被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity4\", RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, \"/test/activity4\", \"test\", null, -1, -2147483648));\n    ....\n  }\n}\n\n```\n\n*   遍历每个组里面的路由节点，查找节点类型是否为PROVIDER类型，如果是就向给ARouter$$Providers$$xxx类中的`loadInto()`添加方法，其文件命名ARouter$$Providers$$+modulename。关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.HelloService\", RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, \"/service/hello\", \"service\", null, -1, -2147483648));\n    //路由节点元素其中一个接口是IProvider的子类型\n    providers.put(\"com.alibaba.android.arouter.facade.service.SerializationService\", RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, \"/service/json\", \"service\", null, -1, -2147483648));\n     //路由节点元素其中一个接口是IProvider接口\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.SingleService\", RouteMeta.build(RouteType.PROVIDER, SingleService.class, \"/service/single\", \"service\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备，其文件命名ARouter$$Root$$+modulename。\n\n我们接着分析`parseRoutes()`方法最后一段代码，这段代码其实很简单，主要目的就是给ARouter$$Root$$xxx的`loadInto()`添加方法体，最后生成Router$$Providers$$xxx，ARouter$$Root$$xxx文件\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n            //遍历rootMap集合，给ARouter$$Root$$xxx的`loadInto()`添加方法体\n            if (MapUtils.isNotEmpty(rootMap)) {\n                // Generate root meta by group name, it must be generated before root, then I can findout the class of group.\n                for (Map.Entry<String, String> entry : rootMap.entrySet()) {\n                    loadIntoMethodOfRootBuilder.addStatement(\"routes.put($S, $T.class)\", entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));\n                }\n            }\n\n            // 生成Router$$Providers$$xxx文件\n            String providerMapFileName = NAME_OF_PROVIDER + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(providerMapFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(type_IProviderGroup))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfProviderBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated provider map, name is \" + providerMapFileName + \" <<<\");\n\n            // 生成ARouter$$Root$$xxx文件\n            String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(rootFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(elementUtil.getTypeElement(ITROUTE_ROOT)))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfRootBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated root, name is \" + rootFileName + \" <<<\");\n        }\n    }\n\n```\n\n关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"service\", ARouter$$Group$$service.class);\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n**上面分析的便是`parseRoutes()`方法所有代码的解析**\n\n3.最后我们看下`categories()`方法是如何分组的\n\n```\n   private void categories(RouteMeta routeMete) {\n        //如果路由路径合法，且有groupname进行执行\n        if (routeVerify(routeMete)) {\n            logger.info(\">>> Start categories, group = \" + routeMete.getGroup() + \", path = \" + routeMete.getPath() + \" <<<\");\n             //根据groupname获取该组的路由节点集合，如果集合为空，则创建一个新的组，将该节点添加进去，并将组集合保存在groupmap中；\n          //不为空，则添加到所属的组集合中去\n            Set<RouteMeta> routeMetas = groupMap.get(routeMete.getGroup());\n            if (CollectionUtils.isEmpty(routeMetas)) {\n                Set<RouteMeta> routeMetaSet = new TreeSet<>(new Comparator<RouteMeta>() {\n                    @Override\n                    public int compare(RouteMeta r1, RouteMeta r2) {\n                        try {\n                            return r1.getPath().compareTo(r2.getPath());\n                        } catch (NullPointerException npe) {\n                            logger.error(npe.getMessage());\n                            return 0;\n                        }\n                    }\n                });\n                routeMetaSet.add(routeMete);\n                groupMap.put(routeMete.getGroup(), routeMetaSet);\n            } else {\n                routeMetas.add(routeMete);\n            }\n        } else {\n            logger.warning(\">>> Route meta verify error, group is \" + routeMete.getGroup() + \" <<<\");\n        }\n    }\n\n//判断路由路径是否合法，并且设置groupname\n private boolean routeVerify(RouteMeta meta) {\n        String path = meta.getPath();\n        //如果路径为空，或者不是由'/'开头，返回false\n        if (StringUtils.isEmpty(path) || !path.startsWith(\"/\")) {   // The path must be start with '/' and not empty!\n            return false;\n        }\n\n         //如果在@Route注解中没有设置group标识，那么就默认取path路径第一段路径名作为groupname\n        if (StringUtils.isEmpty(meta.getGroup())) { // Use default group(the first word in path)\n            try {\n                String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n                if (StringUtils.isEmpty(defaultGroup)) {\n                    return false;\n                }\n\n                meta.setGroup(defaultGroup);\n                return true;\n            } catch (Exception e) {\n                logger.error(\"Failed to extract default group! \" + e.getMessage());\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n```\n\n通过分析，如果@Route注解中有设置group标识，作为groupname，如果没有就取/xxx1/xxx2，xxx1作为groupname，并将同一组的路由节点放到同一个集合中去。\n\n至此关于`@Route`注解在编译期时生成ARouter$$Root$$xxx，Router$$Providers$$xxx，ARouter$$Group$$xxx三种映射文件的源码分析完毕。\n\n###### 2.ARouter初始化过程\n\nARouter经过代码编译后，生成了相应的映射文件，我们可以断定，ARouter 的初始化会将这些文件加载到内存中去，形成一个路由表，以供后面路由查找跳转之用。其相关源码可参见 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `ARouter`的`init()`方法\n\n```\npublic static void init(Application application) {\n        if (!hasInit) {\n            logger = _ARouter.logger;\n            _ARouter.logger.info(Consts.TAG, \"ARouter init start.\");\n            hasInit = _ARouter.init(application);\n\n            if (hasInit) {\n                _ARouter.afterInit();\n            }\n\n            _ARouter.logger.info(Consts.TAG, \"ARouter init over.\");\n        }\n    }\n\n```\n\n由上面代码可以看出，其初始化实际上是调用了`_ARouter` 的 `init ()`方法，而且其他的跳转方法最终调用的也是`_ARouter` 种的方法。\n\n*   `_ARouter`的`init()`方法\n\n```\n  protected static synchronized boolean init(Application application) {\n        mContext = application;\n        LogisticsCenter.init(mContext, executor);\n        logger.info(Consts.TAG, \"ARouter init success!\");\n        hasInit = true;\n\n        return true;\n    }\n\n```\n\n`_ARouter`中又调用了`LogisticsCenter.init()`，继续追踪下去，其中传入了一个线程池`executor`，这个线程池在拦截器的时候会使用到。\n\n```\n    public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n        mContext = context;\n        executor = tpe;\n\n        try {\n             //ROUTE_ROOT_PAKCAGE = \"com.alibaba.android.arouter.routes\"\n            // 获取ROUTE_ROOT_PAKCAGE 包里面的所有文件\n            List<String> classFileNames = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n\n            //遍历所有ROUTE_ROOT_PAKCAGE 包里的文件\n            for (String className : classFileNames) {\n                //文件名以“com.alibaba.android.arouter.routes.ARouter$$Root”开头执行下面代码\n                if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                    // 通过反射实例化，并且调用loadInto()，目的即是将编译生成的ARouter$$Group$$xxx文件加载到内存中，保存在Warehouse.groupsIndex；\n                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n                    //文件名以“com.alibaba.android.arouter.routes.ARouter$$Interceptors”开头执行下面代码\n                    //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()，将自定义拦截器类存放在Warehouse.interceptorsIndex中\n                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n                     //文件名以“com.alibaba.android.arouter.routes.ARouter$$Providers”开头执行下面代码\n                   //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()\n                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n                }\n            }\n\n            if (Warehouse.groupsIndex.size() == 0) {\n                logger.error(TAG, \"No mapping files were found, check your configuration please!\");\n            }\n\n            if (ARouter.debuggable()) {\n                logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));\n            }\n        } catch (Exception e) {\n            throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n        }\n    }\n\n```\n\n*   `_ARouter`的`afterInit()`方法\n\n```\nstatic void afterInit() {\n        // 通过路由机制，初始化路由拦截机制。关于路由拦截机制的使用和原理，后续文章会有分析\n        interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation();\n    }\n\n```\n\n以上就是ARouter初始化的所有代码，关于如何查找到`com.alibaba.android.arouter.routes`包内所有文件这里便不做过多分析，大家可以去阅读 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)中`ClassUtils`这个类的源码。\n**总结下来，其实ARouter 的初始化只做了一件事，找到自己编译期产生的清单文件，把 Group 、Interceptor 、Provider 三种清单加载到 Warehouse 内存仓库中。**即下面这些文件，来源自AROUTER源码中的样例\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n\n值得注意的是，在初始化阶段，ARouter 仅载入了 Group 清单，并没有具体载入每个 Group 中包含的具体的路由节点清单，只有当使用到具体的 Group 时，才会加载对应的 Group 列表。这种分组管理，按需加载，大大的降低了初始化时的内存压力。并且`Warehouse`类中保存了路由清单，并且将使用过的路由对象缓存起来，之后查找都是直接使用缓存的对象 。\n\n###### 3.ARouter调用过程分析\n\n页面跳转最基本方法\n\n> ARouter.getInstance().build(\"/test/activity2\").navigation();\n\n获取Provider服务（实现了IProvider接口以及IProvider子类接口的服务类）的方法有两种：\n\n> 1.byName方式\n> ARouter.getInstance().build(\"/service/hello\").navigation()\n\n> 2.byType方式\n> ARouter.getInstance().navigation(HelloService.class)\n\nARouter路由跳转采用链式调用，`ARouter.getInstance()`其中采用的单例模式，获取ARouter的实例，这个就不作过多分析，主要分析`build()`和`navigation()`。\n\n**build()方法**\nARouter的`build(String path)`和`init()`方法一样，调用的是`_ARouter`的`build(String path)`方法。\n\n```\n  protected Postcard build(String path) {\n        if (TextUtils.isEmpty(path)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return build(path, extractGroup(path));\n        }\n    }\n\n```\n\n其中`extractGroup(String path)`就是根据path获取分组名，即path第一段“/”符号之间的值\n\n```\n  private String extractGroup(String path) {\n        if (TextUtils.isEmpty(path) || !path.startsWith(\"/\")) {\n            throw new HandlerException(Consts.TAG + \"Extract the default group failed, the path must be start with '/' and contain more than 2 '/'!\");\n        }\n\n        try {\n            //    /xxx1/xxx2   ===>  defaulGroup = xxx1\n            String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n            if (TextUtils.isEmpty(defaultGroup)) {\n                throw new HandlerException(Consts.TAG + \"Extract the default group failed! There's nothing between 2 '/'!\");\n            } else {\n                return defaultGroup;\n            }\n        } catch (Exception e) {\n            logger.warning(Consts.TAG, \"Failed to extract default group! \" + e.getMessage());\n            return null;\n        }\n    }\n\n```\n\n`build(String path)`方法最终调用的是`build(String path, String group)`\n\n```\n    protected Postcard build(String path, String group) {\n        if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return new Postcard(path, group);\n        }\n    }\n\n```\n\n**值得注意的是其中`ARouter.getInstance().navigation(PathReplaceService.class)`就是得到实现`PathReplaceService`接口的一个服务对象，对原始path进行处理后，生成新的path路径。而这个类需要我们自己自定义去实现，如果没有实现，pService=null，原始path不做任何处理。**\n下面是`PathReplaceService`接口，我们可以通过实现`forString()`和`forUri()`方法，对某些url进行替换处理，跳转到其他的目标页面。\n\n```\npublic interface PathReplaceService extends IProvider {\n\n    /**\n     * For normal path.\n     *\n     * @param path raw path\n     */\n    String forString(String path);\n\n    /**\n     * For uri type.\n     *\n     * @param uri raw uri\n     */\n    Uri forUri(Uri uri);\n}\n\n```\n\n最后返回一个`Postcard`实例对象，里面封装了路由节点的路径，分组等节点信息。其实`build()`方法的目的只有一个就是根据路由，封装成`Postcard`对象，其对象贯穿之后整个路由过程。Postcard 包含了众多的属性值，提供了路由过程中所有的控制变量。\n\n```\npublic final class Postcard extends RouteMeta {\n    private Uri uri;\n    private Object tag;             // A tag prepare for some thing wrong.\n    private Bundle mBundle;         // 传递的参数\n    private int flags = -1;         // intent 的flag标志\n    private int timeout = 300;      // Navigation timeout, TimeUnit.Second !\n    private IProvider provider;     // IProvider服务对象\n    private boolean greenChannal;\n    private SerializationService serializationService;//序列化服务对象\n\n     // 跳转动画\n    private Bundle optionsCompat;    // The transition animation of activity\n    private int enterAnim;\n    private int exitAnim;\n\n    // copy from RouteMeta \n    private RouteType type;         // 路由节点类型\n    private Element rawType;        \n    private Class<?> destination;  //需要跳转到的页面\n    private String path;            // 路径\n    private String group;           // 分组\n    private int priority = -1;      // 优先级\n    private int extra;              // 配置标识\n    private Map<String, Integer> paramsType;  // 路由页面被@Autowired注解属性\n    // ......\n}\n\n```\n\n**navigation()方法**\n关于页面跳转的`navigation()`方法有多个重载的方法，但最终都会调用`_ARouter`下面这个方法\n\n```\n    protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        try {\n            //首先对postcard进行一些处理，设置postcard的destination，type，priority 等一些属性值，completion()后面会有分析\n            LogisticsCenter.completion(postcard);\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n\n            if (debuggable()) { // Show friendly tips for user.\n                Toast.makeText(mContext, \"There's no route matched!\\n\" +\n                        \" Path = [\" + postcard.getPath() + \"]\\n\" +\n                        \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show();\n            }\n            // 如果处理postcard失败，通过 callback 回调失败结果\n           // callback为空的情况下，如果有定义全局的降级处理（DegradeService），则使用全局处理\n           //降级处理也需要我们自己实现DegradeService接口\n            if (null != callback) {\n                callback.onLost(postcard);\n            } else {    // No callback for this invoke, then we use the global degrade service.\n                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);\n                if (null != degradeService) {\n                    degradeService.onLost(context, postcard);\n                }\n            }\n\n            return null;\n        }\n         //路由处理成功，回调callback.onFound()\n        if (null != callback) {\n            callback.onFound(postcard);\n        }\n\n        //目前来说，PROVIDER服务类型，以及FRAGMENT类型不需要通过拦截器外，其他类型均需要通过拦截器\n        //关于拦截器相关用法及原理分析在后续的文章中会讲解到，大家去可以关注下\n        if (!postcard.isGreenChannel()) {   \n            interceptorService.doInterceptions(postcard, new InterceptorCallback() {\n                /**\n                 * Continue process\n                 *\n                 * @param postcard route meta\n                 */\n                @Override\n                public void onContinue(Postcard postcard) {\n                    _navigation(context, postcard, requestCode, callback);\n                }\n\n                /**\n                 * Interrupt process, pipeline will be destory when this method called.\n                 *\n                 * @param exception Reson of interrupt.\n                 */\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    if (null != callback) {\n                        callback.onInterrupt(postcard);\n                    }\n\n                    logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage());\n                }\n            });\n        } else {\n            return _navigation(context, postcard, requestCode, callback);\n        }\n\n        return null;\n    }\n\n```\n\n**值得注意的是，当跳转路由处理失败的时候，会获取一个降级服务，我们可以实现`DegradeService`接口，实现`onLost()`方法，对路由处理失败的情况进行处理，比如跳转到一个信息提示页面，让用户去更新版本等操作等。** 下面是`DegradeService`接口：\n\n```\npublic interface DegradeService extends IProvider {\n\n    /**\n     * Router has lost.\n     *\n     * @param postcard meta\n     */\n    void onLost(Context context, Postcard postcard);\n}\n\n```\n\n通过上面代码的分析，不管是否通过拦截器进行处理，最后都会调用`_navigation()`达到路由的目的：\n\n```\nprivate Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                //下面就是最基本的使用intent进行activity进行跳转\n                // 创建intent\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                //设置传参\n                intent.putExtras(postcard.getExtras());\n\n                //activity启动标志\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n\n                // 在主线程中进行跳转\n                new Handler(Looper.getMainLooper()).post(new Runnable() {\n                    @Override\n                    public void run() {\n                        //新版本带转场动画的启动方式\n                        if (requestCode > 0) {  // Need start for result\n                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());\n                        } else {\n                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());\n                        }\n\n                        if ((0 != postcard.getEnterAnim() || 0 != postcard.getExitAnim()) && currentContext instanceof Activity) {    // Old version.\n                            //老版本的跳转动画\n                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());\n                        }\n                        //跳转成功，回调callback.onArrival()\n                        if (null != callback) { // Navigation over.\n                            callback.onArrival(postcard);\n                        }\n                    }\n                });\n\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                     //实例化fragment，并传递参数\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n\n```\n\n目前仅ARouter实现了 ACTIVITY ， PROVIDER ，FRAGMENT三种种类型。上面关于postcard的provider，destination的值都是在`completion()`中设置的。我们接着看`LogisticsCenter`的`completion(Postcard postcard)`。\n\n```\n    public synchronized static void completion(Postcard postcard) {\n        if (null == postcard) {\n            throw new NoRouteFoundException(TAG + \"No postcard!\");\n        }\n\n        // 查找Warehouse仓库的路由节点缓存，看是否已在缓存中\n        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n        if (null == routeMeta) {   \n          // 如果没有，查找仓库的组别清单中是否存在该组别，组别清单已经在初始化的时候加载到仓库中去了\n            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  \n            //如果没有抛出异常\n            if (null == groupMeta) {\n                throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n            } else {\n                // Load route and cache it into memory, then delete from metas.\n                try {\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                    // 实例化个组别的类，调用loadInto()，将组别中所有的路由节点加载进仓库Warehouse.routes，缓存\n                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n                    iGroupInstance.loadInto(Warehouse.routes);\n                     // 从组别清单中删除已加载的组别，防止重复加载\n                    Warehouse.groupsIndex.remove(postcard.getGroup());\n\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                } catch (Exception e) {\n                    throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\");\n                }\n                //当路由节点加载到缓存中去后，重新查找执行else代码，对postcard进行处理\n                completion(postcard);   // Reload\n            }\n        } else {\n            //给postcard设置destination,type,priority等值，供上面讲解到的_navigation()进行使用\n            // 其中routeMeta是在ARouter$$Group$$xxx的loadInto中创建的\n            postcard.setDestination(routeMeta.getDestination());\n            postcard.setType(routeMeta.getType());\n            postcard.setPriority(routeMeta.getPriority());\n            postcard.setExtra(routeMeta.getExtra());\n\n            //如果通过build(Uri url) 进行跳转的话 通过解析url ，将传参保存进bundle中\n            Uri rawUri = postcard.getUri();\n            if (null != rawUri) {  \n                //splitQueryParameters()就是在uri中携带的参数进行解析\n                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);\n                Map<String, Integer> paramsType = routeMeta.getParamsType();\n\n                if (MapUtils.isNotEmpty(paramsType)) {\n                    // Set value by its type, just for params which annotation by @Param\n                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {\n                        setValue(postcard,\n                                params.getValue(),\n                                params.getKey(),\n                                resultMap.get(params.getKey()));\n                    }\n\n                    // Save params name which need autoinject.\n                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));\n                }\n\n                // Save raw uri\n                postcard.withString(ARouter.RAW_URI, rawUri.toString());\n            }\n\n            //从这里也可以看出PROVIDER，FRAGMENT不需要通过拦截器\n            switch (routeMeta.getType()) {\n                case PROVIDER:  \n                    // 如果是PROVIDER节点类型，从服务节点列表中获取，如果没有，则实例化，并保存在服务节点列表Warehouse.providers中\n                  //并将实例化的对象设置给postcard的provider属性\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    if (null == instance) { // There's no instance of this provider\n                        IProvider provider;\n                        try {\n                            provider = providerMeta.getConstructor().newInstance();\n                            provider.init(mContext);\n                            Warehouse.providers.put(providerMeta, provider);\n                            instance = provider;\n                        } catch (Exception e) {\n                            throw new HandlerException(\"Init provider failed! \" + e.getMessage());\n                        }\n                    }\n                    postcard.setProvider(instance);\n                    postcard.greenChannel();    // Provider should skip all of interceptors\n                    break;\n                case FRAGMENT:\n                    postcard.greenChannel();    // Fragment needn't interceptors\n                default:\n                    break;\n            }\n        }\n    }\n\n```\n\n分析到这里，关于页面基本跳转的原理分析就已经结束了。最后就是关于获取Provider服务两种方法的源码分析。其中byName方式，和页面跳转是一模一样的。我们只需要看看byType方式即可。byType方式最后调用的是`_ARouter`的`navigation(Class<? extends T> service)`\n\n```\n  protected <T> T navigation(Class<? extends T> service) {\n        try {\n            // 通过 className 获取 Postcard 对象\n            Postcard postcard = LogisticsCenter.buildProvider(service.getName());\n\n            // 兼容1.0.5 compiler sdk版本.\n            if (null == postcard) { // No service, or this service in old version.\n                postcard = LogisticsCenter.buildProvider(service.getSimpleName());\n            }\n           // 对 Postcard 对象进行处理\n            LogisticsCenter.completion(postcard);\n             //返回 Postcard 中的 provider 属性值\n            return (T) postcard.getProvider();\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n            return null;\n        }\n    }\n\n```\n\n上面代码中的`completion()`方法之前已经分析过了，只需要看下`LogisticsCenter.buildProvider(service.getName())`即可。\n\n```\n  public static Postcard buildProvider(String serviceName) {\n        RouteMeta meta = Warehouse.providersIndex.get(serviceName);\n\n        if (null == meta) {\n            return null;\n        } else {\n            return new Postcard(meta.getPath(), meta.getGroup());\n        }\n    }\n\n```\n\n这个方法非常的简单，就是根据服务类名去仓库Warehouse.providersIndex中获去路由节点元素，然后封装在Postcard对象中。服务类清单列表Warehouse.providersIndex中的值是在初始化时缓存的。**值得注意的是，PROVIDER 类型的路由节点既存在于对应的分组中，也存在于服务类清单列表中。所以，ARouter 可通过byType，byName两种方式来获取**。\n\n##### 补充\n\n关于ARouter的基本用法上面只有最基本跳转的介绍，下面对其他一些基本使用进行下补充\n\n*   **带参数跳转**\n\n```\n//1.传递参数\n ARouter.getInstance().build(\"/test/activity1\")\n                        .withString(\"name\", \"老王\")\n                        .withInt(\"age\", 18)\n                        .withBoolean(\"boy\", true)\n                        .withLong(\"high\", 180)\n                        .withString(\"url\", \"https://a.b.c\")\n                        .withParcelable(\"pac\", testParcelable)\n                        .withObject(\"obj\", testObj)\n                        .navigation();\n\n//2.直接传递Bundle\n  Bundle params = new Bundle();\n  ARouter.getInstance()\n          .build(\"/test/activity1\")\n          .with(params)\n          .navigation();\n\n```\n\n这些传参都是保存在生成的`postcard`对象中的`mBundle`属性里，然后在跳转的时候通过`intent.putExtras(postcard.getExtras())`达到传送参数的目的。\n值得注意的是，关于对象的传递有两种，一种是`withParcelable()`方法，不过此方法需要传递的对象实现`Parcelable`接口，达到序列化的目的；另外一种是`withObject()`方法，此方法的原理是将实体类转换成json字符串，通过String的方式进行传递，而且使用这种方式需要实现 SerializationService，并使用@Route注解标注，下面是ARouter样例：\n\n```\n@Route(path = \"/service/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n\n```\n\n而且，需要在跳转到的页面获取`JsonServiceImpl`服务，将json字符串转换成对象。\n\n```\nSerializationService serializationService = ARouter.getInstance().navigation(SerializationService.class);\nTestObj obj = serializationService.json2Object(getIntent().getString(\"obj\"), TestObj.class);\n\n```\n\n*   **带返回结果跳转**\n\n```\nARouter.getInstance().build(\"/test/activity2\").navigation(this, 666);\n\n```\n\n值得注意的是，这时候的 `navigation`需要传递activit和requestCode。\n\n*   **获取Fragment的实例**\n\n定义一个fragment\n\n```\n@Route(path = \"/test/fragment\")\npublic class BlankFragment extends Fragment {\n    public BlankFragment() {\n        //必须要一个空的构造器\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        TextView textView = new TextView(getActivity());\n        return textView;\n    }\n\n}\n\n```\n\n获取frament\n\n```\nFragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation();\n\n```\n\n*   **带转场动画跳转**\n\n```\n// 转场动画(常规方式)\n ARouter.getInstance() .build(\"/test/activity2\")\n                      .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)\n                      .navigation(this);\n\n// 转场动画(API16+)\n ActivityOptionsCompat compat = ActivityOptionsCompat.makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);\nARouter.getInstance().build(\"/test/activity2\").withOptionsCompat(compat) .navigation();\n\n```\n\n*   **获取服务**\n\n服务是全局单例的，只有在第一次使用到的时候才会被初始化。\n暴露服务，必须实现IProvider 接口 或者其子类型\n\n```\n// 声明接口,其他组件通过接口来调用服务\npublic interface HelloService extends IProvider {\n    String sayHello(String name);\n}\n\n// 实现接口\n@Route(path = \"/service/hello\", name = \"测试服务\")\npublic class HelloServiceImpl implements HelloService {\n\n    @Override\n    public String sayHello(String name) {\n    return \"hello, \" + name;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n}\n\n```\n\n获取服务\n\n```\n//bytype\nHelloService helloService1 = ARouter.getInstance().navigation(HelloService.class);\n//byname\nHelloService helloService2 = (HelloService) ARouter.getInstance().build(\"/service/hello\").navigation();\n\n```\n\n*   **多模块结构**\n\n"],[1,388,"\n\n**如果各位同学认为本文对你有一些帮助，希望能点个喜欢，谢谢！**\n\n小礼物走一走，来简书关注我\n\n赞赏支持\n\n[android开发问题](/nb/12473806)\n\n© 著作权归作者所有\n\n举报文章\n\n[![96](//upload.jianshu.io/users/upload_avatars/5994347/dd34592b-ad62-4e24-bb66-f7c689766b2f.png?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96) ](/u/d65e2e163603) 关注 [time_fly](/u/d65e2e163603)\n\n写了 24037 字，被 37 人关注，获得了 92 个喜欢\n\n喜欢\n\n12\n\n[](javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f='http://v.t.sina.com.cn/share/share.php?appkey=1881139527',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function%20a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,'','','', '推荐 @龍儱滝 的文章《阿里ARouter使用及源码解析（一）》（ 分享自 @简书 ）','https://www.jianshu.com/p/46d174f37e82?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo','页面编码gb2312|utf-8默认gb2312'));)[](http://cwb.assets.jianshu.io/notes/images/13526520/weibo/image_bcbd18a5f866.png)[更多分享](javascript:void(0);)\n\n![](//upload.jianshu.io/users/upload_avatars/1786025/f63ccf82f6f8?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114) \n\n3条评论 只看作者 关闭评论\n\n按喜欢排序按时间正序按时间倒序\n\n[![](//cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/ab7bfd384c72)\n\n[winter818](/u/ab7bfd384c72)\n\n2楼 · 2017.08.23 17:56\n\n666 学习了\n\n1人赞 回复 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/426662/e85a4080db83?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/a2a56d463e3d)\n\n[夏鸣浩](/u/a2a56d463e3d)\n\n3楼 · 2017.09.04 17:40\n\n正在拜读，博主辛苦\n\n赞 回复 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/7293029/42130be5-9eb3-4cf2-8874-1f32e70d81e2?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/df76f81fe3ff)\n\n[却把清梅嗅2](/u/df76f81fe3ff)\n\n4楼 · 2017.12.13 16:23\n\n好文，楼主辛苦\n\n赞 回复 举报"]],[0,484],[54215,54215]]],[1519699697266,["xiaoyulaoshi@DESKTOP-LAD9940",[[-1,0,"在app的开发中，页面之间的相互跳转是最基本常用的功能。在Android中的跳转一般通过显式intent和隐式intent两种方式实现的，而Android的原生跳转方式会存在一些缺点：\n\n*   显式intent的实现方式，因为会存在直接的类依赖的问题，导致耦合严重；\n*   隐式intent的实现方式，则会出现规则集中式管理，导致协作变得困难；\n*   可配置性较差，一般而言配置规则都是在Manifest中的，这就导致了扩展性较差；\n*   跳转过程无法控制，一旦使用了StartActivity()就无法插手其中任何环节了，只能交给系统管理；\n*   当多组件化开发，使用原生的路由方式很难实现完全解耦；\n\n而阿里的[ARouter](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)路由框架具有解耦、简单易用、支持多模块项目、定制性较强、支持拦截逻辑等诸多优点，很好的解决了上述的问题。关于ARouter具体实现功能，典型应用以及相应技术方案实现的介绍不在这详细介绍，具体可参见[开源最佳实践：Android平台页面路由框架ARouter](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)。\n\n阿里ARouter的分析计划\n\n*   [阿里ARouter使用及源码解析（一）](https://www.jianshu.com/p/46d174f37e82)\n*   [阿里ARouter拦截器使用及源码解析（二）](https://www.jianshu.com/p/c8d7b1379c1b)\n*   阿里ARouter参数自动装载使用及源码解析（三）\n\n##### 基本功能使用\n\n1.添加依赖和配置\n\n```\nandroid {\n    defaultConfig {\n    ...\n    javaCompileOptions {\n        annotationProcessorOptions {\n        arguments = [ moduleName : project.getName() ]\n        }\n    }\n    }\n}\n\ndependencies {\n    compile 'com.alibaba:arouter-api:1.2.1.1'\n    annotationProcessor 'com.alibaba:arouter-compiler:1.1.2.1'\n    ...\n}\n\n```\n\n2.添加注解\n\n```\n// 在支持路由的页面上添加注解(必选)\n// 这里的路径需要注意的是至少需要有两级，/xx/xx\n@Route(path = \"/test/test1\")\npublic class Test1Activity extends AppCompatActivity{\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_test1);\n    }\n}\n\n```\n\n3.初始化SDK\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            // 如果使用了InstantRun，必须在初始化之前开启调试模式，但是上线前需要关闭，InstantRun仅用于开发阶段，\n            // 线上开启调试模式有安全风险，可以使用BuildConfig.DEBUG来区分环境\n            ARouter.openDebug();\n            ARouter.init(getApplication()); // 尽可能早，推荐在Application中初始化\n        }\n    }\n}\n\n```\n\n4.发起跳转操作\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            ....\n        } else if (v.getId() == R.id.btn2){\n            ARouter.getInstance().build(\"/test/test1\").navigation();\n        }\n    }\n}\n\n```\n\n以上相关代码就是ARouter的最基本功能使用的步骤，下面来分析跳转功能是如何实现的。\n\n##### 原理分析\n\n###### 1.ARouter编译的过程\n\nARouter在编译期的时候，利用自定义注解完成了页面的自动注册。相关注解源码参见[arouter-annotation](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)，编译处理器源码参见[arouter-compiler](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n\n下面是注解`@Route`的源码介绍：\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.CLASS)\npublic @interface Route {\n\n    /**\n     *路由的路径，标识一个路由节点\n     */\n    String path();\n\n    /**\n     * 将路由节点进行分组，可以实现按组动态加载\n     */\n    String group() default \"\";\n\n    /**\n     * 路由节点名称，可用于生成javadoc文档\n     */\n    String name() default \"undefined\";\n\n    /**\n     * 用32位int类型标示，可用于页面的一些配置\n     */\n    int extras() default Integer.MIN_VALUE;\n\n    /**\n     * 路由的优先级\n     */\n    int priority() default -1;\n}\n\n```\n\nRoute中的`extra`值是个int值，由32位表示，即转换成二进制后，一个int中可以配置31个1或者0，而每一个0或者1都可以表示一项配置（排除符号位），如果从这31个位置中随便挑选出一个表示是否需要登录就可以了，只要将标志位置为1，就可以在声明的拦截器中获取到这个标志位，通过位运算的方式判断目标页面是否需要登录。所以可以通过`extra`给页面配置30多个属性，然后在拦截器中去进行处理。\nARouter在拦截器中会把目标页面的信息封装一个类`Postcard`，这个类就包含了目标页面注解上`@Route`标识的各种信息。关于拦截器的使用以及源码分析，后续会有介绍。\n\n将代码编译一遍，可以看到ARouter生成下面几个源文件：\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n\n上面三个文件均是通过注解处理器`RouteProcessor`生成的，关于如何自定义注解处理器，可以阅读[Android编译时注解APT实战（AbstractProcessor）](https://www.jianshu.com/p/07ef8ba80562)，同时也需要学习**JavaPoet**的基本使用。下面我们看`RouteProcessor`是如何生成相关文件的。\n\n```\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //判断被注解了的元素集合是否为空\n        if (CollectionUtils.isNotEmpty(annotations)) {\n            //获取所有被@Route注解的元素集合，Element可以是类、方法、变量等\n            Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);\n            try {\n                logger.info(\">>> Found routes, start... <<<\");\n                //具体处理注解，生成java文件的方法\n                this.parseRoutes(routeElements);\n\n            } catch (Exception e) {\n                logger.error(e);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n```\n\n`process()`方法相当于处理器的主函数`main()`，可以在这个方法中扫描、评估和处理注解的代码，以及生成Java文件。`RouteProcessor`中调用了`parseRoutes()`，用来处理所有被`@Route`注解的元素。在分析上述三个java文件如何生成之前，先看看生成文件的具体代码。\n\n*   ARouter$$Root$$app类\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n*   ARouter$$Group$$test类\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/test/test1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/test1\", \"test\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   ARouter$$Providers$$app类\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n  }\n}\n\n```\n\n我们接着分析上述三个文件是如何生成的\n\n1.首先获取生成方法的参数的类型和参数名称\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n\n            logger.info(\">>> Found routes, size is \" + routeElements.size() + \" <<<\");\n\n            rootMap.clear();\n             // TypeElement 表示一个类或接口元素\n            // public static final String ACTIVITY = \"android.app.Activity\";\n            //得到类activity元素\n            TypeElement type_Activity = elementUtil.getTypeElement(ACTIVITY);\n            // public static final String SERVICE = \"android.app.Service\";\n            //得到类service的元素\n            TypeElement type_Service = elementUtil.getTypeElement(SERVICE);\n            // public static final String SERVICE = \"android.app.Fragment\";\n            TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();\n             // public static final String SERVICE = \"android.support.v4.app.Fragment\";\n            TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();\n\n            // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IRouteGroup\";\n            //得到接口IRouteGroup元素\n            TypeElement type_IRouteGroup = elementUtil.getTypeElement(IROUTE_GROUP);\n          // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IProviderGroup\";\n            //得到接口IProviderGroup元素\n            TypeElement type_IProviderGroup = elementUtil.getTypeElement(IPROVIDER_GROUP);\n            //获取RouteMeta，RouteType类名\n            ClassName routeMetaCn = ClassName.get(RouteMeta.class);\n            ClassName routeTypeCn = ClassName.get(RouteType.class);\n\n            //下面代码是获取生成java文件中方法的参数类型名称和参数名称。\n            /*\n              获取获取ARouter$$Root$$app 类中方法参数Map<String, Class<? extends IRouteGroup>>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ParameterizedTypeName.get(\n                            ClassName.get(Class.class),\n                            WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))\n                    )\n            );\n\n            /*\n              获取ARouter$$Group$$test，ARouter$$Providers$$app类中方法参数 Map<String, RouteMeta>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ClassName.get(RouteMeta.class)\n            );\n\n            /*\n             获取相关的参数\n             */\n            //获取ARouter$$Root$$app 类中方法的参数Map<String, Class<? extends IRouteGroup>> routes\n            ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, \"routes\").build();\n           //获取ARouter$$Group$$test类中方法的参数Map<String, RouteMeta> atlas\n            ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"atlas\").build();\n             //获取ARouter$$Providers$$app类中方法的参数Map<String, RouteMeta> providers\n            ParameterSpec providerParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"providers\").build();  \n\n          .....\n        }\n    }\n\n```\n\n2.获取了方法的参数的类型和参数名称后，下面便是生成相应的方法\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n            /*\n              首先创建ARouter$$Root$$xxx 类中的loadInto()方法\n              @Override\n              public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(rootParamSpec);\n\n            //  遍历所有被@Route注解的元素\n            for (Element element : routeElements) {\n                TypeMirror tm = element.asType();\n                Route route = element.getAnnotation(Route.class);\n                RouteMeta routeMete = null;\n\n                //判断该元素否为 Activity 、IProvider 、 Service 的子类，然后创建相应的RouteMeta 对象\n                if (typeUtil.isSubtype(tm, type_Activity.asType())) {                 // Activity\n                    logger.info(\">>> Found activity route: \" + tm.toString() + \" <<<\");\n\n                    // 如果是acitiviy类型，获取所有被@Autowired的属性\n                    //关于@Autowired的注解，我们之后再进行分析\n                    Map<String, Integer> paramsType = new HashMap<>();\n                    for (Element field : element.getEnclosedElements()) {\n                        if (field.getKind().isField() && field.getAnnotation(Autowired.class) != null && !typeUtil.isSubtype(field.asType(), iProvider)) {\n                            // It must be field, then it has annotation, but it not be provider.\n                            Autowired paramConfig = field.getAnnotation(Autowired.class);\n                            paramsType.put(StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name(), TypeUtils.typeExchange(field.asType()));\n                        }\n                    }\n                    // ACTIVITY类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.ACTIVITY, paramsType);\n                } else if (typeUtil.isSubtype(tm, iProvider)) {         // IProvider\n                    logger.info(\">>> Found provider route: \" + tm.toString() + \" <<<\");\n                    //从该判断可看出，如果要想成功注册一个 PROVIDER 类型的路由节点，\n                    //一定要实现 com.alibaba.android.arouter.facade.template.IProvider 这个接口\n                    routeMete = new RouteMeta(route, element, RouteType.PROVIDER, null);\n                } else if (typeUtil.isSubtype(tm, type_Service.asType())) {           // Service\n                    logger.info(\">>> Found service route: \" + tm.toString() + \" <<<\");\n                     //SERVICE类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(SERVICE), null);\n                } else if (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) {\n                    logger.info(\">>> Found fragment route: \" + tm.toString() + \" <<<\");\n                   //FRAGMENT类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(FRAGMENT), null);\n                }\n\n                //routeMete包含了每个路由节点的各种信息，下面的方法的主要功能就是根据@Route注解信息对节点进行分组，保存在groupMap集合中。\n               //关于方法的具体实现，后面会有解析\n                categories(routeMete);\n\n            }\n\n            .........\n        }\n    }\n\n```\n\n以上代码主要功能就是遍历所有被@Route注解的元素，然后将每个路由节点的信息按照类型（ACTIVITY类型，实现了IProvider 接口类型以及SERVICE类型）封装到`RouteMeta`中，最后调用`categories(routeMete)`方法将节点分组，保存在`groupMap`集合。\n\n继续往下分析\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n             /*\n              然后创建ARouter$$Providers$$xxx 类中的loadInto()方法\n             @Override\n             public void loadInto(Map<String, RouteMeta> providers) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfProviderBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(providerParamSpec);\n\n            //遍历分组的集合，生成相应的java文件\n           //因为本文使用的例子没有对页面进行分组，所以只生成了一个组文件ARouter$$Group$$xxx\n            for (Map.Entry<String, Set<RouteMeta>> entry : groupMap.entrySet()) {\n                String groupName = entry.getKey();\n               /*\n                  创建ARouter$$Group$$xxx 类中的loadInto()方法\n                 @Override\n                 public void loadInto(Map<String, RouteMeta> atlas) {}\n             */\n                MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                        .addAnnotation(Override.class)\n                        .addModifiers(PUBLIC)\n                        .addParameter(groupParamSpec);\n\n                // 生成loadInto()方法体\n                Set<RouteMeta> groupData = entry.getValue();\n                //遍历每个组里面的路由节点\n                for (RouteMeta routeMeta : groupData) {\n                    switch (routeMeta.getType()) {\n                        //如果节点类型是PROVIDER，\n                        case PROVIDER:  \n                          //获取路由节点元素的接口集合\n                            List<? extends TypeMirror> interfaces = ((TypeElement) routeMeta.getRawType()).getInterfaces();\n                            for (TypeMirror tm : interfaces) {\n                             if (types.isSameType(tm, iProvider)) {   // Its implements iProvider interface himself.\n                                   //路由节点元素其中一个接口是 com.alibaba.android.arouter.facade.template.IProvider \n                                  //给ARouter$$Providers$$xxx 类中的loadInto()添加方法体\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            (routeMeta.getRawType()).toString(),//路由节点元素的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                } else if (types.isSubtype(tm, iProvider)) {\n                                   //路由节点元素其中一个接口是com.alibaba.android.arouter.facade.template.IProvider 接口的子类型\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            tm.toString(),   //IProvider子类型的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                }\n                            //上面方法体的代码为：\n                          //providers.put(\"实现接口的名称\", RouteMeta.build(RouteType.PROVIDER, 类名.class,   \"@Route.path\", \"@Route.group\", null, @Route.priority, @Route.extras));\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n\n                    // 将路由节点中被@Autowired注解的属性集合转换成字符串\n                    StringBuilder mapBodyBuilder = new StringBuilder();\n                    //获取路由节点中被@Autowired注解的属性集合\n                    Map<String, Integer> paramsType = routeMeta.getParamsType();\n                    if (MapUtils.isNotEmpty(paramsType)) {\n                        for (Map.Entry<String, Integer> types : paramsType.entrySet()) {\n                            mapBodyBuilder.append(\"put(\\\"\").append(types.getKey()).append(\"\\\", \").append(types.getValue()).append(\"); \");\n                        }\n                    }\n                    String mapBody = mapBodyBuilder.toString();\n\n                    //给ARouter$$Group$$xxx 类中的loadInto()添加方法体\n                    //注意：有多个分组就会创建多个组文件\n                    loadIntoMethodOfGroupBuilder.addStatement(\n                            \"atlas.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, \" + (StringUtils.isEmpty(mapBody) ? null : (\"new java.util.HashMap<String, Integer>(){{\" + mapBodyBuilder.toString() + \"}}\")) + \", \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                            routeMeta.getPath(),\n                            routeMetaCn,\n                            routeTypeCn,\n                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                            routeMeta.getPath().toLowerCase(),\n                            routeMeta.getGroup().toLowerCase());\n                }\n\n                  // 真正生成ARouter$$Group$$test JAVA文件\n                 //NAME_OF_GROUP = ARouter$$Group$$\n                //  groupName = test; 关于groupname的值在方法categories(routeMete)中会有讲解\n                String groupFileName = NAME_OF_GROUP + groupName;\n                JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                        TypeSpec.classBuilder(groupFileName)\n                                .addJavadoc(WARNING_TIPS)\n                                .addSuperinterface(ClassName.get(type_IRouteGroup))\n                                .addModifiers(PUBLIC)\n                                .addMethod(loadIntoMethodOfGroupBuilder.build())\n                                .build()\n                ).build().writeTo(mFiler);\n\n                logger.info(\">>> Generated group: \" + groupName + \"<<<\");\n                //将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备\n                rootMap.put(groupName, groupFileName);\n            }\n\n         .......\n        }\n    }\n\n```\n\n以上代码主要功能由几点：\n\n*   遍历`groupmap`集合给ARouter$$Group$$xxx类中的`loadInto()`添加方法体，并且生成ARouter$$Group$$xxx JAVA文件，而文件命名为ARouter$$Group$$+groupname，其中有多个分组就会创建多个组文件。比如`AROUTER`源码中的样例就生成了多个分组文件\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n\n两个分组文件\n\n关于生成的`loadInto()`中的方法体的例子，来自 `AROUTER`源码中的样例：\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    //存在被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/activity1\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"name\", 18); put(\"boy\", 0); put(\"age\", 3); put(\"url\", 18); }}, -1, -2147483648));\n    .....\n   //没有被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity4\", RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, \"/test/activity4\", \"test\", null, -1, -2147483648));\n    ....\n  }\n}\n\n```\n\n*   遍历每个组里面的路由节点，查找节点类型是否为PROVIDER类型，如果是就向给ARouter$$Providers$$xxx类中的`loadInto()`添加方法，其文件命名ARouter$$Providers$$+modulename。关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.HelloService\", RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, \"/service/hello\", \"service\", null, -1, -2147483648));\n    //路由节点元素其中一个接口是IProvider的子类型\n    providers.put(\"com.alibaba.android.arouter.facade.service.SerializationService\", RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, \"/service/json\", \"service\", null, -1, -2147483648));\n     //路由节点元素其中一个接口是IProvider接口\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.SingleService\", RouteMeta.build(RouteType.PROVIDER, SingleService.class, \"/service/single\", \"service\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备，其文件命名ARouter$$Root$$+modulename。\n\n我们接着分析`parseRoutes()`方法最后一段代码，这段代码其实很简单，主要目的就是给ARouter$$Root$$xxx的`loadInto()`添加方法体，最后生成Router$$Providers$$xxx，ARouter$$Root$$xxx文件\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n            //遍历rootMap集合，给ARouter$$Root$$xxx的`loadInto()`添加方法体\n            if (MapUtils.isNotEmpty(rootMap)) {\n                // Generate root meta by group name, it must be generated before root, then I can findout the class of group.\n                for (Map.Entry<String, String> entry : rootMap.entrySet()) {\n                    loadIntoMethodOfRootBuilder.addStatement(\"routes.put($S, $T.class)\", entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));\n                }\n            }\n\n            // 生成Router$$Providers$$xxx文件\n            String providerMapFileName = NAME_OF_PROVIDER + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(providerMapFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(type_IProviderGroup))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfProviderBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated provider map, name is \" + providerMapFileName + \" <<<\");\n\n            // 生成ARouter$$Root$$xxx文件\n            String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(rootFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(elementUtil.getTypeElement(ITROUTE_ROOT)))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfRootBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated root, name is \" + rootFileName + \" <<<\");\n        }\n    }\n\n```\n\n关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"service\", ARouter$$Group$$service.class);\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n**上面分析的便是`parseRoutes()`方法所有代码的解析**\n\n3.最后我们看下`categories()`方法是如何分组的\n\n```\n   private void categories(RouteMeta routeMete) {\n        //如果路由路径合法，且有groupname进行执行\n        if (routeVerify(routeMete)) {\n            logger.info(\">>> Start categories, group = \" + routeMete.getGroup() + \", path = \" + routeMete.getPath() + \" <<<\");\n             //根据groupname获取该组的路由节点集合，如果集合为空，则创建一个新的组，将该节点添加进去，并将组集合保存在groupmap中；\n          //不为空，则添加到所属的组集合中去\n            Set<RouteMeta> routeMetas = groupMap.get(routeMete.getGroup());\n            if (CollectionUtils.isEmpty(routeMetas)) {\n                Set<RouteMeta> routeMetaSet = new TreeSet<>(new Comparator<RouteMeta>() {\n                    @Override\n                    public int compare(RouteMeta r1, RouteMeta r2) {\n                        try {\n                            return r1.getPath().compareTo(r2.getPath());\n                        } catch (NullPointerException npe) {\n                            logger.error(npe.getMessage());\n                            return 0;\n                        }\n                    }\n                });\n                routeMetaSet.add(routeMete);\n                groupMap.put(routeMete.getGroup(), routeMetaSet);\n            } else {\n                routeMetas.add(routeMete);\n            }\n        } else {\n            logger.warning(\">>> Route meta verify error, group is \" + routeMete.getGroup() + \" <<<\");\n        }\n    }\n\n//判断路由路径是否合法，并且设置groupname\n private boolean routeVerify(RouteMeta meta) {\n        String path = meta.getPath();\n        //如果路径为空，或者不是由'/'开头，返回false\n        if (StringUtils.isEmpty(path) || !path.startsWith(\"/\")) {   // The path must be start with '/' and not empty!\n            return false;\n        }\n\n         //如果在@Route注解中没有设置group标识，那么就默认取path路径第一段路径名作为groupname\n        if (StringUtils.isEmpty(meta.getGroup())) { // Use default group(the first word in path)\n            try {\n                String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n                if (StringUtils.isEmpty(defaultGroup)) {\n                    return false;\n                }\n\n                meta.setGroup(defaultGroup);\n                return true;\n            } catch (Exception e) {\n                logger.error(\"Failed to extract default group! \" + e.getMessage());\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n```\n\n通过分析，如果@Route注解中有设置group标识，作为groupname，如果没有就取/xxx1/xxx2，xxx1作为groupname，并将同一组的路由节点放到同一个集合中去。\n\n至此关于`@Route`注解在编译期时生成ARouter$$Root$$xxx，Router$$Providers$$xxx，ARouter$$Group$$xxx三种映射文件的源码分析完毕。\n\n###### 2.ARouter初始化过程\n\nARouter经过代码编译后，生成了相应的映射文件，我们可以断定，ARouter 的初始化会将这些文件加载到内存中去，形成一个路由表，以供后面路由查找跳转之用。其相关源码可参见 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `ARouter`的`init()`方法\n\n```\npublic static void init(Application application) {\n        if (!hasInit) {\n            logger = _ARouter.logger;\n            _ARouter.logger.info(Consts.TAG, \"ARouter init start.\");\n            hasInit = _ARouter.init(application);\n\n            if (hasInit) {\n                _ARouter.afterInit();\n            }\n\n            _ARouter.logger.info(Consts.TAG, \"ARouter init over.\");\n        }\n    }\n\n```\n\n由上面代码可以看出，其初始化实际上是调用了`_ARouter` 的 `init ()`方法，而且其他的跳转方法最终调用的也是`_ARouter` 种的方法。\n\n*   `_ARouter`的`init()`方法\n\n```\n  protected static synchronized boolean init(Application application) {\n        mContext = application;\n        LogisticsCenter.init(mContext, executor);\n        logger.info(Consts.TAG, \"ARouter init success!\");\n        hasInit = true;\n\n        return true;\n    }\n\n```\n\n`_ARouter`中又调用了`LogisticsCenter.init()`，继续追踪下去，其中传入了一个线程池`executor`，这个线程池在拦截器的时候会使用到。\n\n```\n    public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n        mContext = context;\n        executor = tpe;\n\n        try {\n             //ROUTE_ROOT_PAKCAGE = \"com.alibaba.android.arouter.routes\"\n            // 获取ROUTE_ROOT_PAKCAGE 包里面的所有文件\n            List<String> classFileNames = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n\n            //遍历所有ROUTE_ROOT_PAKCAGE 包里的文件\n            for (String className : classFileNames) {\n                //文件名以“com.alibaba.android.arouter.routes.ARouter$$Root”开头执行下面代码\n                if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                    // 通过反射实例化，并且调用loadInto()，目的即是将编译生成的ARouter$$Group$$xxx文件加载到内存中，保存在Warehouse.groupsIndex；\n                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n                    //文件名以“com.alibaba.android.arouter.routes.ARouter$$Interceptors”开头执行下面代码\n                    //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()，将自定义拦截器类存放在Warehouse.interceptorsIndex中\n                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n                     //文件名以“com.alibaba.android.arouter.routes.ARouter$$Providers”开头执行下面代码\n                   //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()\n                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n                }\n            }\n\n            if (Warehouse.groupsIndex.size() == 0) {\n                logger.error(TAG, \"No mapping files were found, check your configuration please!\");\n            }\n\n            if (ARouter.debuggable()) {\n                logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));\n            }\n        } catch (Exception e) {\n            throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n        }\n    }\n\n```\n\n*   `_ARouter`的`afterInit()`方法\n\n```\nstatic void afterInit() {\n        // 通过路由机制，初始化路由拦截机制。关于路由拦截机制的使用和原理，后续文章会有分析\n        interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation();\n    }\n\n```\n\n以上就是ARouter初始化的所有代码，关于如何查找到`com.alibaba.android.arouter.routes`包内所有文件这里便不做过多分析，大家可以去阅读 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)中`ClassUtils`这个类的源码。\n**总结下来，其实ARouter 的初始化只做了一件事，找到自己编译期产生的清单文件，把 Group 、Interceptor 、Provider 三种清单加载到 Warehouse 内存仓库中。**即下面这些文件，来源自AROUTER源码中的样例\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n\n值得注意的是，在初始化阶段，ARouter 仅载入了 Group 清单，并没有具体载入每个 Group 中包含的具体的路由节点清单，只有当使用到具体的 Group 时，才会加载对应的 Group 列表。这种分组管理，按需加载，大大的降低了初始化时的内存压力。并且`Warehouse`类中保存了路由清单，并且将使用过的路由对象缓存起来，之后查找都是直接使用缓存的对象 。\n\n###### 3.ARouter调用过程分析\n\n页面跳转最基本方法\n\n> ARouter.getInstance().build(\"/test/activity2\").navigation();\n\n获取Provider服务（实现了IProvider接口以及IProvider子类接口的服务类）的方法有两种：\n\n> 1.byName方式\n> ARouter.getInstance().build(\"/service/hello\").navigation()\n\n> 2.byType方式\n> ARouter.getInstance().navigation(HelloService.class)\n\nARouter路由跳转采用链式调用，`ARouter.getInstance()`其中采用的单例模式，获取ARouter的实例，这个就不作过多分析，主要分析`build()`和`navigation()`。\n\n**build()方法**\nARouter的`build(String path)`和`init()`方法一样，调用的是`_ARouter`的`build(String path)`方法。\n\n```\n  protected Postcard build(String path) {\n        if (TextUtils.isEmpty(path)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return build(path, extractGroup(path));\n        }\n    }\n\n```\n\n其中`extractGroup(String path)`就是根据path获取分组名，即path第一段“/”符号之间的值\n\n```\n  private String extractGroup(String path) {\n        if (TextUtils.isEmpty(path) || !path.startsWith(\"/\")) {\n            throw new HandlerException(Consts.TAG + \"Extract the default group failed, the path must be start with '/' and contain more than 2 '/'!\");\n        }\n\n        try {\n            //    /xxx1/xxx2   ===>  defaulGroup = xxx1\n            String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n            if (TextUtils.isEmpty(defaultGroup)) {\n                throw new HandlerException(Consts.TAG + \"Extract the default group failed! There's nothing between 2 '/'!\");\n            } else {\n                return defaultGroup;\n            }\n        } catch (Exception e) {\n            logger.warning(Consts.TAG, \"Failed to extract default group! \" + e.getMessage());\n            return null;\n        }\n    }\n\n```\n\n`build(String path)`方法最终调用的是`build(String path, String group)`\n\n```\n    protected Postcard build(String path, String group) {\n        if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return new Postcard(path, group);\n        }\n    }\n\n```\n\n**值得注意的是其中`ARouter.getInstance().navigation(PathReplaceService.class)`就是得到实现`PathReplaceService`接口的一个服务对象，对原始path进行处理后，生成新的path路径。而这个类需要我们自己自定义去实现，如果没有实现，pService=null，原始path不做任何处理。**\n下面是`PathReplaceService`接口，我们可以通过实现`forString()`和`forUri()`方法，对某些url进行替换处理，跳转到其他的目标页面。\n\n```\npublic interface PathReplaceService extends IProvider {\n\n    /**\n     * For normal path.\n     *\n     * @param path raw path\n     */\n    String forString(String path);\n\n    /**\n     * For uri type.\n     *\n     * @param uri raw uri\n     */\n    Uri forUri(Uri uri);\n}\n\n```\n\n最后返回一个`Postcard`实例对象，里面封装了路由节点的路径，分组等节点信息。其实`build()`方法的目的只有一个就是根据路由，封装成`Postcard`对象，其对象贯穿之后整个路由过程。Postcard 包含了众多的属性值，提供了路由过程中所有的控制变量。\n\n```\npublic final class Postcard extends RouteMeta {\n    private Uri uri;\n    private Object tag;             // A tag prepare for some thing wrong.\n    private Bundle mBundle;         // 传递的参数\n    private int flags = -1;         // intent 的flag标志\n    private int timeout = 300;      // Navigation timeout, TimeUnit.Second !\n    private IProvider provider;     // IProvider服务对象\n    private boolean greenChannal;\n    private SerializationService serializationService;//序列化服务对象\n\n     // 跳转动画\n    private Bundle optionsCompat;    // The transition animation of activity\n    private int enterAnim;\n    private int exitAnim;\n\n    // copy from RouteMeta \n    private RouteType type;         // 路由节点类型\n    private Element rawType;        \n    private Class<?> destination;  //需要跳转到的页面\n    private String path;            // 路径\n    private String group;           // 分组\n    private int priority = -1;      // 优先级\n    private int extra;              // 配置标识\n    private Map<String, Integer> paramsType;  // 路由页面被@Autowired注解属性\n    // ......\n}\n\n```\n\n**navigation()方法**\n关于页面跳转的`navigation()`方法有多个重载的方法，但最终都会调用`_ARouter`下面这个方法\n\n```\n    protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        try {\n            //首先对postcard进行一些处理，设置postcard的destination，type，priority 等一些属性值，completion()后面会有分析\n            LogisticsCenter.completion(postcard);\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n\n            if (debuggable()) { // Show friendly tips for user.\n                Toast.makeText(mContext, \"There's no route matched!\\n\" +\n                        \" Path = [\" + postcard.getPath() + \"]\\n\" +\n                        \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show();\n            }\n            // 如果处理postcard失败，通过 callback 回调失败结果\n           // callback为空的情况下，如果有定义全局的降级处理（DegradeService），则使用全局处理\n           //降级处理也需要我们自己实现DegradeService接口\n            if (null != callback) {\n                callback.onLost(postcard);\n            } else {    // No callback for this invoke, then we use the global degrade service.\n                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);\n                if (null != degradeService) {\n                    degradeService.onLost(context, postcard);\n                }\n            }\n\n            return null;\n        }\n         //路由处理成功，回调callback.onFound()\n        if (null != callback) {\n            callback.onFound(postcard);\n        }\n\n        //目前来说，PROVIDER服务类型，以及FRAGMENT类型不需要通过拦截器外，其他类型均需要通过拦截器\n        //关于拦截器相关用法及原理分析在后续的文章中会讲解到，大家去可以关注下\n        if (!postcard.isGreenChannel()) {   \n            interceptorService.doInterceptions(postcard, new InterceptorCallback() {\n                /**\n                 * Continue process\n                 *\n                 * @param postcard route meta\n                 */\n                @Override\n                public void onContinue(Postcard postcard) {\n                    _navigation(context, postcard, requestCode, callback);\n                }\n\n                /**\n                 * Interrupt process, pipeline will be destory when this method called.\n                 *\n                 * @param exception Reson of interrupt.\n                 */\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    if (null != callback) {\n                        callback.onInterrupt(postcard);\n                    }\n\n                    logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage());\n                }\n            });\n        } else {\n            return _navigation(context, postcard, requestCode, callback);\n        }\n\n        return null;\n    }\n\n```\n\n**值得注意的是，当跳转路由处理失败的时候，会获取一个降级服务，我们可以实现`DegradeService`接口，实现`onLost()`方法，对路由处理失败的情况进行处理，比如跳转到一个信息提示页面，让用户去更新版本等操作等。** 下面是`DegradeService`接口：\n\n```\npublic interface DegradeService extends IProvider {\n\n    /**\n     * Router has lost.\n     *\n     * @param postcard meta\n     */\n    void onLost(Context context, Postcard postcard);\n}\n\n```\n\n通过上面代码的分析，不管是否通过拦截器进行处理，最后都会调用`_navigation()`达到路由的目的：\n\n```\nprivate Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                //下面就是最基本的使用intent进行activity进行跳转\n                // 创建intent\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                //设置传参\n                intent.putExtras(postcard.getExtras());\n\n                //activity启动标志\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n\n                // 在主线程中进行跳转\n                new Handler(Looper.getMainLooper()).post(new Runnable() {\n                    @Override\n                    public void run() {\n                        //新版本带转场动画的启动方式\n                        if (requestCode > 0) {  // Need start for result\n                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());\n                        } else {\n                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());\n                        }\n\n                        if ((0 != postcard.getEnterAnim() || 0 != postcard.getExitAnim()) && currentContext instanceof Activity) {    // Old version.\n                            //老版本的跳转动画\n                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());\n                        }\n                        //跳转成功，回调callback.onArrival()\n                        if (null != callback) { // Navigation over.\n                            callback.onArrival(postcard);\n                        }\n                    }\n                });\n\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                     //实例化fragment，并传递参数\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n\n```\n\n目前仅ARouter实现了 ACTIVITY ， PROVIDER ，FRAGMENT三种种类型。上面关于postcard的provider，destination的值都是在`completion()`中设置的。我们接着看`LogisticsCenter`的`completion(Postcard postcard)`。\n\n```\n    public synchronized static void completion(Postcard postcard) {\n        if (null == postcard) {\n            throw new NoRouteFoundException(TAG + \"No postcard!\");\n        }\n\n        // 查找Warehouse仓库的路由节点缓存，看是否已在缓存中\n        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n        if (null == routeMeta) {   \n          // 如果没有，查找仓库的组别清单中是否存在该组别，组别清单已经在初始化的时候加载到仓库中去了\n            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  \n            //如果没有抛出异常\n            if (null == groupMeta) {\n                throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n            } else {\n                // Load route and cache it into memory, then delete from metas.\n                try {\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                    // 实例化个组别的类，调用loadInto()，将组别中所有的路由节点加载进仓库Warehouse.routes，缓存\n                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n                    iGroupInstance.loadInto(Warehouse.routes);\n                     // 从组别清单中删除已加载的组别，防止重复加载\n                    Warehouse.groupsIndex.remove(postcard.getGroup());\n\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                } catch (Exception e) {\n                    throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\");\n                }\n                //当路由节点加载到缓存中去后，重新查找执行else代码，对postcard进行处理\n                completion(postcard);   // Reload\n            }\n        } else {\n            //给postcard设置destination,type,priority等值，供上面讲解到的_navigation()进行使用\n            // 其中routeMeta是在ARouter$$Group$$xxx的loadInto中创建的\n            postcard.setDestination(routeMeta.getDestination());\n            postcard.setType(routeMeta.getType());\n            postcard.setPriority(routeMeta.getPriority());\n            postcard.setExtra(routeMeta.getExtra());\n\n            //如果通过build(Uri url) 进行跳转的话 通过解析url ，将传参保存进bundle中\n            Uri rawUri = postcard.getUri();\n            if (null != rawUri) {  \n                //splitQueryParameters()就是在uri中携带的参数进行解析\n                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);\n                Map<String, Integer> paramsType = routeMeta.getParamsType();\n\n                if (MapUtils.isNotEmpty(paramsType)) {\n                    // Set value by its type, just for params which annotation by @Param\n                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {\n                        setValue(postcard,\n                                params.getValue(),\n                                params.getKey(),\n                                resultMap.get(params.getKey()));\n                    }\n\n                    // Save params name which need autoinject.\n                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));\n                }\n\n                // Save raw uri\n                postcard.withString(ARouter.RAW_URI, rawUri.toString());\n            }\n\n            //从这里也可以看出PROVIDER，FRAGMENT不需要通过拦截器\n            switch (routeMeta.getType()) {\n                case PROVIDER:  \n                    // 如果是PROVIDER节点类型，从服务节点列表中获取，如果没有，则实例化，并保存在服务节点列表Warehouse.providers中\n                  //并将实例化的对象设置给postcard的provider属性\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    if (null == instance) { // There's no instance of this provider\n                        IProvider provider;\n                        try {\n                            provider = providerMeta.getConstructor().newInstance();\n                            provider.init(mContext);\n                            Warehouse.providers.put(providerMeta, provider);\n                            instance = provider;\n                        } catch (Exception e) {\n                            throw new HandlerException(\"Init provider failed! \" + e.getMessage());\n                        }\n                    }\n                    postcard.setProvider(instance);\n                    postcard.greenChannel();    // Provider should skip all of interceptors\n                    break;\n                case FRAGMENT:\n                    postcard.greenChannel();    // Fragment needn't interceptors\n                default:\n                    break;\n            }\n        }\n    }\n\n```\n\n分析到这里，关于页面基本跳转的原理分析就已经结束了。最后就是关于获取Provider服务两种方法的源码分析。其中byName方式，和页面跳转是一模一样的。我们只需要看看byType方式即可。byType方式最后调用的是`_ARouter`的`navigation(Class<? extends T> service)`\n\n```\n  protected <T> T navigation(Class<? extends T> service) {\n        try {\n            // 通过 className 获取 Postcard 对象\n            Postcard postcard = LogisticsCenter.buildProvider(service.getName());\n\n            // 兼容1.0.5 compiler sdk版本.\n            if (null == postcard) { // No service, or this service in old version.\n                postcard = LogisticsCenter.buildProvider(service.getSimpleName());\n            }\n           // 对 Postcard 对象进行处理\n            LogisticsCenter.completion(postcard);\n             //返回 Postcard 中的 provider 属性值\n            return (T) postcard.getProvider();\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n            return null;\n        }\n    }\n\n```\n\n上面代码中的`completion()`方法之前已经分析过了，只需要看下`LogisticsCenter.buildProvider(service.getName())`即可。\n\n```\n  public static Postcard buildProvider(String serviceName) {\n        RouteMeta meta = Warehouse.providersIndex.get(serviceName);\n\n        if (null == meta) {\n            return null;\n        } else {\n            return new Postcard(meta.getPath(), meta.getGroup());\n        }\n    }\n\n```\n\n这个方法非常的简单，就是根据服务类名去仓库Warehouse.providersIndex中获去路由节点元素，然后封装在Postcard对象中。服务类清单列表Warehouse.providersIndex中的值是在初始化时缓存的。**值得注意的是，PROVIDER 类型的路由节点既存在于对应的分组中，也存在于服务类清单列表中。所以，ARouter 可通过byType，byName两种方式来获取**。\n\n##### 补充\n\n关于ARouter的基本用法上面只有最基本跳转的介绍，下面对其他一些基本使用进行下补充\n\n*   **带参数跳转**\n\n```\n//1.传递参数\n ARouter.getInstance().build(\"/test/activity1\")\n                        .withString(\"name\", \"老王\")\n                        .withInt(\"age\", 18)\n                        .withBoolean(\"boy\", true)\n                        .withLong(\"high\", 180)\n                        .withString(\"url\", \"https://a.b.c\")\n                        .withParcelable(\"pac\", testParcelable)\n                        .withObject(\"obj\", testObj)\n                        .navigation();\n\n//2.直接传递Bundle\n  Bundle params = new Bundle();\n  ARouter.getInstance()\n          .build(\"/test/activity1\")\n          .with(params)\n          .navigation();\n\n```\n\n这些传参都是保存在生成的`postcard`对象中的`mBundle`属性里，然后在跳转的时候通过`intent.putExtras(postcard.getExtras())`达到传送参数的目的。\n值得注意的是，关于对象的传递有两种，一种是`withParcelable()`方法，不过此方法需要传递的对象实现`Parcelable`接口，达到序列化的目的；另外一种是`withObject()`方法，此方法的原理是将实体类转换成json字符串，通过String的方式进行传递，而且使用这种方式需要实现 SerializationService，并使用@Route注解标注，下面是ARouter样例：\n\n```\n@Route(path = \"/service/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n\n```\n\n而且，需要在跳转到的页面获取`JsonServiceImpl`服务，将json字符串转换成对象。\n\n```\nSerializationService serializationService = ARouter.getInstance().navigation(SerializationService.class);\nTestObj obj = serializationService.json2Object(getIntent().getString(\"obj\"), TestObj.class);\n\n```\n\n*   **带返回结果跳转**\n\n```\nARouter.getInstance().build(\"/test/activity2\").navigation(this, 666);\n\n```\n\n值得注意的是，这时候的 `navigation`需要传递activit和requestCode。\n\n*   **获取Fragment的实例**\n\n定义一个fragment\n\n```\n@Route(path = \"/test/fragment\")\npublic class BlankFragment extends Fragment {\n    public BlankFragment() {\n        //必须要一个空的构造器\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        TextView textView = new TextView(getActivity());\n        return textView;\n    }\n\n}\n\n```\n\n获取frament\n\n```\nFragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation();\n\n```\n\n*   **带转场动画跳转**\n\n```\n// 转场动画(常规方式)\n ARouter.getInstance() .build(\"/test/activity2\")\n                      .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)\n                      .navigation(this);\n\n// 转场动画(API16+)\n ActivityOptionsCompat compat = ActivityOptionsCompat.makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);\nARouter.getInstance().build(\"/test/activity2\").withOptionsCompat(compat) .navigation();\n\n```\n\n*   **获取服务**\n\n服务是全局单例的，只有在第一次使用到的时候才会被初始化。\n暴露服务，必须实现IProvider 接口 或者其子类型\n\n```\n// 声明接口,其他组件通过接口来调用服务\npublic interface HelloService extends IProvider {\n    String sayHello(String name);\n}\n\n// 实现接口\n@Route(path = \"/service/hello\", name = \"测试服务\")\npublic class HelloServiceImpl implements HelloService {\n\n    @Override\n    public String sayHello(String name) {\n    return \"hello, \" + name;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n}\n\n```\n\n获取服务\n\n```\n//bytype\nHelloService helloService1 = ARouter.getInstance().navigation(HelloService.class);\n//byname\nHelloService helloService2 = (HelloService) ARouter.getInstance().build(\"/service/hello\").navigation();\n\n```\n\n*   **多模块结构**\n\n![](//upload-images.jianshu.io/upload_images/5994347-767a114aa4746c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\napp中可能存在多个模块，每个模块下面都有一个root结点，每个root结点都会管理整个模块中的group节点，每个group结点则包含了该分组下的所有页面，而每个模块允许存在多个分组，每个模块中都会有一个拦截器节点就是Interceptor结点，除此之外每个模块还会有控制拦截反转的provider结点\n\n##### 最后\n\n到此，关于ARouter的基本用法以及原理分析的就全部结束了，如果有不清楚或者错误的地方，希望各位同学指出。关于ARouter拦截器，各种服务，依赖注入等更多进阶用法及源码分析会更新在后续的文章。\n\n**如果各位同学认为本文对你有一些帮助，希望能点个喜欢，谢谢！**\n\n小礼物走一走，来简书关注我\n\n赞赏支持\n\n[android开发问题](/nb/12473806)\n\n© 著作权归作者所有\n\n举报文章\n\n[![96](//upload.jianshu.io/users/upload_avatars/5994347/dd34592b-ad62-4e24-bb66-f7c689766b2f.png?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96) ](/u/d65e2e163603) 关注 [time_fly](/u/d65e2e163603)\n\n写了 24037 字，被 37 人关注，获得了 92 个喜欢\n\n喜欢\n\n12\n\n[](javascript:void((function(s,d,e,r,l,p,t,z,c){var%20f='http://v.t.sina.com.cn/share/share.php?appkey=1881139527',u=z||d.location,p=['&url=',e(u),'&title=',e(t||d.title),'&source=',e(r),'&sourceUrl=',e(l),'&content=',c||'gb2312','&pic=',e(p||'')].join('');function%20a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=440,height=430,left=',(s.width-440)/2,',top=',(s.height-430)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent))setTimeout(a,0);else%20a();})(screen,document,encodeURIComponent,'','','', '推荐 @龍儱滝 的文章《阿里ARouter使用及源码解析（一）》（ 分享自 @简书 ）','https://www.jianshu.com/p/46d174f37e82?utm_campaign=maleskine&utm_content=note&utm_medium=reader_share&utm_source=weibo','页面编码gb2312|utf-8默认gb2312'));)[](http://cwb.assets.jianshu.io/notes/images/13526520/weibo/image_bcbd18a5f866.png)[更多分享](javascript:void(0);)\n\n![](//upload.jianshu.io/users/upload_avatars/1786025/f63ccf82f6f8?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114) \n\n3条评论 只看作者 关闭评论\n\n按喜欢排序按时间正序按时间倒序\n\n[![](//cdn2.jianshu.io/assets/default_avatar/11-4d7c6ca89f439111aff57b23be1c73ba.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/ab7bfd384c72)\n\n[winter818](/u/ab7bfd384c72)\n\n2楼 · 2017.08.23 17:56\n\n666 学习了\n\n1人赞 回复 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/426662/e85a4080db83?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/a2a56d463e3d)\n\n[夏鸣浩](/u/a2a56d463e3d)\n\n3楼 · 2017.09.04 17:40\n\n正在拜读，博主辛苦\n\n赞 回复 举报\n\n[![](//upload.jianshu.io/users/upload_avatars/7293029/42130be5-9eb3-4cf2-8874-1f32e70d81e2?imageMogr2/auto-orient/strip|imageView2/1/w/114/h/114)](/u/df76f81fe3ff)\n\n[却把清梅嗅2](/u/df76f81fe3ff)\n\n4楼 · 2017.12.13 16:23\n\n好文，楼主辛苦\n\n赞 回复 举报\n\n作者：time_fly\n链接：https://www.jianshu.com/p/46d174f37e82\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[0,54215],[0,0]]],[1519699698712,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,0,"在app的开发中，页面之间的相互跳转是最基本常用的功能。在Android中的跳转一般通过显式intent和隐式intent两种方式实现的，而Android的原生跳转方式会存在一些缺点：\n\n*   显式intent的实现方式，因为会存在直接的类依赖的问题，导致耦合严重；\n*   隐式intent的实现方式，则会出现规则集中式管理，导致协作变得困难；\n*   可配置性较差，一般而言配置规则都是在Manifest中的，这就导致了扩展性较差；\n*   跳转过程无法控制，一旦使用了StartActivity()就无法插手其中任何环节了，只能交给系统管理；\n*   当多组件化开发，使用原生的路由方式很难实现完全解耦；\n\n而阿里的[ARouter](https://link.jianshu.com?t=https://github.com/alibaba/ARouter)路由框架具有解耦、简单易用、支持多模块项目、定制性较强、支持拦截逻辑等诸多优点，很好的解决了上述的问题。关于ARouter具体实现功能，典型应用以及相应技术方案实现的介绍不在这详细介绍，具体可参见[开源最佳实践：Android平台页面路由框架ARouter](https://link.jianshu.com?t=https://yq.aliyun.com/articles/71687?t=t1)。\n\n阿里ARouter的分析计划\n\n*   [阿里ARouter使用及源码解析（一）](https://www.jianshu.com/p/46d174f37e82)\n*   [阿里ARouter拦截器使用及源码解析（二）](https://www.jianshu.com/p/c8d7b1379c1b)\n*   阿里ARouter参数自动装载使用及源码解析（三）\n\n##### 基本功能使用\n\n1.添加依赖和配置\n\n```\nandroid {\n    defaultConfig {\n    ...\n    javaCompileOptions {\n        annotationProcessorOptions {\n        arguments = [ moduleName : project.getName() ]\n        }\n    }\n    }\n}\n\ndependencies {\n    compile 'com.alibaba:arouter-api:1.2.1.1'\n    annotationProcessor 'com.alibaba:arouter-compiler:1.1.2.1'\n    ...\n}\n\n```\n\n2.添加注解\n\n```\n// 在支持路由的页面上添加注解(必选)\n// 这里的路径需要注意的是至少需要有两级，/xx/xx\n@Route(path = \"/test/test1\")\npublic class Test1Activity extends AppCompatActivity{\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_test1);\n    }\n}\n\n```\n\n3.初始化SDK\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            // 如果使用了InstantRun，必须在初始化之前开启调试模式，但是上线前需要关闭，InstantRun仅用于开发阶段，\n            // 线上开启调试模式有安全风险，可以使用BuildConfig.DEBUG来区分环境\n            ARouter.openDebug();\n            ARouter.init(getApplication()); // 尽可能早，推荐在Application中初始化\n        }\n    }\n}\n\n```\n\n4.发起跳转操作\n\n```\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n    private Button btn1,btn2;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        btn1 = (Button) findViewById(R.id.btn1);\n        btn2 = (Button) findViewById(R.id.btn2);\n\n        btn1.setOnClickListener(this);\n        btn2.setOnClickListener(this);\n    }\n\n    @Override\n    public void onClick(View v) {\n        if (v.getId() == R.id.btn1) {\n            ....\n        } else if (v.getId() == R.id.btn2){\n            ARouter.getInstance().build(\"/test/test1\").navigation();\n        }\n    }\n}\n\n```\n\n以上相关代码就是ARouter的最基本功能使用的步骤，下面来分析跳转功能是如何实现的。\n\n##### 原理分析\n\n###### 1.ARouter编译的过程\n\nARouter在编译期的时候，利用自定义注解完成了页面的自动注册。相关注解源码参见[arouter-annotation](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-annotation)，编译处理器源码参见[arouter-compiler](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-compiler)\n\n下面是注解`@Route`的源码介绍：\n\n```\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.CLASS)\npublic @interface Route {\n\n    /**\n     *路由的路径，标识一个路由节点\n     */\n    String path();\n\n    /**\n     * 将路由节点进行分组，可以实现按组动态加载\n     */\n    String group() default \"\";\n\n    /**\n     * 路由节点名称，可用于生成javadoc文档\n     */\n    String name() default \"undefined\";\n\n    /**\n     * 用32位int类型标示，可用于页面的一些配置\n     */\n    int extras() default Integer.MIN_VALUE;\n\n    /**\n     * 路由的优先级\n     */\n    int priority() default -1;\n}\n\n```\n\nRoute中的`extra`值是个int值，由32位表示，即转换成二进制后，一个int中可以配置31个1或者0，而每一个0或者1都可以表示一项配置（排除符号位），如果从这31个位置中随便挑选出一个表示是否需要登录就可以了，只要将标志位置为1，就可以在声明的拦截器中获取到这个标志位，通过位运算的方式判断目标页面是否需要登录。所以可以通过`extra`给页面配置30多个属性，然后在拦截器中去进行处理。\nARouter在拦截器中会把目标页面的信息封装一个类`Postcard`，这个类就包含了目标页面注解上`@Route`标识的各种信息。关于拦截器的使用以及源码分析，后续会有介绍。\n\n将代码编译一遍，可以看到ARouter生成下面几个源文件：\n\n![](//upload-images.jianshu.io/upload_images/5994347-6c409a3386b0abd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/327)\n\n上面三个文件均是通过注解处理器`RouteProcessor`生成的，关于如何自定义注解处理器，可以阅读[Android编译时注解APT实战（AbstractProcessor）](https://www.jianshu.com/p/07ef8ba80562)，同时也需要学习**JavaPoet**的基本使用。下面我们看`RouteProcessor`是如何生成相关文件的。\n\n```\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        //判断被注解了的元素集合是否为空\n        if (CollectionUtils.isNotEmpty(annotations)) {\n            //获取所有被@Route注解的元素集合，Element可以是类、方法、变量等\n            Set<? extends Element> routeElements = roundEnv.getElementsAnnotatedWith(Route.class);\n            try {\n                logger.info(\">>> Found routes, start... <<<\");\n                //具体处理注解，生成java文件的方法\n                this.parseRoutes(routeElements);\n\n            } catch (Exception e) {\n                logger.error(e);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n```\n\n`process()`方法相当于处理器的主函数`main()`，可以在这个方法中扫描、评估和处理注解的代码，以及生成Java文件。`RouteProcessor`中调用了`parseRoutes()`，用来处理所有被`@Route`注解的元素。在分析上述三个java文件如何生成之前，先看看生成文件的具体代码。\n\n*   ARouter$$Root$$app类\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n*   ARouter$$Group$$test类\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    atlas.put(\"/test/test1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/test1\", \"test\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   ARouter$$Providers$$app类\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n  }\n}\n\n```\n\n我们接着分析上述三个文件是如何生成的\n\n1.首先获取生成方法的参数的类型和参数名称\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n\n            logger.info(\">>> Found routes, size is \" + routeElements.size() + \" <<<\");\n\n            rootMap.clear();\n             // TypeElement 表示一个类或接口元素\n            // public static final String ACTIVITY = \"android.app.Activity\";\n            //得到类activity元素\n            TypeElement type_Activity = elementUtil.getTypeElement(ACTIVITY);\n            // public static final String SERVICE = \"android.app.Service\";\n            //得到类service的元素\n            TypeElement type_Service = elementUtil.getTypeElement(SERVICE);\n            // public static final String SERVICE = \"android.app.Fragment\";\n            TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();\n             // public static final String SERVICE = \"android.support.v4.app.Fragment\";\n            TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();\n\n            // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IRouteGroup\";\n            //得到接口IRouteGroup元素\n            TypeElement type_IRouteGroup = elementUtil.getTypeElement(IROUTE_GROUP);\n          // public static final String IROUTE_GROUP = \"com.alibaba.android.arouter.facade.template.IProviderGroup\";\n            //得到接口IProviderGroup元素\n            TypeElement type_IProviderGroup = elementUtil.getTypeElement(IPROVIDER_GROUP);\n            //获取RouteMeta，RouteType类名\n            ClassName routeMetaCn = ClassName.get(RouteMeta.class);\n            ClassName routeTypeCn = ClassName.get(RouteType.class);\n\n            //下面代码是获取生成java文件中方法的参数类型名称和参数名称。\n            /*\n              获取获取ARouter$$Root$$app 类中方法参数Map<String, Class<? extends IRouteGroup>>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ParameterizedTypeName.get(\n                            ClassName.get(Class.class),\n                            WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))\n                    )\n            );\n\n            /*\n              获取ARouter$$Group$$test，ARouter$$Providers$$app类中方法参数 Map<String, RouteMeta>类型的名称\n             */\n            ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(\n                    ClassName.get(Map.class),\n                    ClassName.get(String.class),\n                    ClassName.get(RouteMeta.class)\n            );\n\n            /*\n             获取相关的参数\n             */\n            //获取ARouter$$Root$$app 类中方法的参数Map<String, Class<? extends IRouteGroup>> routes\n            ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, \"routes\").build();\n           //获取ARouter$$Group$$test类中方法的参数Map<String, RouteMeta> atlas\n            ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"atlas\").build();\n             //获取ARouter$$Providers$$app类中方法的参数Map<String, RouteMeta> providers\n            ParameterSpec providerParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, \"providers\").build();  \n\n          .....\n        }\n    }\n\n```\n\n2.获取了方法的参数的类型和参数名称后，下面便是生成相应的方法\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n            /*\n              首先创建ARouter$$Root$$xxx 类中的loadInto()方法\n              @Override\n              public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(rootParamSpec);\n\n            //  遍历所有被@Route注解的元素\n            for (Element element : routeElements) {\n                TypeMirror tm = element.asType();\n                Route route = element.getAnnotation(Route.class);\n                RouteMeta routeMete = null;\n\n                //判断该元素否为 Activity 、IProvider 、 Service 的子类，然后创建相应的RouteMeta 对象\n                if (typeUtil.isSubtype(tm, type_Activity.asType())) {                 // Activity\n                    logger.info(\">>> Found activity route: \" + tm.toString() + \" <<<\");\n\n                    // 如果是acitiviy类型，获取所有被@Autowired的属性\n                    //关于@Autowired的注解，我们之后再进行分析\n                    Map<String, Integer> paramsType = new HashMap<>();\n                    for (Element field : element.getEnclosedElements()) {\n                        if (field.getKind().isField() && field.getAnnotation(Autowired.class) != null && !typeUtil.isSubtype(field.asType(), iProvider)) {\n                            // It must be field, then it has annotation, but it not be provider.\n                            Autowired paramConfig = field.getAnnotation(Autowired.class);\n                            paramsType.put(StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name(), TypeUtils.typeExchange(field.asType()));\n                        }\n                    }\n                    // ACTIVITY类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.ACTIVITY, paramsType);\n                } else if (typeUtil.isSubtype(tm, iProvider)) {         // IProvider\n                    logger.info(\">>> Found provider route: \" + tm.toString() + \" <<<\");\n                    //从该判断可看出，如果要想成功注册一个 PROVIDER 类型的路由节点，\n                    //一定要实现 com.alibaba.android.arouter.facade.template.IProvider 这个接口\n                    routeMete = new RouteMeta(route, element, RouteType.PROVIDER, null);\n                } else if (typeUtil.isSubtype(tm, type_Service.asType())) {           // Service\n                    logger.info(\">>> Found service route: \" + tm.toString() + \" <<<\");\n                     //SERVICE类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(SERVICE), null);\n                } else if (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) {\n                    logger.info(\">>> Found fragment route: \" + tm.toString() + \" <<<\");\n                   //FRAGMENT类型节点\n                    routeMete = new RouteMeta(route, element, RouteType.parse(FRAGMENT), null);\n                }\n\n                //routeMete包含了每个路由节点的各种信息，下面的方法的主要功能就是根据@Route注解信息对节点进行分组，保存在groupMap集合中。\n               //关于方法的具体实现，后面会有解析\n                categories(routeMete);\n\n            }\n\n            .........\n        }\n    }\n\n```\n\n以上代码主要功能就是遍历所有被@Route注解的元素，然后将每个路由节点的信息按照类型（ACTIVITY类型，实现了IProvider 接口类型以及SERVICE类型）封装到`RouteMeta`中，最后调用`categories(routeMete)`方法将节点分组，保存在`groupMap`集合。\n\n继续往下分析\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n\n             /*\n              然后创建ARouter$$Providers$$xxx 类中的loadInto()方法\n             @Override\n             public void loadInto(Map<String, RouteMeta> providers) {}\n             */\n            MethodSpec.Builder loadIntoMethodOfProviderBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .addParameter(providerParamSpec);\n\n            //遍历分组的集合，生成相应的java文件\n           //因为本文使用的例子没有对页面进行分组，所以只生成了一个组文件ARouter$$Group$$xxx\n            for (Map.Entry<String, Set<RouteMeta>> entry : groupMap.entrySet()) {\n                String groupName = entry.getKey();\n               /*\n                  创建ARouter$$Group$$xxx 类中的loadInto()方法\n                 @Override\n                 public void loadInto(Map<String, RouteMeta> atlas) {}\n             */\n                MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)\n                        .addAnnotation(Override.class)\n                        .addModifiers(PUBLIC)\n                        .addParameter(groupParamSpec);\n\n                // 生成loadInto()方法体\n                Set<RouteMeta> groupData = entry.getValue();\n                //遍历每个组里面的路由节点\n                for (RouteMeta routeMeta : groupData) {\n                    switch (routeMeta.getType()) {\n                        //如果节点类型是PROVIDER，\n                        case PROVIDER:  \n                          //获取路由节点元素的接口集合\n                            List<? extends TypeMirror> interfaces = ((TypeElement) routeMeta.getRawType()).getInterfaces();\n                            for (TypeMirror tm : interfaces) {\n                             if (types.isSameType(tm, iProvider)) {   // Its implements iProvider interface himself.\n                                   //路由节点元素其中一个接口是 com.alibaba.android.arouter.facade.template.IProvider \n                                  //给ARouter$$Providers$$xxx 类中的loadInto()添加方法体\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            (routeMeta.getRawType()).toString(),//路由节点元素的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                } else if (types.isSubtype(tm, iProvider)) {\n                                   //路由节点元素其中一个接口是com.alibaba.android.arouter.facade.template.IProvider 接口的子类型\n                                    loadIntoMethodOfProviderBuilder.addStatement(\n                                            \"providers.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, null, \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                                            tm.toString(),   //IProvider子类型的全名\n                                            routeMetaCn,\n                                            routeTypeCn,\n                                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                                            routeMeta.getPath(),\n                                            routeMeta.getGroup());\n                                }\n                            //上面方法体的代码为：\n                          //providers.put(\"实现接口的名称\", RouteMeta.build(RouteType.PROVIDER, 类名.class,   \"@Route.path\", \"@Route.group\", null, @Route.priority, @Route.extras));\n                            }\n                            break;\n                        default:\n                            break;\n                    }\n\n                    // 将路由节点中被@Autowired注解的属性集合转换成字符串\n                    StringBuilder mapBodyBuilder = new StringBuilder();\n                    //获取路由节点中被@Autowired注解的属性集合\n                    Map<String, Integer> paramsType = routeMeta.getParamsType();\n                    if (MapUtils.isNotEmpty(paramsType)) {\n                        for (Map.Entry<String, Integer> types : paramsType.entrySet()) {\n                            mapBodyBuilder.append(\"put(\\\"\").append(types.getKey()).append(\"\\\", \").append(types.getValue()).append(\"); \");\n                        }\n                    }\n                    String mapBody = mapBodyBuilder.toString();\n\n                    //给ARouter$$Group$$xxx 类中的loadInto()添加方法体\n                    //注意：有多个分组就会创建多个组文件\n                    loadIntoMethodOfGroupBuilder.addStatement(\n                            \"atlas.put($S, $T.build($T.\" + routeMeta.getType() + \", $T.class, $S, $S, \" + (StringUtils.isEmpty(mapBody) ? null : (\"new java.util.HashMap<String, Integer>(){{\" + mapBodyBuilder.toString() + \"}}\")) + \", \" + routeMeta.getPriority() + \", \" + routeMeta.getExtra() + \"))\",\n                            routeMeta.getPath(),\n                            routeMetaCn,\n                            routeTypeCn,\n                            ClassName.get((TypeElement) routeMeta.getRawType()),\n                            routeMeta.getPath().toLowerCase(),\n                            routeMeta.getGroup().toLowerCase());\n                }\n\n                  // 真正生成ARouter$$Group$$test JAVA文件\n                 //NAME_OF_GROUP = ARouter$$Group$$\n                //  groupName = test; 关于groupname的值在方法categories(routeMete)中会有讲解\n                String groupFileName = NAME_OF_GROUP + groupName;\n                JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                        TypeSpec.classBuilder(groupFileName)\n                                .addJavadoc(WARNING_TIPS)\n                                .addSuperinterface(ClassName.get(type_IRouteGroup))\n                                .addModifiers(PUBLIC)\n                                .addMethod(loadIntoMethodOfGroupBuilder.build())\n                                .build()\n                ).build().writeTo(mFiler);\n\n                logger.info(\">>> Generated group: \" + groupName + \"<<<\");\n                //将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备\n                rootMap.put(groupName, groupFileName);\n            }\n\n         .......\n        }\n    }\n\n```\n\n以上代码主要功能由几点：\n\n*   遍历`groupmap`集合给ARouter$$Group$$xxx类中的`loadInto()`添加方法体，并且生成ARouter$$Group$$xxx JAVA文件，而文件命名为ARouter$$Group$$+groupname，其中有多个分组就会创建多个组文件。比如`AROUTER`源码中的样例就生成了多个分组文件\n\n![](//upload-images.jianshu.io/upload_images/5994347-bd709da910e3a722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/592)\n\n两个分组文件\n\n关于生成的`loadInto()`中的方法体的例子，来自 `AROUTER`源码中的样例：\n\n```\npublic class ARouter$$Group$$test implements IRouteGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> atlas) {\n    //存在被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity1\", RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, \"/test/activity1\", \"test\", new java.util.HashMap<String, Integer>(){{put(\"name\", 18); put(\"boy\", 0); put(\"age\", 3); put(\"url\", 18); }}, -1, -2147483648));\n    .....\n   //没有被@Autowired注解参数生成的代码\n    atlas.put(\"/test/activity4\", RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, \"/test/activity4\", \"test\", null, -1, -2147483648));\n    ....\n  }\n}\n\n```\n\n*   遍历每个组里面的路由节点，查找节点类型是否为PROVIDER类型，如果是就向给ARouter$$Providers$$xxx类中的`loadInto()`添加方法，其文件命名ARouter$$Providers$$+modulename。关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Providers$$app implements IProviderGroup {\n  @Override\n  public void loadInto(Map<String, RouteMeta> providers) {\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.HelloService\", RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, \"/service/hello\", \"service\", null, -1, -2147483648));\n    //路由节点元素其中一个接口是IProvider的子类型\n    providers.put(\"com.alibaba.android.arouter.facade.service.SerializationService\", RouteMeta.build(RouteType.PROVIDER, JsonServiceImpl.class, \"/service/json\", \"service\", null, -1, -2147483648));\n     //路由节点元素其中一个接口是IProvider接口\n    providers.put(\"com.alibaba.android.arouter.demo.testservice.SingleService\", RouteMeta.build(RouteType.PROVIDER, SingleService.class, \"/service/single\", \"service\", null, -1, -2147483648));\n  }\n}\n\n```\n\n*   将生成的组文件放在rootmap集合中去，为下面生成ARouter$$Root$$xxx文件做准备，其文件命名ARouter$$Root$$+modulename。\n\n我们接着分析`parseRoutes()`方法最后一段代码，这段代码其实很简单，主要目的就是给ARouter$$Root$$xxx的`loadInto()`添加方法体，最后生成Router$$Providers$$xxx，ARouter$$Root$$xxx文件\n\n```\n private void parseRoutes(Set<? extends Element> routeElements) throws IOException {\n        if (CollectionUtils.isNotEmpty(routeElements)) {\n            ........\n            //遍历rootMap集合，给ARouter$$Root$$xxx的`loadInto()`添加方法体\n            if (MapUtils.isNotEmpty(rootMap)) {\n                // Generate root meta by group name, it must be generated before root, then I can findout the class of group.\n                for (Map.Entry<String, String> entry : rootMap.entrySet()) {\n                    loadIntoMethodOfRootBuilder.addStatement(\"routes.put($S, $T.class)\", entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));\n                }\n            }\n\n            // 生成Router$$Providers$$xxx文件\n            String providerMapFileName = NAME_OF_PROVIDER + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(providerMapFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(type_IProviderGroup))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfProviderBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated provider map, name is \" + providerMapFileName + \" <<<\");\n\n            // 生成ARouter$$Root$$xxx文件\n            String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName;\n            JavaFile.builder(PACKAGE_OF_GENERATE_FILE,\n                    TypeSpec.classBuilder(rootFileName)\n                            .addJavadoc(WARNING_TIPS)\n                            .addSuperinterface(ClassName.get(elementUtil.getTypeElement(ITROUTE_ROOT)))\n                            .addModifiers(PUBLIC)\n                            .addMethod(loadIntoMethodOfRootBuilder.build())\n                            .build()\n            ).build().writeTo(mFiler);\n\n            logger.info(\">>> Generated root, name is \" + rootFileName + \" <<<\");\n        }\n    }\n\n```\n\n关于生成的`loadInto()`中的方法体的例子，来自 AROUTER源码中的样例：\n\n```\npublic class ARouter$$Root$$app implements IRouteRoot {\n  @Override\n  public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {\n    routes.put(\"service\", ARouter$$Group$$service.class);\n    routes.put(\"test\", ARouter$$Group$$test.class);\n  }\n}\n\n```\n\n**上面分析的便是`parseRoutes()`方法所有代码的解析**\n\n3.最后我们看下`categories()`方法是如何分组的\n\n```\n   private void categories(RouteMeta routeMete) {\n        //如果路由路径合法，且有groupname进行执行\n        if (routeVerify(routeMete)) {\n            logger.info(\">>> Start categories, group = \" + routeMete.getGroup() + \", path = \" + routeMete.getPath() + \" <<<\");\n             //根据groupname获取该组的路由节点集合，如果集合为空，则创建一个新的组，将该节点添加进去，并将组集合保存在groupmap中；\n          //不为空，则添加到所属的组集合中去\n            Set<RouteMeta> routeMetas = groupMap.get(routeMete.getGroup());\n            if (CollectionUtils.isEmpty(routeMetas)) {\n                Set<RouteMeta> routeMetaSet = new TreeSet<>(new Comparator<RouteMeta>() {\n                    @Override\n                    public int compare(RouteMeta r1, RouteMeta r2) {\n                        try {\n                            return r1.getPath().compareTo(r2.getPath());\n                        } catch (NullPointerException npe) {\n                            logger.error(npe.getMessage());\n                            return 0;\n                        }\n                    }\n                });\n                routeMetaSet.add(routeMete);\n                groupMap.put(routeMete.getGroup(), routeMetaSet);\n            } else {\n                routeMetas.add(routeMete);\n            }\n        } else {\n            logger.warning(\">>> Route meta verify error, group is \" + routeMete.getGroup() + \" <<<\");\n        }\n    }\n\n//判断路由路径是否合法，并且设置groupname\n private boolean routeVerify(RouteMeta meta) {\n        String path = meta.getPath();\n        //如果路径为空，或者不是由'/'开头，返回false\n        if (StringUtils.isEmpty(path) || !path.startsWith(\"/\")) {   // The path must be start with '/' and not empty!\n            return false;\n        }\n\n         //如果在@Route注解中没有设置group标识，那么就默认取path路径第一段路径名作为groupname\n        if (StringUtils.isEmpty(meta.getGroup())) { // Use default group(the first word in path)\n            try {\n                String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n                if (StringUtils.isEmpty(defaultGroup)) {\n                    return false;\n                }\n\n                meta.setGroup(defaultGroup);\n                return true;\n            } catch (Exception e) {\n                logger.error(\"Failed to extract default group! \" + e.getMessage());\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n```\n\n通过分析，如果@Route注解中有设置group标识，作为groupname，如果没有就取/xxx1/xxx2，xxx1作为groupname，并将同一组的路由节点放到同一个集合中去。\n\n至此关于`@Route`注解在编译期时生成ARouter$$Root$$xxx，Router$$Providers$$xxx，ARouter$$Group$$xxx三种映射文件的源码分析完毕。\n\n###### 2.ARouter初始化过程\n\nARouter经过代码编译后，生成了相应的映射文件，我们可以断定，ARouter 的初始化会将这些文件加载到内存中去，形成一个路由表，以供后面路由查找跳转之用。其相关源码可参见 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)\n\n*   `ARouter`的`init()`方法\n\n```\npublic static void init(Application application) {\n        if (!hasInit) {\n            logger = _ARouter.logger;\n            _ARouter.logger.info(Consts.TAG, \"ARouter init start.\");\n            hasInit = _ARouter.init(application);\n\n            if (hasInit) {\n                _ARouter.afterInit();\n            }\n\n            _ARouter.logger.info(Consts.TAG, \"ARouter init over.\");\n        }\n    }\n\n```\n\n由上面代码可以看出，其初始化实际上是调用了`_ARouter` 的 `init ()`方法，而且其他的跳转方法最终调用的也是`_ARouter` 种的方法。\n\n*   `_ARouter`的`init()`方法\n\n```\n  protected static synchronized boolean init(Application application) {\n        mContext = application;\n        LogisticsCenter.init(mContext, executor);\n        logger.info(Consts.TAG, \"ARouter init success!\");\n        hasInit = true;\n\n        return true;\n    }\n\n```\n\n`_ARouter`中又调用了`LogisticsCenter.init()`，继续追踪下去，其中传入了一个线程池`executor`，这个线程池在拦截器的时候会使用到。\n\n```\n    public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {\n        mContext = context;\n        executor = tpe;\n\n        try {\n             //ROUTE_ROOT_PAKCAGE = \"com.alibaba.android.arouter.routes\"\n            // 获取ROUTE_ROOT_PAKCAGE 包里面的所有文件\n            List<String> classFileNames = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);\n\n            //遍历所有ROUTE_ROOT_PAKCAGE 包里的文件\n            for (String className : classFileNames) {\n                //文件名以“com.alibaba.android.arouter.routes.ARouter$$Root”开头执行下面代码\n                if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {\n                    // 通过反射实例化，并且调用loadInto()，目的即是将编译生成的ARouter$$Group$$xxx文件加载到内存中，保存在Warehouse.groupsIndex；\n                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {\n                    //文件名以“com.alibaba.android.arouter.routes.ARouter$$Interceptors”开头执行下面代码\n                    //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()，将自定义拦截器类存放在Warehouse.interceptorsIndex中\n                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);\n                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {\n                     //文件名以“com.alibaba.android.arouter.routes.ARouter$$Providers”开头执行下面代码\n                   //  执行编译生成的ARouter$$Interceptors$$xxx的loadInto()\n                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);\n                }\n            }\n\n            if (Warehouse.groupsIndex.size() == 0) {\n                logger.error(TAG, \"No mapping files were found, check your configuration please!\");\n            }\n\n            if (ARouter.debuggable()) {\n                logger.debug(TAG, String.format(Locale.getDefault(), \"LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]\", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));\n            }\n        } catch (Exception e) {\n            throw new HandlerException(TAG + \"ARouter init logistics center exception! [\" + e.getMessage() + \"]\");\n        }\n    }\n\n```\n\n*   `_ARouter`的`afterInit()`方法\n\n```\nstatic void afterInit() {\n        // 通过路由机制，初始化路由拦截机制。关于路由拦截机制的使用和原理，后续文章会有分析\n        interceptorService = (InterceptorService) ARouter.getInstance().build(\"/arouter/service/interceptor\").navigation();\n    }\n\n```\n\n以上就是ARouter初始化的所有代码，关于如何查找到`com.alibaba.android.arouter.routes`包内所有文件这里便不做过多分析，大家可以去阅读 [arouter-api](https://link.jianshu.com?t=https://github.com/alibaba/ARouter/tree/master/arouter-api)中`ClassUtils`这个类的源码。\n**总结下来，其实ARouter 的初始化只做了一件事，找到自己编译期产生的清单文件，把 Group 、Interceptor 、Provider 三种清单加载到 Warehouse 内存仓库中。**即下面这些文件，来源自AROUTER源码中的样例\n\n![](//upload-images.jianshu.io/upload_images/5994347-c375d8bc320ad241.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/518)\n\n值得注意的是，在初始化阶段，ARouter 仅载入了 Group 清单，并没有具体载入每个 Group 中包含的具体的路由节点清单，只有当使用到具体的 Group 时，才会加载对应的 Group 列表。这种分组管理，按需加载，大大的降低了初始化时的内存压力。并且`Warehouse`类中保存了路由清单，并且将使用过的路由对象缓存起来，之后查找都是直接使用缓存的对象 。\n\n###### 3.ARouter调用过程分析\n\n页面跳转最基本方法\n\n> ARouter.getInstance().build(\"/test/activity2\").navigation();\n\n获取Provider服务（实现了IProvider接口以及IProvider子类接口的服务类）的方法有两种：\n\n> 1.byName方式\n> ARouter.getInstance().build(\"/service/hello\").navigation()\n\n> 2.byType方式\n> ARouter.getInstance().navigation(HelloService.class)\n\nARouter路由跳转采用链式调用，`ARouter.getInstance()`其中采用的单例模式，获取ARouter的实例，这个就不作过多分析，主要分析`build()`和`navigation()`。\n\n**build()方法**\nARouter的`build(String path)`和`init()`方法一样，调用的是`_ARouter`的`build(String path)`方法。\n\n```\n  protected Postcard build(String path) {\n        if (TextUtils.isEmpty(path)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return build(path, extractGroup(path));\n        }\n    }\n\n```\n\n其中`extractGroup(String path)`就是根据path获取分组名，即path第一段“/”符号之间的值\n\n```\n  private String extractGroup(String path) {\n        if (TextUtils.isEmpty(path) || !path.startsWith(\"/\")) {\n            throw new HandlerException(Consts.TAG + \"Extract the default group failed, the path must be start with '/' and contain more than 2 '/'!\");\n        }\n\n        try {\n            //    /xxx1/xxx2   ===>  defaulGroup = xxx1\n            String defaultGroup = path.substring(1, path.indexOf(\"/\", 1));\n            if (TextUtils.isEmpty(defaultGroup)) {\n                throw new HandlerException(Consts.TAG + \"Extract the default group failed! There's nothing between 2 '/'!\");\n            } else {\n                return defaultGroup;\n            }\n        } catch (Exception e) {\n            logger.warning(Consts.TAG, \"Failed to extract default group! \" + e.getMessage());\n            return null;\n        }\n    }\n\n```\n\n`build(String path)`方法最终调用的是`build(String path, String group)`\n\n```\n    protected Postcard build(String path, String group) {\n        if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {\n            throw new HandlerException(Consts.TAG + \"Parameter is invalid!\");\n        } else {\n            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);\n            if (null != pService) {\n                path = pService.forString(path);\n            }\n            return new Postcard(path, group);\n        }\n    }\n\n```\n\n**值得注意的是其中`ARouter.getInstance().navigation(PathReplaceService.class)`就是得到实现`PathReplaceService`接口的一个服务对象，对原始path进行处理后，生成新的path路径。而这个类需要我们自己自定义去实现，如果没有实现，pService=null，原始path不做任何处理。**\n下面是`PathReplaceService`接口，我们可以通过实现`forString()`和`forUri()`方法，对某些url进行替换处理，跳转到其他的目标页面。\n\n```\npublic interface PathReplaceService extends IProvider {\n\n    /**\n     * For normal path.\n     *\n     * @param path raw path\n     */\n    String forString(String path);\n\n    /**\n     * For uri type.\n     *\n     * @param uri raw uri\n     */\n    Uri forUri(Uri uri);\n}\n\n```\n\n最后返回一个`Postcard`实例对象，里面封装了路由节点的路径，分组等节点信息。其实`build()`方法的目的只有一个就是根据路由，封装成`Postcard`对象，其对象贯穿之后整个路由过程。Postcard 包含了众多的属性值，提供了路由过程中所有的控制变量。\n\n```\npublic final class Postcard extends RouteMeta {\n    private Uri uri;\n    private Object tag;             // A tag prepare for some thing wrong.\n    private Bundle mBundle;         // 传递的参数\n    private int flags = -1;         // intent 的flag标志\n    private int timeout = 300;      // Navigation timeout, TimeUnit.Second !\n    private IProvider provider;     // IProvider服务对象\n    private boolean greenChannal;\n    private SerializationService serializationService;//序列化服务对象\n\n     // 跳转动画\n    private Bundle optionsCompat;    // The transition animation of activity\n    private int enterAnim;\n    private int exitAnim;\n\n    // copy from RouteMeta \n    private RouteType type;         // 路由节点类型\n    private Element rawType;        \n    private Class<?> destination;  //需要跳转到的页面\n    private String path;            // 路径\n    private String group;           // 分组\n    private int priority = -1;      // 优先级\n    private int extra;              // 配置标识\n    private Map<String, Integer> paramsType;  // 路由页面被@Autowired注解属性\n    // ......\n}\n\n```\n\n**navigation()方法**\n关于页面跳转的`navigation()`方法有多个重载的方法，但最终都会调用`_ARouter`下面这个方法\n\n```\n    protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        try {\n            //首先对postcard进行一些处理，设置postcard的destination，type，priority 等一些属性值，completion()后面会有分析\n            LogisticsCenter.completion(postcard);\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n\n            if (debuggable()) { // Show friendly tips for user.\n                Toast.makeText(mContext, \"There's no route matched!\\n\" +\n                        \" Path = [\" + postcard.getPath() + \"]\\n\" +\n                        \" Group = [\" + postcard.getGroup() + \"]\", Toast.LENGTH_LONG).show();\n            }\n            // 如果处理postcard失败，通过 callback 回调失败结果\n           // callback为空的情况下，如果有定义全局的降级处理（DegradeService），则使用全局处理\n           //降级处理也需要我们自己实现DegradeService接口\n            if (null != callback) {\n                callback.onLost(postcard);\n            } else {    // No callback for this invoke, then we use the global degrade service.\n                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);\n                if (null != degradeService) {\n                    degradeService.onLost(context, postcard);\n                }\n            }\n\n            return null;\n        }\n         //路由处理成功，回调callback.onFound()\n        if (null != callback) {\n            callback.onFound(postcard);\n        }\n\n        //目前来说，PROVIDER服务类型，以及FRAGMENT类型不需要通过拦截器外，其他类型均需要通过拦截器\n        //关于拦截器相关用法及原理分析在后续的文章中会讲解到，大家去可以关注下\n        if (!postcard.isGreenChannel()) {   \n            interceptorService.doInterceptions(postcard, new InterceptorCallback() {\n                /**\n                 * Continue process\n                 *\n                 * @param postcard route meta\n                 */\n                @Override\n                public void onContinue(Postcard postcard) {\n                    _navigation(context, postcard, requestCode, callback);\n                }\n\n                /**\n                 * Interrupt process, pipeline will be destory when this method called.\n                 *\n                 * @param exception Reson of interrupt.\n                 */\n                @Override\n                public void onInterrupt(Throwable exception) {\n                    if (null != callback) {\n                        callback.onInterrupt(postcard);\n                    }\n\n                    logger.info(Consts.TAG, \"Navigation failed, termination by interceptor : \" + exception.getMessage());\n                }\n            });\n        } else {\n            return _navigation(context, postcard, requestCode, callback);\n        }\n\n        return null;\n    }\n\n```\n\n**值得注意的是，当跳转路由处理失败的时候，会获取一个降级服务，我们可以实现`DegradeService`接口，实现`onLost()`方法，对路由处理失败的情况进行处理，比如跳转到一个信息提示页面，让用户去更新版本等操作等。** 下面是`DegradeService`接口：\n\n```\npublic interface DegradeService extends IProvider {\n\n    /**\n     * Router has lost.\n     *\n     * @param postcard meta\n     */\n    void onLost(Context context, Postcard postcard);\n}\n\n```\n\n通过上面代码的分析，不管是否通过拦截器进行处理，最后都会调用`_navigation()`达到路由的目的：\n\n```\nprivate Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {\n        final Context currentContext = null == context ? mContext : context;\n\n        switch (postcard.getType()) {\n            case ACTIVITY:\n                //下面就是最基本的使用intent进行activity进行跳转\n                // 创建intent\n                final Intent intent = new Intent(currentContext, postcard.getDestination());\n                //设置传参\n                intent.putExtras(postcard.getExtras());\n\n                //activity启动标志\n                int flags = postcard.getFlags();\n                if (-1 != flags) {\n                    intent.setFlags(flags);\n                } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.\n                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n                }\n\n                // 在主线程中进行跳转\n                new Handler(Looper.getMainLooper()).post(new Runnable() {\n                    @Override\n                    public void run() {\n                        //新版本带转场动画的启动方式\n                        if (requestCode > 0) {  // Need start for result\n                            ActivityCompat.startActivityForResult((Activity) currentContext, intent, requestCode, postcard.getOptionsBundle());\n                        } else {\n                            ActivityCompat.startActivity(currentContext, intent, postcard.getOptionsBundle());\n                        }\n\n                        if ((0 != postcard.getEnterAnim() || 0 != postcard.getExitAnim()) && currentContext instanceof Activity) {    // Old version.\n                            //老版本的跳转动画\n                            ((Activity) currentContext).overridePendingTransition(postcard.getEnterAnim(), postcard.getExitAnim());\n                        }\n                        //跳转成功，回调callback.onArrival()\n                        if (null != callback) { // Navigation over.\n                            callback.onArrival(postcard);\n                        }\n                    }\n                });\n\n                break;\n            case PROVIDER:\n                return postcard.getProvider();\n            case BOARDCAST:\n            case CONTENT_PROVIDER:\n            case FRAGMENT:\n                Class fragmentMeta = postcard.getDestination();\n                try {\n                     //实例化fragment，并传递参数\n                    Object instance = fragmentMeta.getConstructor().newInstance();\n                    if (instance instanceof Fragment) {\n                        ((Fragment) instance).setArguments(postcard.getExtras());\n                    } else if (instance instanceof android.support.v4.app.Fragment) {\n                        ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());\n                    }\n\n                    return instance;\n                } catch (Exception ex) {\n                    logger.error(Consts.TAG, \"Fetch fragment instance error, \" + TextUtils.formatStackTrace(ex.getStackTrace()));\n                }\n            case METHOD:\n            case SERVICE:\n            default:\n                return null;\n        }\n\n        return null;\n    }\n\n```\n\n目前仅ARouter实现了 ACTIVITY ， PROVIDER ，FRAGMENT三种种类型。上面关于postcard的provider，destination的值都是在`completion()`中设置的。我们接着看`LogisticsCenter`的`completion(Postcard postcard)`。\n\n```\n    public synchronized static void completion(Postcard postcard) {\n        if (null == postcard) {\n            throw new NoRouteFoundException(TAG + \"No postcard!\");\n        }\n\n        // 查找Warehouse仓库的路由节点缓存，看是否已在缓存中\n        RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());\n        if (null == routeMeta) {   \n          // 如果没有，查找仓库的组别清单中是否存在该组别，组别清单已经在初始化的时候加载到仓库中去了\n            Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  \n            //如果没有抛出异常\n            if (null == groupMeta) {\n                throw new NoRouteFoundException(TAG + \"There is no route match the path [\" + postcard.getPath() + \"], in group [\" + postcard.getGroup() + \"]\");\n            } else {\n                // Load route and cache it into memory, then delete from metas.\n                try {\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] starts loading, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                    // 实例化个组别的类，调用loadInto()，将组别中所有的路由节点加载进仓库Warehouse.routes，缓存\n                    IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();\n                    iGroupInstance.loadInto(Warehouse.routes);\n                     // 从组别清单中删除已加载的组别，防止重复加载\n                    Warehouse.groupsIndex.remove(postcard.getGroup());\n\n                    if (ARouter.debuggable()) {\n                        logger.debug(TAG, String.format(Locale.getDefault(), \"The group [%s] has already been loaded, trigger by [%s]\", postcard.getGroup(), postcard.getPath()));\n                    }\n                } catch (Exception e) {\n                    throw new HandlerException(TAG + \"Fatal exception when loading group meta. [\" + e.getMessage() + \"]\");\n                }\n                //当路由节点加载到缓存中去后，重新查找执行else代码，对postcard进行处理\n                completion(postcard);   // Reload\n            }\n        } else {\n            //给postcard设置destination,type,priority等值，供上面讲解到的_navigation()进行使用\n            // 其中routeMeta是在ARouter$$Group$$xxx的loadInto中创建的\n            postcard.setDestination(routeMeta.getDestination());\n            postcard.setType(routeMeta.getType());\n            postcard.setPriority(routeMeta.getPriority());\n            postcard.setExtra(routeMeta.getExtra());\n\n            //如果通过build(Uri url) 进行跳转的话 通过解析url ，将传参保存进bundle中\n            Uri rawUri = postcard.getUri();\n            if (null != rawUri) {  \n                //splitQueryParameters()就是在uri中携带的参数进行解析\n                Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);\n                Map<String, Integer> paramsType = routeMeta.getParamsType();\n\n                if (MapUtils.isNotEmpty(paramsType)) {\n                    // Set value by its type, just for params which annotation by @Param\n                    for (Map.Entry<String, Integer> params : paramsType.entrySet()) {\n                        setValue(postcard,\n                                params.getValue(),\n                                params.getKey(),\n                                resultMap.get(params.getKey()));\n                    }\n\n                    // Save params name which need autoinject.\n                    postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));\n                }\n\n                // Save raw uri\n                postcard.withString(ARouter.RAW_URI, rawUri.toString());\n            }\n\n            //从这里也可以看出PROVIDER，FRAGMENT不需要通过拦截器\n            switch (routeMeta.getType()) {\n                case PROVIDER:  \n                    // 如果是PROVIDER节点类型，从服务节点列表中获取，如果没有，则实例化，并保存在服务节点列表Warehouse.providers中\n                  //并将实例化的对象设置给postcard的provider属性\n                    Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();\n                    IProvider instance = Warehouse.providers.get(providerMeta);\n                    if (null == instance) { // There's no instance of this provider\n                        IProvider provider;\n                        try {\n                            provider = providerMeta.getConstructor().newInstance();\n                            provider.init(mContext);\n                            Warehouse.providers.put(providerMeta, provider);\n                            instance = provider;\n                        } catch (Exception e) {\n                            throw new HandlerException(\"Init provider failed! \" + e.getMessage());\n                        }\n                    }\n                    postcard.setProvider(instance);\n                    postcard.greenChannel();    // Provider should skip all of interceptors\n                    break;\n                case FRAGMENT:\n                    postcard.greenChannel();    // Fragment needn't interceptors\n                default:\n                    break;\n            }\n        }\n    }\n\n```\n\n分析到这里，关于页面基本跳转的原理分析就已经结束了。最后就是关于获取Provider服务两种方法的源码分析。其中byName方式，和页面跳转是一模一样的。我们只需要看看byType方式即可。byType方式最后调用的是`_ARouter`的`navigation(Class<? extends T> service)`\n\n```\n  protected <T> T navigation(Class<? extends T> service) {\n        try {\n            // 通过 className 获取 Postcard 对象\n            Postcard postcard = LogisticsCenter.buildProvider(service.getName());\n\n            // 兼容1.0.5 compiler sdk版本.\n            if (null == postcard) { // No service, or this service in old version.\n                postcard = LogisticsCenter.buildProvider(service.getSimpleName());\n            }\n           // 对 Postcard 对象进行处理\n            LogisticsCenter.completion(postcard);\n             //返回 Postcard 中的 provider 属性值\n            return (T) postcard.getProvider();\n        } catch (NoRouteFoundException ex) {\n            logger.warning(Consts.TAG, ex.getMessage());\n            return null;\n        }\n    }\n\n```\n\n上面代码中的`completion()`方法之前已经分析过了，只需要看下`LogisticsCenter.buildProvider(service.getName())`即可。\n\n```\n  public static Postcard buildProvider(String serviceName) {\n        RouteMeta meta = Warehouse.providersIndex.get(serviceName);\n\n        if (null == meta) {\n            return null;\n        } else {\n            return new Postcard(meta.getPath(), meta.getGroup());\n        }\n    }\n\n```\n\n这个方法非常的简单，就是根据服务类名去仓库Warehouse.providersIndex中获去路由节点元素，然后封装在Postcard对象中。服务类清单列表Warehouse.providersIndex中的值是在初始化时缓存的。**值得注意的是，PROVIDER 类型的路由节点既存在于对应的分组中，也存在于服务类清单列表中。所以，ARouter 可通过byType，byName两种方式来获取**。\n\n##### 补充\n\n关于ARouter的基本用法上面只有最基本跳转的介绍，下面对其他一些基本使用进行下补充\n\n*   **带参数跳转**\n\n```\n//1.传递参数\n ARouter.getInstance().build(\"/test/activity1\")\n                        .withString(\"name\", \"老王\")\n                        .withInt(\"age\", 18)\n                        .withBoolean(\"boy\", true)\n                        .withLong(\"high\", 180)\n                        .withString(\"url\", \"https://a.b.c\")\n                        .withParcelable(\"pac\", testParcelable)\n                        .withObject(\"obj\", testObj)\n                        .navigation();\n\n//2.直接传递Bundle\n  Bundle params = new Bundle();\n  ARouter.getInstance()\n          .build(\"/test/activity1\")\n          .with(params)\n          .navigation();\n\n```\n\n这些传参都是保存在生成的`postcard`对象中的`mBundle`属性里，然后在跳转的时候通过`intent.putExtras(postcard.getExtras())`达到传送参数的目的。\n值得注意的是，关于对象的传递有两种，一种是`withParcelable()`方法，不过此方法需要传递的对象实现`Parcelable`接口，达到序列化的目的；另外一种是`withObject()`方法，此方法的原理是将实体类转换成json字符串，通过String的方式进行传递，而且使用这种方式需要实现 SerializationService，并使用@Route注解标注，下面是ARouter样例：\n\n```\n@Route(path = \"/service/json\")\npublic class JsonServiceImpl implements SerializationService {\n    @Override\n    public void init(Context context) {\n\n    }\n\n    @Override\n    public <T> T json2Object(String text, Class<T> clazz) {\n        return JSON.parseObject(text, clazz);\n    }\n\n    @Override\n    public String object2Json(Object instance) {\n        return JSON.toJSONString(instance);\n    }\n}\n\n```\n\n而且，需要在跳转到的页面获取`JsonServiceImpl`服务，将json字符串转换成对象。\n\n```\nSerializationService serializationService = ARouter.getInstance().navigation(SerializationService.class);\nTestObj obj = serializationService.json2Object(getIntent().getString(\"obj\"), TestObj.class);\n\n```\n\n*   **带返回结果跳转**\n\n```\nARouter.getInstance().build(\"/test/activity2\").navigation(this, 666);\n\n```\n\n值得注意的是，这时候的 `navigation`需要传递activit和requestCode。\n\n*   **获取Fragment的实例**\n\n定义一个fragment\n\n```\n@Route(path = \"/test/fragment\")\npublic class BlankFragment extends Fragment {\n    public BlankFragment() {\n        //必须要一个空的构造器\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        TextView textView = new TextView(getActivity());\n        return textView;\n    }\n\n}\n\n```\n\n获取frament\n\n```\nFragment fragment = (Fragment) ARouter.getInstance().build(\"/test/fragment\").navigation();\n\n```\n\n*   **带转场动画跳转**\n\n```\n// 转场动画(常规方式)\n ARouter.getInstance() .build(\"/test/activity2\")\n                      .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom)\n                      .navigation(this);\n\n// 转场动画(API16+)\n ActivityOptionsCompat compat = ActivityOptionsCompat.makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);\nARouter.getInstance().build(\"/test/activity2\").withOptionsCompat(compat) .navigation();\n\n```\n\n*   **获取服务**\n\n服务是全局单例的，只有在第一次使用到的时候才会被初始化。\n暴露服务，必须实现IProvider 接口 或者其子类型\n\n```\n// 声明接口,其他组件通过接口来调用服务\npublic interface HelloService extends IProvider {\n    String sayHello(String name);\n}\n\n// 实现接口\n@Route(path = \"/service/hello\", name = \"测试服务\")\npublic class HelloServiceImpl implements HelloService {\n\n    @Override\n    public String sayHello(String name) {\n    return \"hello, \" + name;\n    }\n\n    @Override\n    public void init(Context context) {\n\n    }\n}\n\n```\n\n获取服务\n\n```\n//bytype\nHelloService helloService1 = ARouter.getInstance().navigation(HelloService.class);\n//byname\nHelloService helloService2 = (HelloService) ARouter.getInstance().build(\"/service/hello\").navigation();\n\n```\n\n*   **多模块结构**\n\n![](//upload-images.jianshu.io/upload_images/5994347-767a114aa4746c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\napp中可能存在多个模块，每个模块下面都有一个root结点，每个root结点都会管理整个模块中的group节点，每个group结点则包含了该分组下的所有页面，而每个模块允许存在多个分组，每个模块中都会有一个拦截器节点就是Interceptor结点，除此之外每个模块还会有控制拦截反转的provider结点\n\n##### 最后\n\n到此，关于ARouter的基本用法以及原理分析的就全部结束了，如果有不清楚或者错误的地方，希望各位同学指出。关于ARouter拦截器，各种服务，依赖注入等更多进阶用法及源码分析会更新在后续的文章。\n\n作者：time_fly\n链接：https://www.jianshu.com/p/46d174f37e82\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[0,0],[52174,52174]]],[1519699717055,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,4166,"https:"],[-1,4287,""],[1,19658,"https:"],[1,30747,"https:"],[-1,51690,""],[1,51694,"https:"]],[4162,4174],[4162,4162]]]]]]}