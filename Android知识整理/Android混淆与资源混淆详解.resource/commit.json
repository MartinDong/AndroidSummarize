{"compress":true,"commitItems":[["3f95719e-aa1d-42bf-a808-4ea5c6cce12a",1519553387634,"",[[1519553377587,["Kotlin@DESKTOP-C3FKI4V",[[1,0,"Android混淆与资源混淆详解\n===\n\n\n"]],[0,0],[23,23]]],[1519553386726,["Kotlin@DESKTOP-C3FKI4V",[[-1,1,"ndroid混淆与资源混淆详解\n===\n\n\n"],[1,23,"PK的混淆分为资源混淆与代码混淆.一般大部分都使用两者结合.尤其是目前主流的应用.\n\n#### 其中的优点:\n\n*   **防止被恶意破解逆向分析**\n*   **减少apk体积,也是瘦身的方法**\n*   **代码可阅读性降低**\n\n#### 其中的缺点:\n\n*   **调试不方便(可以配置mapping变得方便)**\n*   **测试不充分,可能导致部分功能不能使用(比如注解相关等)**\n\n#### 混淆前(这儿偷个懒直接用工具反编译看):\n\n![这里写图片描述](http://img.blog.csdn.net/20160920105928451)\n\n#### 混淆后:\n\n![这里写图片描述](http://img.blog.csdn.net/20160920110700837)\n\n## 如何使用代码混淆:\n\n1.直接在build.gradle文件中配置即可.如图: \n![这里写图片描述](http://img.blog.csdn.net/20160920103345493) \n图片有了,文件也找到了,接下来了呢?"]],[0,23],[468,468]]],[1519553395196,["Kotlin@DESKTOP-C3FKI4V",[[-1,392," "],[1,393," "],[-1,448," "],[1,449," "],[1,468,"\n\nbuildTypes { debug { // 如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt） pseudoLocalesEnabled true  // 显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"  //混淆 minifyEnabled false  //Zipalign优化 zipAlignEnabled true  // 移除无用的resource文件 shrinkResources true  //加载默认混淆配置文件 proguardFiles getDefaultProguardFile('proguard-Android.txt'), 'proguard-rules.pro'  //签名 signingConfig signingConfigs.debug } release { // 如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt） pseudoLocalesEnabled true  // 不显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"  //混淆 minifyEnabled true  //Zipalign优化 zipAlignEnabled true  // 移除无用的resource文件 shrinkResources true  //加载默认混淆配置文件 proguardFiles getDefaultProguardFile('proguard-Android.txt'), 'proguard-rules.pro'  //签名 signingConfig signingConfigs.relealse } }"]],[468,468],[1297,1297]]],[1519553396595,["Kotlin@DESKTOP-C3FKI4V",[[-1,469,"buildTypes { debug { // 如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt） pseudoLocalesEnabled true  // 显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"  //混淆 minifyEnabled false  //Zipalign优化 zipAlignEnabled true  // 移除无用的resource文件 shrinkResources true  //加载默认混淆配置文件 proguardFiles getDefaultProguardFile('proguard-Android.txt'), 'proguard-rules.pro'  //签名 signingConfig signingConfigs.debug } release { // 如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt） pseudoLocalesEnabled true  // 不显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"  //混淆 minifyEnabled true  //Zipalign优化 zipAlignEnabled true  // 移除无用的resource文件 shrinkResources true  //加载默认混淆配置文件 proguardFiles getDefaultProguardFile('proguard-Android.txt'), 'proguard-rules.pro'  //签名 signingConfig signingConfigs.relealse } }"]],[1297,1297],[469,469]]],[1519553404256,["Kotlin@DESKTOP-C3FKI4V",[[1,470,"```java\nbuildTypes {\n        debug {\n            // 如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt）\n            pseudoLocalesEnabled true\n            // 显示Log\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\"\n            //混淆\n            minifyEnabled false\n            //Zipalign优化\n            zipAlignEnabled true\n            // 移除无用的resource文件\n            shrinkResources true\n            //加载默认混淆配置文件\n            proguardFiles getDefaultProguardFile('proguard-Android.txt'), 'proguard-rules.pro'\n            //签名\n            signingConfig signingConfigs.debug\n        }\n        release {\n            // 如果没有提供混淆规则文件，则设置默认的混淆规则文件（SDK/tools/proguard/proguard-android.txt）\n            pseudoLocalesEnabled true\n            // 不显示Log\n            buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\"\n            //混淆\n            minifyEnabled true\n            //Zipalign优化\n            zipAlignEnabled true\n            // 移除无用的resource文件\n            shrinkResources true\n            //加载默认混淆配置文件\n            proguardFiles getDefaultProguardFile('proguard-Android.txt'), 'proguard-rules.pro'\n            //签名\n            signingConfig signingConfigs.relealse\n        }\n    }12345678910111213141516171819202122232425262728293031323334\n```\n\n经过这样的配置过后呢,可以发现gradle是加载了一个混淆的配置文件(proguard-Android.txt,这个文件的位置和build.gradle同级),根据混淆配置文件的规则进行混淆的.为什么要混淆配置呢?因为有些东西是不能混淆的,比如jni调用,本身就是根据包名去调用的,如果混淆了就会NotFoundMethod了.所以这个规则就是自定义的了.\n\n"]],[450,468],[1909,1909]]],[1519553417514,["Kotlin@DESKTOP-C3FKI4V",[[1,1911,"\n"]],[1909,1909],[1910,1910]]],[1519553417656,["Kotlin@DESKTOP-C3FKI4V",[[1,1912,"\n"]],[1910,1910],[1911,1911]]],[1519553417941,["Kotlin@DESKTOP-C3FKI4V",[[1,1911,"## 如何自定义:\n\n```java\n-libraryjars class_path //应用的依赖包，如Android-support-v4  \n-keep [,modifier,...] class_specification //这里的keep就是保持的意思，意味着不混淆某些类 \n-keepclassmembers [,modifier,...] class_specification //同样的保持，不混淆类的成员  \n-keepclasseswithmembers [,modifier,...] class_specification //不混淆类及其成员  \n-keepnames class_specification //不混淆类及其成员名  \n-keepclassmembernames class_specification //不混淆类的成员名  \n-keepclasseswithmembernames class_specification //不混淆类及其成员名  \n-assumenosideeffects class_specification //假设调用不产生任何影响，在proguard代码优化时会将该调用remove掉。如system.out.println和Log.v等等  \n-dontwarn [class_filter] //不提示warnning 123456789\n```\n\n接下来看了语法可能有点蒙了,这些只是了解就可以了,一般有通用的.\n\n#### 比如:\n\n```ruby\n# Add project specific ProGuard rules here.\n# By default, the flags in this file are appended to flags specified\n# in D:\\Android\\sdk/tools/proguard/proguard-android.txt\n# You can edit the include path and order by changing the proguardFiles\n# directive in build.gradle.\n#\n# For more details, see\n#   http://developer.android.com/guide/developing/tools/proguard.html\n\n# Add any project specific keep options here:\n\n# If your project uses WebView with JS, uncomment the following\n# and specify the fully qualified class name to the JavaScript interface\n# class:\n#-keepclassmembers class fqcn.of.javascript.interface.for.webview {\n#   public *;\n#}\n-optimizationpasses 5\n-dontusemixedcaseclassnames\n-dontskipnonpubliclibraryclasses\n-dontpreverify\n-verbose\n-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*\n\n# 系统类不需要混淆\n-keepattributes *Annotation*\n-keep class * extends java.lang.annotation.Annotation { *; }\n-keepattributes Signature\n-keep public class * extends android.app.Fragment\n-keep public class * extends android.app.Activity\n-keep public class * extends android.app.Application\n-keep public class * extends android.app.Service\n-keep public class * extends android.content.BroadcastReceiver\n-keep public class * extends android.content.ContentProvider\n-keep public class * extends android.app.backup.BackupAgentHelper\n-keep public class * extends android.preference.Preference\n-keep public class * extends android.support.v4.**\n-keep public class * extends android.support.v7.**\n-dontwarn com.alipay.android.phone.mrpc.core**\n-keep class com.alipay.android.phone.mrpc.core.**{*;}\n\n-dontwarn com.alipay.apmobilesecuritysdk.face**\n-keep class com.alipay.apmobilesecuritysdk.face.**{*;}\n\n#  百度导航的不需要混淆\n#-dontwarn com.baidu.navisdk.comapi.tts.ttsplayer**\n#-keep class com.baidu.navisdk.**{*;}\n\n#  Jpush不需要混淆\n-dontwarn cn.jpush**\n-keep class cn.jpush.** { *; }#Jpush\n\n# XUtils工具不需要混淆\n-dontwarn com.lidroid**\n-keep class com.lidroid.**{*;}#ViewInject\n\n# 自定义控件不需要混淆\n-keep class com.cheweishi.android.widget.** {*;}#CustomView\n\n-dontwarn com.sinovoice**\n-keep class com.sinovoice.** { *; }\n\n# 百度地图相关不需要混淆\n-dontwarn com.baidu**\n-keep class com.baidu.** { *; }\n-keep class vi.com.gdi.bgl.android.**{*;}\n\n#-dontwarn demo.Pinyin4jAppletDemo**\n#-keep class demo.Pinyin4jAppletDemo{*;}\n\n# volley工具不需要混淆\n-dontwarn com.android.volley.toolbox**\n-keep class com.android.volley.toolbox{*;}\n\n# gson工具不需要混淆\n-dontwarn com.google.gson**\n-keep class com.google.gson.**{*;}\n\n#-dontwarn com.nineoldandroids.**\n#-keep class com.nineoldandroids.**{*;}\n\n-dontwarn org.apache.http**\n-keep class org.apache.http.**{*;}\n\n-dontwarn com.handmark.pulltorefresh**\n-keep class com.handmark.pulltorefresh.**{*;}\n\n-dontwarn com.squareup.picasso**\n-keep class com.squareup.picasso.**{*;}\n\n-dontwarn com.cheweishi.android.entity**\n-keep class com.cheweishi.android.entity.**{*;}\n\n-keep class com.cheweishi.android.response.BaseResponse\n\n-keep public class com.android.vending.licensing.ILicensingService\n\n-printmapping mapping.txt #混淆后文件映射\n\n#-keep public class com.cheweishi.android.R$*{\n#    public static final int *;\n#}\n\n-keepclasseswithmembernames class * {\n    native <methods>;\n}\n-keepclasseswithmembernames class * {\n    public <init>(android.content.Context, android.util.AttributeSet);\n}\n-keepclasseswithmembernames class * {\n    public <init>(android.content.Context, android.util.AttributeSet, int);\n}\n-keepclassmembers enum * {\n    public static **[] values();\n    public static ** valueOf(java.lang.String);\n}\n-keep class * implements android.os.Parcelable {\n  public static final android.os.Parcelable$Creator *;\n}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119\n```\n\n当你混淆后你会发现一些错误日志全是a.b.c.d()等,根本不知道具体错误在哪儿,这就是混淆后调试的确定,竟然提供了混淆肯定就可以还原啦,google早就考虑到了.那我要怎么还原呢?\n\n1.**cmd进入sdk/tools/proguard/bin目录。** \n2.**将混淆后的日志和上文提到的mapping文件放入此目录中。** \n3.**执行命令：retrace.bat mapping.txt XXX.txt**\n\n未还原前: \n![这里写图片描述](http://img.blog.csdn.net/20160920143328134) \n还原后: \n![这里写图片描述](http://img.blog.csdn.net/20160920143343291)\n\n这下有没有觉得比较好调试了,这下你比较关心如何线上的产品如何查看呢?一般(友盟)提供了mapping文件管理的,所以混淆规则的文件(proguard-Android.txt)的生成是非常有必要的.\n\n### 资源混淆:\n\n资源混淆是可以解决apk瘦身,主要就是压缩了资源文件及修改了文件名字及映射关系.看看效果吧.\n\n#### 资源混淆前:\n\n![这里写图片描述](http://img.blog.csdn.net/20160920113545580)\n\n#### 资源混淆后:\n\n![这里写图片描述](http://img.blog.csdn.net/20160920113602298)\n\n##### 关于资源混淆有很多种解决方案,首先我们可以看看最早美团提出来的([美团资源保护实战](http://tech.meituan.com/mt-android-resource-obfuscation.html),这里就不做具体的分析):\n\n*   **1.首先介绍了打包的过程,是通过appt对资源进行记录.**\n*   **2.了解原理后,可以通过修改源码在资源文件映射的时候修改文件名字及映射路径**\n*   **3.美团仅仅是提供了修改的思路,并未将混淆的函数公开**\n\n其实通过这样修改aapt,然后再Linux编译出来的aapt(可以编译分为Linux或者windows,以windows为例)替换置SDK目录下/build-tools/aapt.exe,然后使用对应版本编译即可.**当然这样的做法虽然可以实现,但是非常麻烦(依赖编译过程,依赖编译源码…),比如aapt升级等**\n\n再看看微信开源的git([AndResGuard](https://github.com/shwenzhang/AndResGuard)),大致原理将资源文件通过7zip进行压缩后重新映射然后打包成apk并对其签名. \n![这里写图片描述](http://img.blog.csdn.net/20160920141903385)\n\n对比: \n![这里写图片描述](http://img.blog.csdn.net/20160920142027948)\n\n如果你还需要对apk瘦身,你可以将编译前无用资源给删除.具体可使用gradle提供的Lint.\n\n#### 如何使用:\n\n![这里写图片描述](http://img.blog.csdn.net/20160920142251372) \n然后build后会在projectName\\app\\build\\outputs\\lint-results.xml,该Lint可以检测语法以及无用资源,然后写一个工具就可以删除了.这里也可以推荐大家使用:lintAutoCleaner,该工具选择对应的lint-results.xml文件就可以自动删除并备份了,非常人性化."]],[1911,1911],[7991,7991]]]]]]}