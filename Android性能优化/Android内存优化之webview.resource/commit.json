{"compress":true,"commitItems":[["de107cbf-d2ce-4413-b263-71cb43b1dffd",1519807738293,"",[[1519807727752,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,0,"Android内存优化之webview\n===\n\n\n"]],[0,0],[26,26]]],[1519807737505,["xiaoyulaoshi@DESKTOP-LAD9940",[[1,0,"> 提起android端的webview，它既是天使，又是魔鬼。\n\n_在混合型app中它是主角，一切由它呈现，如58同城，赶集网等；在另一些超级app中亦有它的影子，微信，qq，支付宝，没有一个超级app能少了它，既能展示最新最潮的实时资讯，又能扮演盘踞一方的全功能型网站，与native结合后又能扮演诸如公众号之内的应用等等，其能力可想而知。_\n\nwebview在android端的演化可谓_曲折_，2015年google宣布不在支持4.4版本一下的webview[[1]](#fn1)，这意味着目前扔有近四分之一的"],[1,7,"用户因无法获得Google的支持而受到安全威胁。对于深度依赖webview的巨头开始自家的内核及上层sdk以求提升整体稳定性及其性能,腾讯x5内核是比较通用的一种.\n\n目前大致的webview"],[-1,9,"优化之"],[1,12,"处理方式分为两类:\n\n### 1.独立的web进程，与主进程隔开\n\n这个方法被运用于类似qq，微信这样的超级app中，这也是解决任何webview内存问题屡试不爽的方法\n对于封装的webactivity，在`manifest.xml`中设置\n\n```\n<activity android:name=\".webview.WebViewActivity\" android:launchMode=\"singleTop\" android:process=\":remote\" android:screenOrientation=\"unspecified\" />\n\n```\n\n然后在关闭webactivity时销毁进程\n\n```\n@Overrideprotected void onDestroy() {                \n     super.onDestroy(); \n     System.exit(0);\n}\n\n```\n\n关闭浏览器后便销毁整个进程，这样一般`95%`的情况下不会造成内存泄漏之类的问题，但这就涉及到[android进程间通讯](https://link.jianshu.com?t=http://blog.csdn.net/hitlion2008/article/details/9824009)，比较不方便处理， 优劣参半，也是可选的一个方案.\n\n### 2.封装过的webview\n\n相比系统内置的webview的支持自2005年之后就没有了，而首推google的chrome。 腾讯的x5"],[1,19,"对h5的兼容性与稳定性与安全性逐渐凸显出来，并自成一系, 下面以使用[x5webview](https://link.jianshu.com?t=http://x5.tencent.com/)为例做说明:"],[1,20,"\n*   首先使用webview的时候，不在xml里面声明，而是直接代码new个对象，传入application context防止activity引用滥用.\n\n```\nwebView "],[1,21,"  new BridgeWebView(getContext().getApplicationContext());\nwebFrameLayout.addView(webView, 0);\n\n```\n\n在使用了这个方式后，基本上90%的webview内存泄漏的问题便得以解决.\n\n*   而在android4.4版本以下，会出现android webview无法自动释放，如在`fragment`中,使用`ondetach`的释放webview是比较好的时机[[2]](#fn2)\n\n```\npublic void onDetach() {\n    releaseWebViews();\n    super.onDetach();\n}\npublic synchronized void releaseWebViews() {\n    if(webView !"],[1,22," null) {\n        try {\n            if(webView.getParent() !"],[1,23," null) {"],[1,24,"                ((ViewGroup) webView.getParent()).removeView(webView);\n            }\n//                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {\n//this is causing the segfault occasionally below 4.2\n            webView.destroy();\n    //                }\n        }catch (IllegalArgumentException e) {\n            DLog.p(e);\n        }\n        RefWatcher refWatcher = FApplication.getRefWatcher();\n        refWatcher.watch(webView);\n        webView = null;\n    }\n}\n\n```\n\n其中webview自身的销毁代码如下：\n\n```\n@Override\npublic void destroy()\n//flushMessageQueue();\n    clearCache(true);\n    clearFormData();\n    clearMatches();\n    clearSslPreferences();\n    clearDisappearingChildren();\n    clearHistory();\n    //@Deprecated\n    //clearView();\n    clearAnimation();\n    loadUrl(\"about:blank\");\n    removeAllViews();\n    freeMemory();\n    super.destroy();\n}\n\n```\n\n*   如果以上的方案还不管用，实时加入`反射`来清理webview的引用：\n\n```\npublic void setConfigCallback(WindowManager windowManager) {\n    try {\n        Field field = WebView.class.getDeclaredField(\"mWebViewCore\");\n        field = field.getType().getDeclaredField(\"mBrowserFrame\");\n        field = field.getType().getDeclaredField(\"sConfigCallback\");\n        field.setAccessible(true);\n        Object configCallback = field.get(null);\n        if (null == configCallback) {\n            return;\n        }\n        field = field.getType().getDeclaredField(\"mWindowManager\");\n        field.setAccessible(true);\n        field.set(configCallback, windowManager);\n    } catch(Exception e) {\n    }\n}\n\n```\n\n然后在activity中加入\n\n```\npublic void onCreate(BundlesavedInstanceState){\n    super.onCreate(savedInstanceState);\n    setConfigCallback((WindowManager);\n    getApplicationContext().getSystemService(Context.WINDOW_SERVICE));\n}\npublicvoidonDestroy()\n{\n    setConfigCallback(null);\n    super.onDestroy();\n}\n\n```\n\n*   对于application 级别的可能的misbehaving callbacks，加入\n\n```\nprivate static String[] misbehavingClasses = new String[]{\n    \"com.google.android.gms.ads\",\n    \"com.android.org.chromium.android_webview.AwContents$AwComponentCallbacks\",\n};\npublic static boolean isMisbehavingCallBacks(String name){\n    for(String s : misbehavingClasses){\n        if(name.startsWith(s)){\n            return true;\n        }\n    }\n    return false;\n}\n\n```\n\n然后重写applicaiton类记录这些callback, 并在适当的时机删掉：\n\n```\n@Override\npublic void registerComponentCallbacks(ComponentCallbacks callback) {\n    super.registerComponentCallbacks(callback);\n    ComponentCallbacksBehavioralAdjustmentToolIcs.INSTANCE.onComponentCallbacksRegistered(callback);\n}"],[1,26,"@Override\npublic void unregisterComponentCallbacks(ComponentCallbacks callback) {\n    ComponentCallbacksBehavioralAdjustmentToolIcs.INSTANCE.onComponentCallbacksUnregistered(callback);\n    super.unregisterComponentCallbacks(callback);\n}\n\npublic void forceUnregisterComponentCallbacks() {\n    ComponentCallbacksBehavioralAdjustmentToolIcs.INSTANCE.unregisterAll(this);\n}\n\nprivate static class ComponentCallbacksBehavioralAdjustmentToolIcs {\n    private static final String TAG = \"componentCallbacks\";\n    static ComponentCallbacksBehavioralAdjustmentToolIcs INSTANCE = new ComponentCallbacksBehavioralAdjustmentToolIcs();\n\n    private WeakHashMap<ComponentCallbacks, ApplicationErrorReport.CrashInfo> mCallbacks = new WeakHashMap<>();\n    private boolean mSuspended = false;\n\n    public void onComponentCallbacksRegistered(ComponentCallbacks callback) {\n        Throwable thr = new Throwable(\"Callback registered here.\");\n        ApplicationErrorReport.CrashInfo ci = new ApplicationErrorReport.CrashInfo(thr);\n\n        if (FApplication.DEBUG) DLog.w(TAG, \"registerComponentCallbacks: \" + callback.getClass().getName(), thr);\n\n        if (!mSuspended) {\n            if (BugFix.isMisbehavingCallBacks(callback.getClass().getName())) {\n                mCallbacks.put(callback, ci);\n            }\n            // TODO: other classes may still prove to be problematic?  For now, only watch for .gms.ads, since we know those are misbehaving\n        } else {\n            if (FApplication.DEBUG) DLog.e(TAG, \"ComponentCallbacks was registered while tracking is suspended!\");\n        }\n    }\n\n    public void onComponentCallbacksUnregistered(ComponentCallbacks callback) {\n        if (!mSuspended) {\n            if (FApplication.DEBUG) {\n                DLog.i(TAG, \"unregisterComponentCallbacks: \" + callback, new Throwable());\n            }\n\n            mCallbacks.remove(callback);\n        }\n    }\n\n    public void unregisterAll(Context context) {\n        mSuspended = true;\n        for (Map.Entry<ComponentCallbacks, ApplicationErrorReport.CrashInfo> entry : mCallbacks.entrySet()) {\n            ComponentCallbacks callback = entry.getKey();\n            if (callback == null) continue;\n\n            if (FApplication.DEBUG) {\n                DLog.w(TAG, \"Forcibly unregistering a misbehaving ComponentCallbacks: \" + entry.getKey());\n                DLog.w(TAG, entry.getValue().stackTrace);\n            }\n\n            try {\n                context.unregisterComponentCallbacks(entry.getKey());\n            } catch (Exception exc) {\n                if (FApplication.DEBUG) DLog.e(TAG, \"Unable to unregister ComponentCallbacks\", exc);\n            }\n        }\n\n        mCallbacks.clear();\n        mSuspended = false;\n    }\n}\n\n```\n\n##### 为方便webactivity的debug\n\n*   在`application`的`oncreate`里面，我们加入\n\n```\nprivate static void enableStrictMode() {\nStrictMode.ThreadPolicy.Builder threadPolicyBuilder =\n    new StrictMode.ThreadPolicy.Builder()\n    .detectAll()\n    .penaltyLog();\n    StrictMode.VmPolicy.Builder vmPolicyBuilder =\n    new StrictMode.VmPolicy.Builder()\n    .detectAll()\n    .penaltyLog();\n    threadPolicyBuilder.penaltyFlashScreen();\n    vmPolicyBuilder.setClassInstanceLimit(WebActivity.class, 1);\n    StrictMode.setThreadPolicy(threadPolicyBuilder.build());\n    StrictMode.setVmPolicy(vmPolicyBuilder.build());\n}\n\n```\n\n*   在webview中，对于android4.4以上的版本，我们开启调试模式\n\n```\nif (FApplication.DEBUG && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\n    WebView.setWebContentsDebuggingEnabled(true);\n}\n\n```\n\n*   最后不可缺少的是, leakcanary的加入来跟踪这些消耗内存的组件:\n    在`webfragment`，`webactivity`，`webview` ondestory后加上\n\n```\n    RefWatcher refWatcher = FApplication.getRefWatcher();\n    refWatcher.watch(obj);\n\n```\n\n> 总结: 如果你只是简单地用 webview 做呈现, 使用application context启动webview已经足够了，但如果你需要webview来播放视频，处理弹窗等复杂工作, 新建一个进程来处理会更可靠.\n\n* * *\n\n1.  [Google将不再为Android 4.4之前版本提供WebView补丁](https://link.jianshu.com?t=http://www.leiphone.com/news/201501/1NkxWlVGV1IVMUyr.html) [↩](#fnref1)\n\n2.  [this is how I fixed my WebView leak inside a fragment](https://link.jianshu.com?t=http://stackoverflow.com/a/12408703/1369016) [↩](#fnref2)\n\n作者：jefforeilly\n链接：https://www.jianshu.com/p/c2412918b2b5\n來源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"]],[0,26],[8431,8431]]]]]]}